{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":1},{"_id":"themes/yilia/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":1},{"_id":"themes/yilia/source/img/avatar.png","path":"img/avatar.png","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"source/images/cnzz.png","path":"images/cnzz.png","modified":1},{"_id":"source/images/article-review-insight-3.png","path":"images/article-review-insight-3.png","modified":1},{"_id":"source/images/article-review-insight-2.png","path":"images/article-review-insight-2.png","modified":1},{"_id":"source/images/article-review-insight-1.png","path":"images/article-review-insight-1.png","modified":1},{"_id":"source/images/angular-markdown-note.gif","path":"images/angular-markdown-note.gif","modified":1},{"_id":"source/images/angluar-markdown-note-3.png","path":"images/angluar-markdown-note-3.png","modified":1},{"_id":"source/images/angluar-markdown-note-2.png","path":"images/angluar-markdown-note-2.png","modified":1},{"_id":"source/images/angluar-markdown-note-1.png","path":"images/angluar-markdown-note-1.png","modified":1}],"Cache":[{"_id":"source/_posts/angular/angular-collect.md","shasum":"09d60e7c3cbd7d16f60fac4045cd1e7fddb1dde6","modified":1459759668340},{"_id":"source/_posts/angular/angular-lazyload.md","shasum":"88ea08b85f3694b6ed51b563d36846fc9e00a2ea","modified":1456325279701},{"_id":"source/_posts/angular/angular-markdown-note.md","shasum":"4af9bdfc7e340ca1dc0af0d823525fa10b08cfae","modified":1462373445483},{"_id":"source/_posts/angular/angular-markdown.md","shasum":"2543dba38b09769b63d1b403fa03a930e499d49a","modified":1460651135193},{"_id":"source/_posts/essays/article-review-insight.md","shasum":"7544a45ff461a9aca5261339108fc3b0516c52e9","modified":1462029339242},{"_id":"source/_posts/essays/darktime-reading-note.md","shasum":"ae0db08ed0ce735851b5bbe74cf732d4e3020a31","modified":1462029049397},{"_id":"source/_posts/essays/essays-mechanical-keyboard.md","shasum":"af3fd26fd235ee71d7f8c0c54dcaa0989047b064","modified":1458579354480},{"_id":"source/_posts/essays/leave-office.md","shasum":"8c60e799026250b22224d1e37f0f922747a906f9","modified":1460213404941},{"_id":"source/_posts/essays/reading-list-2016.md","shasum":"ef56332ba8515f68d069c8bc4fd127798b79b5f6","modified":1462030895041},{"_id":"source/_posts/essays/write.md","shasum":"59a961b3204413f2334ca84222cbcadd883edccf","modified":1456062254952},{"_id":"source/_posts/git/git-standard.md","shasum":"2ce8eb495c8f0b78b43da048a639d6721bc78a51","modified":1460216358465},{"_id":"source/_posts/hexo/hexo-guide-1.md","shasum":"2b34dbce8aa17c36751083e9fd95101d9695892d","modified":1459753514430},{"_id":"source/_posts/hexo/hexo-guide-2.md","shasum":"a6af306224ef3ad65dfb5ac0bca19782e185df1a","modified":1456150068498},{"_id":"source/_posts/hexo/hexo-guide-3.md","shasum":"6e42133dac71be2fe6ed0d2d9b86318bd0aa1eee","modified":1456241046197},{"_id":"source/_posts/hexo/hexo-guide-4.md","shasum":"a9b30e388e06a1b345d77e4b8f32167044ba64dc","modified":1462373780561},{"_id":"source/_posts/interview/zhaimi-interview-summary.md","shasum":"d41a5ad23f94e48e812f5d5a3781d3aee7541e8b","modified":1459761275266},{"_id":"source/_posts/javascript/javascirpt-call-method.md","shasum":"997774b2d9dfe387eb0c637f2e5d8cbd8789c344","modified":1462029264227},{"_id":"source/_posts/javascript/javascript-closure.md","shasum":"59fd51bf0abfcdc5b0b6a928329749330046da38","modified":1458405807387},{"_id":"source/_posts/javascript/javascript-hoisting.md","shasum":"77874e905d2f833564111a95bb999b8a20074a44","modified":1457797841529},{"_id":"source/_posts/javascript/javascript-inherit.md","shasum":"d3af5527a2efcdc16703c67815fc411773f9bde5","modified":1457199064891},{"_id":"source/_posts/javascript/javascript-learning-object.md","shasum":"2f8ad3cb7e868b2485887f0cdfe81a17ae1a0952","modified":1457198999632},{"_id":"source/_posts/javascript/you-donot-konw-javascript-reading-notes-2.md","shasum":"8a942ec0c8f10601672f0cc37d346edbb4ca9365","modified":1458219993331},{"_id":"source/_posts/javascript/you-donot-konw-javascript-reading-notes.md","shasum":"c1ea229e6c661d817c6c5b9b8227541162fb41eb","modified":1459756666370},{"_id":"source/_posts/mobile/mobile-collect.md","shasum":"1d91e9559bdcadbcdeabfc66ea92f5eef4857c2d","modified":1457791791392},{"_id":"source/_posts/mobile/wechat-clean-cache.md","shasum":"69496887e4c36de7bb477a9cf18850fd6107f832","modified":1460037371505},{"_id":"source/_posts/project-summary-uular.md","shasum":"67dbacf61f3e632570e6d58dd5bbececd9a7ee27","modified":1457792375834},{"_id":"source/files/editor_md.html","shasum":"a86251c114d93e3eb0d4c397a2c0015d1f972d02","modified":1458222245335},{"_id":"source/images/angluar-markdown-note-1.png","shasum":"c3dc9a969306ab63d622edf789795e36bdd328e2","modified":1462369130838},{"_id":"source/images/angluar-markdown-note-2.png","shasum":"c0de95c12569e1908515692135c31eb3be547aca","modified":1462369735604},{"_id":"source/images/angluar-markdown-note-3.png","shasum":"ca8b28c8c3c3405246df6e376d9d8361fb539c9d","modified":1462370163746},{"_id":"source/images/article-review-insight-2.png","shasum":"4e025fcf43625094610e78e5ecdaac278e8e4df6","modified":1461078845622},{"_id":"source/images/article-review-insight-3.png","shasum":"9c1b6ae89ae3ecf4e7a1ecf0c611b063ac822928","modified":1461077791580},{"_id":"source/images/cnzz.png","shasum":"9d997129aed64fe1c90f92ca561bd2433e3c8789","modified":1456238520554},{"_id":"source/images/article-review-insight-1.png","shasum":"046f75b0ebe4cfe21af0d5df0edda25625be081d","modified":1461078831043},{"_id":"themes/yilia/README.md","shasum":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1456027247669},{"_id":"themes/yilia/_config.yml","shasum":"29580e10f64047bb4a115a188a0a0c6c392f63ed","modified":1461080343123},{"_id":"themes/yilia/languages/de.yml","shasum":"bc80f78f61c3d7af9652e6aa6fc3e4ff39b0c8d3","modified":1456027247676},{"_id":"themes/yilia/languages/default.yml","shasum":"f0a7a032b31555c9ec05a711e1ac19bb07724708","modified":1456027247683},{"_id":"themes/yilia/languages/en.yml","shasum":"a093e794aef63ec9e9e9ef490cf7e4474e45e59f","modified":1456027247687},{"_id":"themes/yilia/languages/fr-FR.yml","shasum":"04b9a0d80d88d01e039e8077afe88f741e9620ba","modified":1456027247690},{"_id":"themes/yilia/languages/ru.yml","shasum":"62f84ea82a696060c481fc22d4742e6201bb9bdc","modified":1456027247697},{"_id":"themes/yilia/languages/zh-Hans.yml","shasum":"d2336578e14bb880d152266981c2b17523fc8742","modified":1456027247701},{"_id":"themes/yilia/languages/zh-hk.yml","shasum":"e702fc43556e54c396917bdf7c869d528742e28b","modified":1456027247705},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","shasum":"3709af4e8f7e1196dbd1f9dea62fa440d4b47836","modified":1456027247733},{"_id":"themes/yilia/languages/zh-tw.yml","shasum":"005559baa96b7bb34e1efe6b031829a95d58d5e0","modified":1456027247710},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","shasum":"5b29a383418cfdcf8d5c5719b4fc4608aaba6fe7","modified":1456027247736},{"_id":"themes/yilia/layout/_partial/archive.ejs","shasum":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1456027247753},{"_id":"themes/yilia/layout/_partial/article.ejs","shasum":"0f3033ea411eabb7a57cf16f08fde468f83add6b","modified":1456152612721},{"_id":"themes/yilia/layout/_partial/cnzz_tongji.ejs","shasum":"fc26f4bf24a9478192710ec420a0432f08c8b8d7","modified":1456241298555},{"_id":"themes/yilia/layout/_partial/footer.ejs","shasum":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1456027247778},{"_id":"themes/yilia/layout/_partial/head.ejs","shasum":"8fde5ac9e7d10625d9ab9317e008d26d3c02e3a6","modified":1458369146839},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","shasum":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1456027247786},{"_id":"themes/yilia/layout/_partial/header.ejs","shasum":"b69855e07b65117769adc515cb64b803932068c9","modified":1456027247813},{"_id":"themes/yilia/layout/_partial/left-col.ejs","shasum":"774bd80765760c97db1488da646b8a49e4f44fc9","modified":1462030755253},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","shasum":"7be03a92dabeb2f94bf0e731d12a1c1146d736dd","modified":1456027247840},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","shasum":"6a7a2a4960dabf9d7cd523573da7869eebf4b02d","modified":1456027247846},{"_id":"themes/yilia/layout/_partial/post/category.ejs","shasum":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1456027247855},{"_id":"themes/yilia/layout/_partial/post/date.ejs","shasum":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1456027247859},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","shasum":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1456027247872},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","shasum":"c115c282eebfb6b18612d2d8733272c270b03066","modified":1456027247878},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","shasum":"4ab6cab2a975a4df8419448b33dec4724279d85c","modified":1456027247883},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","shasum":"d50294bf9858e7942208c380e851a37ed37f1d6f","modified":1456027247888},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","shasum":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1456027247897},{"_id":"themes/yilia/layout/_partial/post/title.ejs","shasum":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1456027247902},{"_id":"themes/yilia/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1456027247905},{"_id":"themes/yilia/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1456027247911},{"_id":"themes/yilia/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1456027247914},{"_id":"themes/yilia/layout/layout.ejs","shasum":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1456027247924},{"_id":"themes/yilia/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1456027247928},{"_id":"themes/yilia/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1456027247930},{"_id":"themes/yilia/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1456027247935},{"_id":"themes/yilia/package.json","shasum":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1456027247938},{"_id":"themes/yilia/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1456027247951},{"_id":"themes/yilia/source/css/_partial/archive.styl","shasum":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1456027247956},{"_id":"themes/yilia/source/css/_partial/article.styl","shasum":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1456027247961},{"_id":"themes/yilia/source/css/_partial/footer.styl","shasum":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1456027247965},{"_id":"themes/yilia/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1456027247969},{"_id":"themes/yilia/source/css/_partial/highlight.styl","shasum":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1456027247973},{"_id":"themes/yilia/source/css/_partial/instagram.styl","shasum":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1456027247977},{"_id":"themes/yilia/source/css/_partial/main.styl","shasum":"bfaa5979188612175c90ae881ed16b6870a51bc8","modified":1456063063046},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","shasum":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1456027247985},{"_id":"themes/yilia/source/css/_partial/mobile.styl","shasum":"c44f4c9068160f7ee679c0faf6cda898cd21225e","modified":1456326471164},{"_id":"themes/yilia/source/css/_partial/page.styl","shasum":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1456027247994},{"_id":"themes/yilia/source/css/_partial/scroll.styl","shasum":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1456027247999},{"_id":"themes/yilia/source/css/_partial/share.styl","shasum":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1456027248003},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","shasum":"af0115de5c6455f899a2e09225b50224982c039d","modified":1456027248009},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","shasum":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1456027248013},{"_id":"themes/yilia/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1456027248017},{"_id":"themes/yilia/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1456027248026},{"_id":"themes/yilia/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1456027248032},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1456027248039},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1456027248051},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","shasum":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1456027248057},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1456027248062},{"_id":"themes/yilia/source/css/style.styl","shasum":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1456027248066},{"_id":"themes/yilia/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1456027248068},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1456027248069},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1456027248070},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1456027248071},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1456027248072},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1456027248073},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1456027248076},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1456027248079},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1456027248084},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1456027248091},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1456027248094},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1456027248100},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","shasum":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1456027248104},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","shasum":"004bb0812414554ab48067792f09e978603253b6","modified":1456027248116},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","shasum":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1456027248127},{"_id":"themes/yilia/source/img/avatar.png","shasum":"69470d1a8a3a5e39dc22fc8f0ff6e1e735ac0986","modified":1456035285536},{"_id":"themes/yilia/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1456027248128},{"_id":"themes/yilia/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1456027248130},{"_id":"themes/yilia/source/img/douban.png","shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1456027248131},{"_id":"themes/yilia/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1456027248132},{"_id":"themes/yilia/source/img/favicon.ico","shasum":"e7b7dbb3c7c62aef9e5bddcae3ca87df20c78e0f","modified":1456032156747},{"_id":"themes/yilia/source/img/github.png","shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1456027248133},{"_id":"themes/yilia/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1456027248134},{"_id":"themes/yilia/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1456027248136},{"_id":"themes/yilia/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1456027248136},{"_id":"themes/yilia/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1456027248138},{"_id":"themes/yilia/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1456027248139},{"_id":"themes/yilia/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1456027248140},{"_id":"themes/yilia/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1456027248141},{"_id":"themes/yilia/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1456027248142},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1456027248143},{"_id":"themes/yilia/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1456027248144},{"_id":"themes/yilia/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1456027248146},{"_id":"themes/yilia/source/img/weibo.png","shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1456027248148},{"_id":"themes/yilia/source/img/zhihu.png","shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1456027248149},{"_id":"themes/yilia/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1456027248162},{"_id":"themes/yilia/source/js/jquery.lazyload.js","shasum":"9c34c37b4dca82386648d364da913153d1db902e","modified":1456027248169},{"_id":"themes/yilia/source/js/main.js","shasum":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1456027248174},{"_id":"themes/yilia/source/js/mobile.js","shasum":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1456027248181},{"_id":"themes/yilia/source/js/pc.js","shasum":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1456027248187},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1456027248046},{"_id":"source/images/angular-markdown-note.gif","shasum":"e3c50d92b80ea5c9317b60620d3bddf5af09fbd3","modified":1462372158884},{"_id":"public/js/pc.js","modified":1462374104085,"shasum":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10"},{"_id":"public/js/mobile.js","modified":1462374104090,"shasum":"b68cc01d24e80973c48205f551da87f3f3427644"},{"_id":"public/js/main.js","modified":1462374104093,"shasum":"0640b68a76fab3c693b3cd1e4d04d14be1e53940"},{"_id":"public/js/jquery.lazyload.js","modified":1462374104096,"shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799"},{"_id":"public/js/instagram.js","modified":1462374104098,"shasum":"f19adbcc0dac33536bc6660598059048ec901882"},{"_id":"public/img/zhihu.png","modified":1462374104107,"shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d"},{"_id":"public/img/weibo.png","modified":1462374104111,"shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b"},{"_id":"public/img/twitter.png","modified":1462374104113,"shasum":"14dbb8e62d056525253bc0de13acd1723da7a934"},{"_id":"public/img/stackoverflow.png","modified":1462374104116,"shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2"},{"_id":"public/img/scrollbar_arrow.png","modified":1462374104119,"shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0"},{"_id":"public/img/rss.png","modified":1462374104121,"shasum":"430fd47340e75214c081abd05cd7410cf7c71b86"},{"_id":"public/img/pinterest.png","modified":1462374104125,"shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630"},{"_id":"public/img/pinboard.png","modified":1462374104128,"shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0"},{"_id":"public/img/mail.png","modified":1462374104132,"shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7"},{"_id":"public/img/linkedin.png","modified":1462374104136,"shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c"},{"_id":"public/img/img-loading.png","modified":1462374104138,"shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031"},{"_id":"public/img/img-err.png","modified":1462374104142,"shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b"},{"_id":"public/img/google.png","modified":1462374104145,"shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d"},{"_id":"public/img/github.png","modified":1462374104149,"shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d"},{"_id":"public/img/favicon.ico","modified":1462374104152,"shasum":"e7b7dbb3c7c62aef9e5bddcae3ca87df20c78e0f"},{"_id":"public/img/facebook.png","modified":1462374104154,"shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54"},{"_id":"public/img/douban.png","modified":1462374104158,"shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e"},{"_id":"public/img/delicious.png","modified":1462374104161,"shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd"},{"_id":"public/img/coderwall.png","modified":1462374104163,"shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331"},{"_id":"public/img/avatar.png","modified":1462374104166,"shasum":"69470d1a8a3a5e39dc22fc8f0ff6e1e735ac0986"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1462374104170,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1462374104174,"shasum":"a82597493d75ea989ca586e09173cff332efe41e"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1462374104176,"shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1462374104180,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1462374104183,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1462374104190,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1462374104194,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1462374104196,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1462374104200,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1462374104203,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1462374104206,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1462374104209,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1462374104212,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1462374104215,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1462374104218,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1462374105480,"shasum":"8c5b2578d5712ac630d1cf6923a8e2d64c2a2739"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1462374105899,"shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1462374105903,"shasum":"1480b8101b02da9bc4c60341b5e185e63e585064"},{"_id":"public/css/fonts/fontawesome-webfont.svgz","modified":1462374105914,"shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1462374105919,"shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1462374105924,"shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6"},{"_id":"public/images/cnzz.png","modified":1462374105930,"shasum":"9d997129aed64fe1c90f92ca561bd2433e3c8789"},{"_id":"public/images/article-review-insight-3.png","modified":1462374105935,"shasum":"9c1b6ae89ae3ecf4e7a1ecf0c611b063ac822928"},{"_id":"public/images/article-review-insight-2.png","modified":1462374105940,"shasum":"4e025fcf43625094610e78e5ecdaac278e8e4df6"},{"_id":"public/images/article-review-insight-1.png","modified":1462374105944,"shasum":"046f75b0ebe4cfe21af0d5df0edda25625be081d"},{"_id":"public/images/angular-markdown-note.gif","modified":1462374105950,"shasum":"e3c50d92b80ea5c9317b60620d3bddf5af09fbd3"},{"_id":"public/images/angluar-markdown-note-3.png","modified":1462374105955,"shasum":"ca8b28c8c3c3405246df6e376d9d8361fb539c9d"},{"_id":"public/images/angluar-markdown-note-2.png","modified":1462374105959,"shasum":"c0de95c12569e1908515692135c31eb3be547aca"},{"_id":"public/images/angluar-markdown-note-1.png","modified":1462374105963,"shasum":"c3dc9a969306ab63d622edf789795e36bdd328e2"},{"_id":"public/files/editor_md.html","modified":1462374106030,"shasum":"cfae51c4a808423c15985fd0a9cfb0c931545fc6"},{"_id":"public/2016/05/04/angular/angular-markdown-note/index.html","modified":1462374106099,"shasum":"7e791f8813568b4d7f3bef3c1e5677b7ad2fea11"},{"_id":"public/2016/04/30/essays/darktime-reading-note/index.html","modified":1462374106127,"shasum":"330ea86fe1ed7ec6a59ed8253f53f2ef45d50349"},{"_id":"public/2016/04/30/essays/reading-list-2016/index.html","modified":1462374106158,"shasum":"313e83074462794d580a9e58767a0d38ccba0abb"},{"_id":"public/2016/04/20/javascript/javascirpt-call-method/index.html","modified":1462374106191,"shasum":"64eceeea63812b0199951a2e1bf3e1e690b9b6e0"},{"_id":"public/2016/04/19/essays/article-review-insight/index.html","modified":1462374106213,"shasum":"15342d233d777a3327a5e760c565bfcedf2a49fc"},{"_id":"public/2016/04/15/angular/angular-markdown/index.html","modified":1462374106242,"shasum":"7a4cbd3aa67245c9c428b4e6684d2ce50e624df5"},{"_id":"public/2016/04/09/git/git-standard/index.html","modified":1462374106274,"shasum":"230d816f4397292611e46b4605360da085b6d3d4"},{"_id":"public/2016/04/07/essays/leave-office/index.html","modified":1462374106301,"shasum":"dd7f2cc2d772627388d849a7ed685969d392d189"},{"_id":"public/2016/04/07/mobile/wechat-clean-cache/index.html","modified":1462374106321,"shasum":"b4d850ded29b933342df04568b228349dc64ec0b"},{"_id":"public/2016/04/04/interview/zhaimi-interview-summary/index.html","modified":1462374106344,"shasum":"b1241e597aabd21613786cb2cd7b9be32abebb97"},{"_id":"public/2016/04/04/angular/angular-collect/index.html","modified":1462374106374,"shasum":"15a103df32c9b3e075347aba328b4b955ff841e0"},{"_id":"public/2016/03/22/essays/essays-mechanical-keyboard/index.html","modified":1462374106400,"shasum":"c63b81c823afcb57f06f8136371ba72409210fdd"},{"_id":"public/2016/03/20/javascript/javascript-closure/index.html","modified":1462374106429,"shasum":"d57554ece9d1882ab34cf66ff903e21b92d64400"},{"_id":"public/2016/03/15/javascript/you-donot-konw-javascript-reading-notes-2/index.html","modified":1462374106453,"shasum":"be4e9cb50b9f4778d3caa19d144caf313c3c3759"},{"_id":"public/2016/03/12/javascript/you-donot-konw-javascript-reading-notes/index.html","modified":1462374106479,"shasum":"a72d7b56735ec4bf39e915974fdfa7a8756b6307"},{"_id":"public/2016/03/12/project-summary-uular/index.html","modified":1462374106504,"shasum":"34bf35c8946c030e8177a0a2e828a6568606761e"},{"_id":"public/2016/03/06/javascript/javascript-inherit/index.html","modified":1462374106548,"shasum":"c56a61c4616f12d9f4b793b7c8a2ce2a8f8635c2"},{"_id":"public/2016/03/05/javascript/javascript-hoisting/index.html","modified":1462374106567,"shasum":"ca200a2ab0fafd999232958defdcec83367aab9f"},{"_id":"public/2016/02/29/mobile/mobile-collect/index.html","modified":1462374106589,"shasum":"be9855b473a4138a204b06f0b8abec1ce790a5eb"},{"_id":"public/2016/02/26/javascript/javascript-learning-object/index.html","modified":1462374106618,"shasum":"03c92c7c118a6050069fe23bfe0263bf1a6fd499"},{"_id":"public/2016/02/24/angular/angular-lazyload/index.html","modified":1462374106644,"shasum":"27d6ea8d734ddd05d7a0ca6292f8614e42d7f9ce"},{"_id":"public/2016/02/23/hexo/hexo-guide-4/index.html","modified":1462374106668,"shasum":"04dcec55ef8b2084e1454756e80b1e514a8bae82"},{"_id":"public/2016/02/22/hexo/hexo-guide-3/index.html","modified":1462374106693,"shasum":"6db73bdc9f1d7163e978e2126c780ac50767f87e"},{"_id":"public/2016/02/21/hexo/hexo-guide-2/index.html","modified":1462374106723,"shasum":"55567be84671d35ac3b673946d77e2d9fbe4eb9d"},{"_id":"public/2016/02/21/hexo/hexo-guide-1/index.html","modified":1462374106751,"shasum":"88ac783e01cb7db28041c03ad625075ab19f0eb3"},{"_id":"public/2016/02/21/essays/write/index.html","modified":1462374106769,"shasum":"ca341d4f5c31d6af36c835328df2283f70f8778a"},{"_id":"public/archives/index.html","modified":1462374106899,"shasum":"fc0c4bb40cf1764594f0cd40f675b8f6fe96b363"},{"_id":"public/archives/2016/index.html","modified":1462374107044,"shasum":"4c90d61037c30aa7084cb3fc189aaea3fa512e55"},{"_id":"public/archives/2016/02/index.html","modified":1462374107096,"shasum":"ad8b5e0218475d2f15e9509c8f7f127501871851"},{"_id":"public/archives/2016/03/index.html","modified":1462374107136,"shasum":"40bc9a080a03899e207b48146fad1fc800d94c69"},{"_id":"public/archives/2016/04/index.html","modified":1462374107185,"shasum":"ce0a5d18174923f51a3c9bc00acedd5b097be342"},{"_id":"public/archives/2016/05/index.html","modified":1462374107202,"shasum":"339c7ab02e4c5fd53585c3e2c3e200984e0d6379"},{"_id":"public/index.html","modified":1462374107233,"shasum":"2ecb86bb60ab23db3ef9a3b6e526a960afddcb50"},{"_id":"public/page/2/index.html","modified":1462374107265,"shasum":"19769a543fb9bc0056ce170e85572ec785195bb6"},{"_id":"public/page/3/index.html","modified":1462374107293,"shasum":"de7700740ed1765d57d73899520f9dd787821fb4"},{"_id":"public/page/4/index.html","modified":1462374107322,"shasum":"9011c3c69488ed7dc1a08f5d77dec5ccd4242b3d"},{"_id":"public/page/5/index.html","modified":1462374107351,"shasum":"6fd7453cf2dda0c5b3176e660bc069321f9df2d3"},{"_id":"public/page/6/index.html","modified":1462374107366,"shasum":"58da637e1dbc3829011d0f48666f030c6bf3c9b9"},{"_id":"public/tags/AngularJS/index.html","modified":1462374107400,"shasum":"364d2af4fed87c76f1454415e7fca3b211119536"},{"_id":"public/tags/移动端/index.html","modified":1462374107420,"shasum":"891e823ec655aec72af8b9c8f502f78eceac9813"},{"_id":"public/tags/rem布局/index.html","modified":1462374107437,"shasum":"225ad7d48c1e8ede8df73e9fc9d2f0df5fc04a4b"},{"_id":"public/tags/微信/index.html","modified":1462374107451,"shasum":"3173d9756fa6cc1bc442b58d3051d0f8fc4e0f4c"},{"_id":"public/tags/JavaScript/index.html","modified":1462374107545,"shasum":"10a917af0f2530b0377ff7b376c30a52741e4fa1"},{"_id":"public/tags/JavaScript学习笔记/index.html","modified":1462374107580,"shasum":"0c308b1eba8e62fcc823a8a8855676d7a36c498d"},{"_id":"public/tags/JavaScript高级程序设计学习笔记/index.html","modified":1462374107601,"shasum":"649634f216fdc46a1f611c1e56d425ec6dc8066c"},{"_id":"public/tags/面向对象/index.html","modified":1462374107618,"shasum":"85ecd8741f53d1262a5fe47413269892c4c4313d"},{"_id":"public/tags/对象/index.html","modified":1462374107631,"shasum":"70799ce3031fda244030de0d270e3b0d62b1b3f3"},{"_id":"public/tags/继承/index.html","modified":1462374107647,"shasum":"2739760bc341b766b624a60564d0f0993cc44109"},{"_id":"public/tags/面试总结/index.html","modified":1462374107662,"shasum":"1958c5e4c59d0dd2684bb9b42ad9af3e847b4e9e"},{"_id":"public/tags/Hexo/index.html","modified":1462374107700,"shasum":"32f30f4eb64d8de408284616e1781a87045cec9a"},{"_id":"public/tags/Git/index.html","modified":1462374107716,"shasum":"cffefc743b7d0ca060046b22353788e672c8e48b"},{"_id":"public/tags/Git规范/index.html","modified":1462374107731,"shasum":"a86fb24c120e7fdf5d6582960a5bb69c2066042f"},{"_id":"public/tags/随笔/index.html","modified":1462374107769,"shasum":"587f4a135ecd5d1c5372e43f4d4f501affafd174"},{"_id":"public/tags/随笔/page/2/index.html","modified":1462374107786,"shasum":"618736e16c26395edc0d808dc9fdb909bfb976dd"},{"_id":"public/tags/阅读书单/index.html","modified":1462374107803,"shasum":"2f310836c35cc048127717f0292c4df524b33292"},{"_id":"public/tags/机械键盘/index.html","modified":1462374107821,"shasum":"ff69f72198cc458fc3b9b0002f4cf38718d90fc6"},{"_id":"public/tags/读书笔记/index.html","modified":1462374107841,"shasum":"591de8b009211f26ed5bb6aa5148116234c703f2"},{"_id":"public/tags/读后感/index.html","modified":1462374107861,"shasum":"ed2effa5e8ed32dc801e1f33f2958d5ef72fb38b"},{"_id":"public/tags/markdown/index.html","modified":1462374107885,"shasum":"3b69353069ef5b88bf9cd92af223f05f598afe2b"},{"_id":"public/tags/动态加载/index.html","modified":1462374107901,"shasum":"f3ffb6cd12c53bbb78e9b06f7506e8ec5d60941e"}],"Category":[],"Data":[],"Page":[{"_content":"<style type=\"text/css\">.e{position:absolute;top:0;right:50%;bottom:0;left:0;} .c{position:absolute;overflow:auto;top:0;right:0;bottom:0;left:50%;}</style><div class=\"e\" id=\"editor\"></div><div class=\"c\"></div><script src=\"http://d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js\" type=\"text/javascript\" charset=\"utf-8\"></script><script src=\"http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js\"></script><script> function showResult(e){consoleEl.innerHTML=e}var e=ace.edit(\"editor\");e.setTheme(\"ace/theme/monokai\");e.getSession().setMode(\"ace/mode/markdown\");var consoleEl=document.getElementsByClassName(\"c\")[0];var converter=new Showdown.converter;e.commands.addCommand({name:\"markdown\",bindKey:{win:\"Ctrl-M\",mac:\"Command-M\"},exec:function(t){var n=e.getSession().getMode().$id;if(n==\"ace/mode/markdown\"){showResult(converter.makeHtml(t.getValue()))}},readOnly:true})</script>","source":"files/editor_md.html","raw":"<style type=\"text/css\">.e{position:absolute;top:0;right:50%;bottom:0;left:0;} .c{position:absolute;overflow:auto;top:0;right:0;bottom:0;left:50%;}</style><div class=\"e\" id=\"editor\"></div><div class=\"c\"></div><script src=\"http://d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js\" type=\"text/javascript\" charset=\"utf-8\"></script><script src=\"http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js\"></script><script> function showResult(e){consoleEl.innerHTML=e}var e=ace.edit(\"editor\");e.setTheme(\"ace/theme/monokai\");e.getSession().setMode(\"ace/mode/markdown\");var consoleEl=document.getElementsByClassName(\"c\")[0];var converter=new Showdown.converter;e.commands.addCommand({name:\"markdown\",bindKey:{win:\"Ctrl-M\",mac:\"Command-M\"},exec:function(t){var n=e.getSession().getMode().$id;if(n==\"ace/mode/markdown\"){showResult(converter.makeHtml(t.getValue()))}},readOnly:true})</script>","date":"2016-03-17T13:44:05.335Z","updated":"2016-03-17T13:44:05.335Z","path":"files/editor_md.html","title":"","comments":1,"layout":"page","_id":"cinszs7jo0003rwtzj4tyx261"}],"Post":[{"title":"关于AngularJS的一些坑","date":"2016-04-04T08:45:39.000Z","_content":"本文是搜集学习AngularJS和开发中收集的一些坑。持续更新。\n<!-- more -->\n## 1、select第一行出现空白\n在使用带有angular数据绑定功能的HTML SELECT 元素时，如果不指定default value的话，第一个option会出现空白，如下图：\n\n解决办法：\n`为select添加 一个 默认的option`\n```javascript\n    <select ng-model=\"myColor\" ng-options=\"d.id for d in data\">\n            <option value=\"\">请选择</option>\n     </select>\n```\n## 2、AngularJS在IE的XHR请求存在Bug。\nIE只会在第一次才会从服务器中去请求XHR数据，之后的XHR请求都是从缓存中取。 \n解决办法：禁用IE对ajax的缓存\nhttp://stackoverflow.com/questions/16098430/angular-ie-caching-issue-for-http\n具体代码如下：\n```javascript\nmyModule.config(['$httpProvider', function($httpProvider) {\n    //initialize get if not there\n    if (!$httpProvider.defaults.headers.get) {\n        $httpProvider.defaults.headers.get = {};  \n    }  \n \n    // Answer edited to include suggestions from comments\n    // because previous version of code introduced browser-related errors\n \n    //disable IE ajax request caching\n    $httpProvider.defaults.headers.get['If-Modified-Since'] = 'Mon, 26 Jul 1997 05:00:00 GMT';\n    // extra\n    $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';\n    $httpProvider.defaults.headers.get['Pragma'] = 'no-cache';}]);\n```\n## 3、使用ui-bootstrap中的$modal出现编译错误\n问题描述:在页面一加载的时候就去调用`$modal`服务的话，会报错对象的模板页面找不到。\n解决办法：使用`$timeout`，延迟100ms之后再去调用`$modal`服务。\n```javascript\n $timeout(function () {\n            if($scope.isDated){\n                $modal.open({\n                    backdrop: 'static',\n                    keyboard: false,\n                    animation: true,\n                    templateUrl: 'activity_reward_dated_modal.html',\n                    controller: 'ActivityRewardDatedModalCtrl'\n                });\n            }\n        },100)\n```\n## 4、页面出现表达式闪烁\n\n### 1、为什么会出现表达式{{express}}闪烁？\n　　因为我们利用JavaScript操作DOM，都需要等待DOM Ready完成。AngularJS也会在DOM Ready完成后才会去解析页面上的视图模板。在AngularJS开始工作之前，用户会看到表达式本身，之后才会被替换为表达式的求值结果。\n### 2、表达式闪烁解决方案：主要有两种解决方案\n* 把{{express}}替换为ng-bind因为ng-bind只是html节点的拓展属性，浏览器并不理解这个未知的属性，因为浏览器不会显示它。\n```\n<div ng-bind='express'></div>\n```\n* 利用AngularJS提供的ngCloak来标记AngularJS出现的节点。ngCloak主要利用CSSdisplay属性来控制显示和隐藏表达式模块。\n```\n<div ng-cloak>{{express}}</div>\n```\n#### ngCloak实现原理\n　　AngularJS会在文件加载的同时向HTML的head元素添加ng-hide、ng-cloak的样式定义。这样在浏览器初始化页面的时候，添加了ngCloak指令的节点会被`ng-cloak`这个样式隐藏掉，因此在AngularJS解析视图模板之前，我们看不到ng-cloak指令的节点。\n那么被隐藏的节点又是怎么样在视图解析完成后显示出来的呢？\n　　complie函数会在AngularJS开始解析模板指令的时候被执行，它会移除在DOM节点上的ngCloak属性和ngCloak样式，这样带有ng-cloak指令的的DOM节点就会被正常显示出来。\n\n## 5、使用第三方插件的时候，会出现无法动态绑定值\n　　AngularJS是通过“脏检查”来实现动态绑定的。然而这种\"脏检查\"机制只能适用于AngularJS内部的行为触发方式比如ng-clcik、ng-change等，而不能涵盖所有的AngularJS操作场景。典型的例子就是我们在封装第三方jQuery插件时，不能自动更新视图，而需要我们手动调用`$scope.$apply`。但是往往我们在集成jQuery插件时候调用`$scope.$apply`会出现`digest in progress`错误，那么这时候可以考虑使用`$timeout`来代替.\n　　那为什么手动触发`$scope.$apply`会报`digest in progess`的错误？\n　　AngularJS在任何时候只允许一个`$digest`或者`$apply`操作存在于应用中。因此当应用中已经有`$digest`或者`$apply`操作的时候，如果再手动去触发的话，就会报错`$digest in progress`。\n   \n\n参考资料：\n> https://docs.angularjs.org/error/$rootScope/inprog\n>《AngularJS深度剖析与最佳实践》\n\n\n","source":"_posts/angular/angular-collect.md","raw":"---\ntitle: 关于AngularJS的一些坑\ndate: 2016-04-04 16:45:39\ntags: AngularJS\n---\n本文是搜集学习AngularJS和开发中收集的一些坑。持续更新。\n<!-- more -->\n## 1、select第一行出现空白\n在使用带有angular数据绑定功能的HTML SELECT 元素时，如果不指定default value的话，第一个option会出现空白，如下图：\n\n解决办法：\n`为select添加 一个 默认的option`\n```javascript\n    <select ng-model=\"myColor\" ng-options=\"d.id for d in data\">\n            <option value=\"\">请选择</option>\n     </select>\n```\n## 2、AngularJS在IE的XHR请求存在Bug。\nIE只会在第一次才会从服务器中去请求XHR数据，之后的XHR请求都是从缓存中取。 \n解决办法：禁用IE对ajax的缓存\nhttp://stackoverflow.com/questions/16098430/angular-ie-caching-issue-for-http\n具体代码如下：\n```javascript\nmyModule.config(['$httpProvider', function($httpProvider) {\n    //initialize get if not there\n    if (!$httpProvider.defaults.headers.get) {\n        $httpProvider.defaults.headers.get = {};  \n    }  \n \n    // Answer edited to include suggestions from comments\n    // because previous version of code introduced browser-related errors\n \n    //disable IE ajax request caching\n    $httpProvider.defaults.headers.get['If-Modified-Since'] = 'Mon, 26 Jul 1997 05:00:00 GMT';\n    // extra\n    $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';\n    $httpProvider.defaults.headers.get['Pragma'] = 'no-cache';}]);\n```\n## 3、使用ui-bootstrap中的$modal出现编译错误\n问题描述:在页面一加载的时候就去调用`$modal`服务的话，会报错对象的模板页面找不到。\n解决办法：使用`$timeout`，延迟100ms之后再去调用`$modal`服务。\n```javascript\n $timeout(function () {\n            if($scope.isDated){\n                $modal.open({\n                    backdrop: 'static',\n                    keyboard: false,\n                    animation: true,\n                    templateUrl: 'activity_reward_dated_modal.html',\n                    controller: 'ActivityRewardDatedModalCtrl'\n                });\n            }\n        },100)\n```\n## 4、页面出现表达式闪烁\n\n### 1、为什么会出现表达式{{express}}闪烁？\n　　因为我们利用JavaScript操作DOM，都需要等待DOM Ready完成。AngularJS也会在DOM Ready完成后才会去解析页面上的视图模板。在AngularJS开始工作之前，用户会看到表达式本身，之后才会被替换为表达式的求值结果。\n### 2、表达式闪烁解决方案：主要有两种解决方案\n* 把{{express}}替换为ng-bind因为ng-bind只是html节点的拓展属性，浏览器并不理解这个未知的属性，因为浏览器不会显示它。\n```\n<div ng-bind='express'></div>\n```\n* 利用AngularJS提供的ngCloak来标记AngularJS出现的节点。ngCloak主要利用CSSdisplay属性来控制显示和隐藏表达式模块。\n```\n<div ng-cloak>{{express}}</div>\n```\n#### ngCloak实现原理\n　　AngularJS会在文件加载的同时向HTML的head元素添加ng-hide、ng-cloak的样式定义。这样在浏览器初始化页面的时候，添加了ngCloak指令的节点会被`ng-cloak`这个样式隐藏掉，因此在AngularJS解析视图模板之前，我们看不到ng-cloak指令的节点。\n那么被隐藏的节点又是怎么样在视图解析完成后显示出来的呢？\n　　complie函数会在AngularJS开始解析模板指令的时候被执行，它会移除在DOM节点上的ngCloak属性和ngCloak样式，这样带有ng-cloak指令的的DOM节点就会被正常显示出来。\n\n## 5、使用第三方插件的时候，会出现无法动态绑定值\n　　AngularJS是通过“脏检查”来实现动态绑定的。然而这种\"脏检查\"机制只能适用于AngularJS内部的行为触发方式比如ng-clcik、ng-change等，而不能涵盖所有的AngularJS操作场景。典型的例子就是我们在封装第三方jQuery插件时，不能自动更新视图，而需要我们手动调用`$scope.$apply`。但是往往我们在集成jQuery插件时候调用`$scope.$apply`会出现`digest in progress`错误，那么这时候可以考虑使用`$timeout`来代替.\n　　那为什么手动触发`$scope.$apply`会报`digest in progess`的错误？\n　　AngularJS在任何时候只允许一个`$digest`或者`$apply`操作存在于应用中。因此当应用中已经有`$digest`或者`$apply`操作的时候，如果再手动去触发的话，就会报错`$digest in progress`。\n   \n\n参考资料：\n> https://docs.angularjs.org/error/$rootScope/inprog\n>《AngularJS深度剖析与最佳实践》\n\n\n","slug":"angular/angular-collect","published":1,"updated":"2016-04-04T08:47:48.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7ja0000rwtzn99pzyyo"},{"title":"优乐健身移动端页面制作总结","date":"2016-03-12T13:50:42.000Z","_content":"该项目是优乐健身的移动端页面。刚好利用这个项目用来学习移动端的适配方案：rem布局。 \n<!-- more -->\n\n# 项目介绍\n该项目是优乐健身的移动端页面。网站要求字体和边距做到自适应。因此采用了rem布局。\nrem布局参考资料：\nweb app变革之rem: https://isux.tencent.com/web-app-rem.html\n手机端页面自适应解决方案: http://www.jianshu.com/p/b00cd3506782\n\n# 项目技术点\n## 1、rem布局\nrem布局非常简单，只需要将下面的JavaScript代码放到你的页面中即可。\n```\n(function (doc, win) { \n\tvar docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', \n\trecalc = function () { \n\tvar clientWidth = docEl.clientWidth; \n\tif (!clientWidth) return; \n\tif(clientWidth>=640){ \n\tdocEl.style.fontSize = '100px'; \n\t}\n\telse{ \n\tdocEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; \n\t}\n\t}; \n\tif (!doc.addEventListener) return; \n\twin.addEventListener(resizeEvt, recalc, false); \n\tdoc.addEventListener('DOMContentLoaded', recalc, false); \n\t})(document, window);\n```\n### 如何使用\n先解释下上面的代码，最核心的意思就是说当页面的宽度超过了640px，html的`font-size`为100px。如果小于640px，则通过`100 * (clientWidth / 640)`计算出页面的`font-size`。这时候便可以在网页中尽情使用rem了。所以涉及到宽度和距离的属性比如`width`、`margin`、`padding`、`font-size`等都可以使用rem作为单位。\n那么设计稿中的px值要怎么转换成rem值呢？\n我们可以将font-size的值设成100px，这样1rem = 100px。如果设计稿中的宽度是30px的话，那么就可以很方便的转换为0.3rem。\n**ps:这里设置宽度为640px是根据设计稿来的，如果你拿到的设计稿是750，那么你就可以将上面的数值改为750。**\n\n### rem布局存在的问题\n**存在的问题**：在生成dom树的时候，底部用js改变html的font-size的话，会造成整个页面重新布局，这样的结果就是导致页面元素因为尺寸改变了而闪烁的情况。在页面类容大的时候，加载时页面会有明显的动态变化，\n**解决办法**： \n* 使用一个全局loading页面，在fontSize计算之后才展示真正的页面\n* 用响应式样式控制最好先用响应式，再用js。具体做法就是用CSS的`@media`根据屏幕初始化一遍html的font-size，然后在再用js计算，这样可以避免页面加载时候出现的闪烁。具体的CSS代码如下面：\n```css\n@media only screen and (max-width: 320px){html{font-size: 9px;} }\n@media only screen and (min-width: 320px) and (max-width: 352px){html{font-size: 10px;} }\n@media only screen and (min-width: 352px) and (max-width: 384px){html{font-size: 11px;} }\n@media only screen and (min-width: 384px) and (max-width: 416px){html{font-size: 12px;} }\n@media only screen and (min-width: 416px) and (max-width: 448px){html{font-size: 13px;} }\n@media only screen and (min-width: 448px) and (max-width: 480px){html{font-size: 14px;} }\n@media only screen and (min-width: 480px) and (max-width: 512px){html{font-size: 15px;} }\n@media only screen and (min-width: 512px) and (max-width: 544px){html{font-size: 16px;} }\n@media only screen and (min-width: 544px) and (max-width: 576px){html{font-size: 17px;} }\n@media only screen and (min-width: 576px) and (max-width: 608px){html{font-size: 18px;} }\n@media only screen and (min-width: 608px) and (max-width: 640px){html{font-size: 19px;} }\n@media only screen and (min-width: 640px){html{font-size: 20px;} }\n\n来源： https://isux.tencent.com/web-app-rem.html\n```     \n* 采取淘宝的[flexible.js](https://github.com/amfe/lib-flexible)方案解决。\n```\n## 2、自定义select框\n如何自定义select框的样式\n## 3、移动端直接拨打电话\n\n```html\n<a href=\"tel://110\">电话</a>\n```\n在`a`标签中使用tel://协议，后面跟着电话号码，就可以实现在移动端拨打电话。","source":"_posts/project-summary-uular.md","raw":"---\ntitle: 优乐健身移动端页面制作总结\ndate: 2016-03-12 21:50:42\ntags: \n- 移动端 \n- rem布局\n---\n该项目是优乐健身的移动端页面。刚好利用这个项目用来学习移动端的适配方案：rem布局。 \n<!-- more -->\n\n# 项目介绍\n该项目是优乐健身的移动端页面。网站要求字体和边距做到自适应。因此采用了rem布局。\nrem布局参考资料：\nweb app变革之rem: https://isux.tencent.com/web-app-rem.html\n手机端页面自适应解决方案: http://www.jianshu.com/p/b00cd3506782\n\n# 项目技术点\n## 1、rem布局\nrem布局非常简单，只需要将下面的JavaScript代码放到你的页面中即可。\n```\n(function (doc, win) { \n\tvar docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', \n\trecalc = function () { \n\tvar clientWidth = docEl.clientWidth; \n\tif (!clientWidth) return; \n\tif(clientWidth>=640){ \n\tdocEl.style.fontSize = '100px'; \n\t}\n\telse{ \n\tdocEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; \n\t}\n\t}; \n\tif (!doc.addEventListener) return; \n\twin.addEventListener(resizeEvt, recalc, false); \n\tdoc.addEventListener('DOMContentLoaded', recalc, false); \n\t})(document, window);\n```\n### 如何使用\n先解释下上面的代码，最核心的意思就是说当页面的宽度超过了640px，html的`font-size`为100px。如果小于640px，则通过`100 * (clientWidth / 640)`计算出页面的`font-size`。这时候便可以在网页中尽情使用rem了。所以涉及到宽度和距离的属性比如`width`、`margin`、`padding`、`font-size`等都可以使用rem作为单位。\n那么设计稿中的px值要怎么转换成rem值呢？\n我们可以将font-size的值设成100px，这样1rem = 100px。如果设计稿中的宽度是30px的话，那么就可以很方便的转换为0.3rem。\n**ps:这里设置宽度为640px是根据设计稿来的，如果你拿到的设计稿是750，那么你就可以将上面的数值改为750。**\n\n### rem布局存在的问题\n**存在的问题**：在生成dom树的时候，底部用js改变html的font-size的话，会造成整个页面重新布局，这样的结果就是导致页面元素因为尺寸改变了而闪烁的情况。在页面类容大的时候，加载时页面会有明显的动态变化，\n**解决办法**： \n* 使用一个全局loading页面，在fontSize计算之后才展示真正的页面\n* 用响应式样式控制最好先用响应式，再用js。具体做法就是用CSS的`@media`根据屏幕初始化一遍html的font-size，然后在再用js计算，这样可以避免页面加载时候出现的闪烁。具体的CSS代码如下面：\n```css\n@media only screen and (max-width: 320px){html{font-size: 9px;} }\n@media only screen and (min-width: 320px) and (max-width: 352px){html{font-size: 10px;} }\n@media only screen and (min-width: 352px) and (max-width: 384px){html{font-size: 11px;} }\n@media only screen and (min-width: 384px) and (max-width: 416px){html{font-size: 12px;} }\n@media only screen and (min-width: 416px) and (max-width: 448px){html{font-size: 13px;} }\n@media only screen and (min-width: 448px) and (max-width: 480px){html{font-size: 14px;} }\n@media only screen and (min-width: 480px) and (max-width: 512px){html{font-size: 15px;} }\n@media only screen and (min-width: 512px) and (max-width: 544px){html{font-size: 16px;} }\n@media only screen and (min-width: 544px) and (max-width: 576px){html{font-size: 17px;} }\n@media only screen and (min-width: 576px) and (max-width: 608px){html{font-size: 18px;} }\n@media only screen and (min-width: 608px) and (max-width: 640px){html{font-size: 19px;} }\n@media only screen and (min-width: 640px){html{font-size: 20px;} }\n\n来源： https://isux.tencent.com/web-app-rem.html\n```     \n* 采取淘宝的[flexible.js](https://github.com/amfe/lib-flexible)方案解决。\n```\n## 2、自定义select框\n如何自定义select框的样式\n## 3、移动端直接拨打电话\n\n```html\n<a href=\"tel://110\">电话</a>\n```\n在`a`标签中使用tel://协议，后面跟着电话号码，就可以实现在移动端拨打电话。","slug":"project-summary-uular","published":1,"updated":"2016-03-12T14:19:35.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7jr0004rwtzq4bq0lv5"},{"title":"如何在安卓和iOS中清除微信浏览器的缓存","date":"2016-04-07T13:26:49.000Z","_content":"本文介绍了如何在iOS和Android清除微信浏览器的缓存\n<!-- more -->\n在做微信移动页面开发时，若需要清除缓存，对于Android和iOS平台的清除方法如下：\n# iOS\niOS的微信浏览器中自带刷新按钮。点击微信右上角的菜单->刷新，，即可刷新页面实现清除缓存。\n# Android\n不得不说，Android平台比较坑，没有刷新按钮。关掉应用再开启也不能保证百分百清除缓存。\n对于 Android 版微信，目前微信自动使用了 QQ浏览器的 X5 内核，如果上述方法不可以清掉缓存，可以执行如下操作：\n1、在任意聊天窗口发送：http://debugx5.qq.com\n2、打开这个网址，找到清理缓存，点击清除即可。\n![](http://7xr6yj.com1.z0.glb.clouddn.com/wechat-clean-cache.jpg)\n","source":"_posts/mobile/wechat-clean-cache.md","raw":"---\ntitle: 如何在安卓和iOS中清除微信浏览器的缓存\ndate: 2016-04-07 21:26:49\ntags:\n- 微信\n- 移动端\n---\n本文介绍了如何在iOS和Android清除微信浏览器的缓存\n<!-- more -->\n在做微信移动页面开发时，若需要清除缓存，对于Android和iOS平台的清除方法如下：\n# iOS\niOS的微信浏览器中自带刷新按钮。点击微信右上角的菜单->刷新，，即可刷新页面实现清除缓存。\n# Android\n不得不说，Android平台比较坑，没有刷新按钮。关掉应用再开启也不能保证百分百清除缓存。\n对于 Android 版微信，目前微信自动使用了 QQ浏览器的 X5 内核，如果上述方法不可以清掉缓存，可以执行如下操作：\n1、在任意聊天窗口发送：http://debugx5.qq.com\n2、打开这个网址，找到清理缓存，点击清除即可。\n![](http://7xr6yj.com1.z0.glb.clouddn.com/wechat-clean-cache.jpg)\n","slug":"mobile/wechat-clean-cache","published":1,"updated":"2016-04-07T13:56:11.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7jw0009rwtzgle0z6ax"},{"title":"收集移动端代码","date":"2016-02-29T13:44:05.000Z","_content":"收集了移动端的一些代码，持续更新。\n<!-- more -->\n## 1、input输入框更改placeholder样式\n```cpp\n/* webkit solution*/\ninput :: -webkit-input-placeholder {\n    text-align: center;\n    color: #333;\n}\n/* mozilla solution*/\ninput:-moz-placeholder{\n    text-align: center;\n    color: #333;\n}\n```\n## 2、iOS系统去除input输入框自带的内阴影\n```cpp\ninput{\n    -webkit-appearance: none;\n}\n```\n### 3、去除数字输入框的小三角\n```cpp\n/* webkit*/\ninput::-webkit-outer-spin-button,\ninput:: -webkit-inner-spin-button{\n   -webikt-appearance: none;\n}\n/*mozilla */\ninput[type=\"numer\"]{\n    -moz-appearance: textfield;\n}\n```\n### 4、手机网页中点击链接自动拨打电话\n```\n<a href=”tel://110 ”>电话</a>\n```\n","source":"_posts/mobile/mobile-collect.md","raw":"---\ntitle: 收集移动端代码\ndate: 2016-02-29 21:44:05\ntags: 移动端\n---\n收集了移动端的一些代码，持续更新。\n<!-- more -->\n## 1、input输入框更改placeholder样式\n```cpp\n/* webkit solution*/\ninput :: -webkit-input-placeholder {\n    text-align: center;\n    color: #333;\n}\n/* mozilla solution*/\ninput:-moz-placeholder{\n    text-align: center;\n    color: #333;\n}\n```\n## 2、iOS系统去除input输入框自带的内阴影\n```cpp\ninput{\n    -webkit-appearance: none;\n}\n```\n### 3、去除数字输入框的小三角\n```cpp\n/* webkit*/\ninput::-webkit-outer-spin-button,\ninput:: -webkit-inner-spin-button{\n   -webikt-appearance: none;\n}\n/*mozilla */\ninput[type=\"numer\"]{\n    -moz-appearance: textfield;\n}\n```\n### 4、手机网页中点击链接自动拨打电话\n```\n<a href=”tel://110 ”>电话</a>\n```\n","slug":"mobile/mobile-collect","published":1,"updated":"2016-03-12T14:09:51.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7jz000drwtzeuyp6tmb"},{"title":"【你不知道的JavasSript(上)读书笔记】第1章：作用域","date":"2016-03-12T14:11:54.000Z","_content":"该系列是《你不知道的JavaScript（上）》的读书笔记。记录成文字，加深学习印象。\n<!-- more -->\n# 一、JavaScript编译原理\n传统的语言编译一般经历三个过程：\n* 分词/词法分析\n* 解析/语法分析\n* 代码生成\n而JavaScript引擎则要复杂得多了。简单来说就是任何JavaScript代码在执行前都要进行**编译**（通常在代码执行前）。\n# 二、理解作用域\n要理解作用域之前需要了解下什么是作用域，它有什么作用？同时还需要了解JavaScript引擎和编译器是什么？\n* 引擎\n    从头到尾负责整个JavaScript程序的编译及执行过程。\n* 编译器\n    负责语法分析及代码生成\n* 作用域\n   负责收集并维护由所有声明的标识符（及变量）组成的一系列**查询**，并实施一套**规则**，确定当前执行的代码对这些标识符的**访问权限**（简而言之就是规定了谁有权限访问哪些变量）。\n现在以`var a = 2`这个简单的变量命名过程来分析，JavaScript引擎会将其看做两步`var a;`和`a = 2`两步进行。详见下面的流程图\n![JavaScript变量编译流程图](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_JavaScript%E5%8F%98%E9%87%8F%E7%BC%96%E8%AF%91.png)\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域查找该变量，如果能够找到便对它进行赋值。\n### 关于变量查找的类型\n编译器在编译过程，会对变量进行查询。一种是LHS查询，另外一种查找的类型是RHS。\n* LHS 当变量出现在赋值操作的左侧时进行LHS查询 （赋值操作的目标是谁）\n* RHS 当变量出现在赋值操作的非左侧时，进行RHS查询（谁是赋值操作的源头，取到这个变量的源值）\n试着找出下面的例子各有多少个LHS和RHS\n```javascript\nfunction foo(a){\n    var b = a;\n    return b+a;\n}\nvar c = foo(2);\n```\n_答案在结尾_\n# 三、作用域嵌套\n所谓作用域嵌套就是当一个块或函数嵌套在另外一个块或函数中，就发生了作用域的嵌套。因此在当前作用域无法找到该变量时，就会往外层嵌套作用域中继续寻找，直到找到该变量或者抵达最外层的作用域（也就是全局作用域）为止。\n# 四、异常\n前面提到的LHS和RHS两种查询，如何区分它们是非常重要的一件事。\n因为在变量尚未声明之前，二者的查询行为是不一样的。如下面例子\n```javascript\nfunction foo(a){\n    console.log(b+a);\n    b = a;\n}\nfoo(2);\n```\n想一下，输出的值应该是什么？\n答案：`Uncaught ReferenceError: b is not defined(…)`，结果会报错。因为`b`并没有被定义，因此引擎就抛出`ReferenceError`异常。\n为什么会导致这样的结果呢？这是因为在对变量`b`进行RHS查询的时候，如果在作用域中没有找到该变量，也就是说明这是一个“未声明”的变量，这时候引擎就会抛出`ReferenceError`异常。\n相比较之下，如果是对变量`b`进行LHS查询的时候，如果在全局作用域也没有找到该变量的话，**全局作用域便会自动创建该变量**，前提是在非严格模式下。**这就是LHS和RHS的两种查询类型的区别**。\n同样，在JavaScript中，也有两种异常类型。一种就是刚刚说到的`ReferenceError`，另外一种则是`TypeError`。那这二者有什么区别吗？\n* `ReferenceError`指的是同作用域判别失败相关，简单说就是在作用域找不到该变量。\n* `TypeError`指的是作用域判别成功，但对结果的操作是非法或者不合理的。简单说就是在作用域找到该变量，但是该变量的值不符合。\n\n**前面问题的答案**\nLHS\n* `c=`\n* `a=2`\n* `b=`。\nRHS\n* `foo(2)`\n* `=a`\n* `a`（return的时候要去查找a的值）   \n* `b`（return的时候要去查找b的值）","source":"_posts/javascript/you-donot-konw-javascript-reading-notes.md","raw":"---\ntitle: 【你不知道的JavasSript(上)读书笔记】第1章：作用域\ndate: 2016-03-12 22:11:54\ntags:\n- JavaScript\n- JavaScript学习笔记\n---\n该系列是《你不知道的JavaScript（上）》的读书笔记。记录成文字，加深学习印象。\n<!-- more -->\n# 一、JavaScript编译原理\n传统的语言编译一般经历三个过程：\n* 分词/词法分析\n* 解析/语法分析\n* 代码生成\n而JavaScript引擎则要复杂得多了。简单来说就是任何JavaScript代码在执行前都要进行**编译**（通常在代码执行前）。\n# 二、理解作用域\n要理解作用域之前需要了解下什么是作用域，它有什么作用？同时还需要了解JavaScript引擎和编译器是什么？\n* 引擎\n    从头到尾负责整个JavaScript程序的编译及执行过程。\n* 编译器\n    负责语法分析及代码生成\n* 作用域\n   负责收集并维护由所有声明的标识符（及变量）组成的一系列**查询**，并实施一套**规则**，确定当前执行的代码对这些标识符的**访问权限**（简而言之就是规定了谁有权限访问哪些变量）。\n现在以`var a = 2`这个简单的变量命名过程来分析，JavaScript引擎会将其看做两步`var a;`和`a = 2`两步进行。详见下面的流程图\n![JavaScript变量编译流程图](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_JavaScript%E5%8F%98%E9%87%8F%E7%BC%96%E8%AF%91.png)\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域查找该变量，如果能够找到便对它进行赋值。\n### 关于变量查找的类型\n编译器在编译过程，会对变量进行查询。一种是LHS查询，另外一种查找的类型是RHS。\n* LHS 当变量出现在赋值操作的左侧时进行LHS查询 （赋值操作的目标是谁）\n* RHS 当变量出现在赋值操作的非左侧时，进行RHS查询（谁是赋值操作的源头，取到这个变量的源值）\n试着找出下面的例子各有多少个LHS和RHS\n```javascript\nfunction foo(a){\n    var b = a;\n    return b+a;\n}\nvar c = foo(2);\n```\n_答案在结尾_\n# 三、作用域嵌套\n所谓作用域嵌套就是当一个块或函数嵌套在另外一个块或函数中，就发生了作用域的嵌套。因此在当前作用域无法找到该变量时，就会往外层嵌套作用域中继续寻找，直到找到该变量或者抵达最外层的作用域（也就是全局作用域）为止。\n# 四、异常\n前面提到的LHS和RHS两种查询，如何区分它们是非常重要的一件事。\n因为在变量尚未声明之前，二者的查询行为是不一样的。如下面例子\n```javascript\nfunction foo(a){\n    console.log(b+a);\n    b = a;\n}\nfoo(2);\n```\n想一下，输出的值应该是什么？\n答案：`Uncaught ReferenceError: b is not defined(…)`，结果会报错。因为`b`并没有被定义，因此引擎就抛出`ReferenceError`异常。\n为什么会导致这样的结果呢？这是因为在对变量`b`进行RHS查询的时候，如果在作用域中没有找到该变量，也就是说明这是一个“未声明”的变量，这时候引擎就会抛出`ReferenceError`异常。\n相比较之下，如果是对变量`b`进行LHS查询的时候，如果在全局作用域也没有找到该变量的话，**全局作用域便会自动创建该变量**，前提是在非严格模式下。**这就是LHS和RHS的两种查询类型的区别**。\n同样，在JavaScript中，也有两种异常类型。一种就是刚刚说到的`ReferenceError`，另外一种则是`TypeError`。那这二者有什么区别吗？\n* `ReferenceError`指的是同作用域判别失败相关，简单说就是在作用域找不到该变量。\n* `TypeError`指的是作用域判别成功，但对结果的操作是非法或者不合理的。简单说就是在作用域找到该变量，但是该变量的值不符合。\n\n**前面问题的答案**\nLHS\n* `c=`\n* `a=2`\n* `b=`。\nRHS\n* `foo(2)`\n* `=a`\n* `a`（return的时候要去查找a的值）   \n* `b`（return的时候要去查找b的值）","slug":"javascript/you-donot-konw-javascript-reading-notes","published":1,"updated":"2016-04-04T07:57:46.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7k2000frwtzeatq5h6s"},{"title":"【你不知道的JavasSript(上)读书笔记】第2章：词法作用域","date":"2016-03-14T16:54:54.000Z","_content":"该系列是《你不知道的JavaScript（上）》的读书笔记。记录成文字，加深学习印象。\n<!-- more -->\n# 什么是词法作用域\n词法作用域就是定义在词法阶段的作用域。是不是很难理解呢、换句话说就是，词法作用域意味着**作用域由书写代码时函数的位置**来决定的。如果还不能理解的话，先以一个简单的例子来说明：\n```javascript\n    function fn1(a) {\n        var b = a * 2;\n\n        function fn2(c) {\n        \tconsole.log(a, b, c);\n        }\n        fn2(b * 3);\n    }\n    fn1(2);\t// 2, 4 ,12\n```\n上面这个例子包含着三个作用域\n* 全局作用域\n* fn1的作用域\n* fn2的作用域\n根据它们定义的位置，这三个作用域应该是逐级包含的关系。\n\n如果上面这个例子可以理解的话，那么再来看一个相对复杂一点的例子：\n```javascript\n    function foo() {\n        console.log(a);\n    }\n\n    function bar() {\n        var a = 3;\n        foo();\n    }\n    var a = 2;\n    bar(); // 2\n```\n最终的输出结果是`2`。可能会有人觉得应该输出`3`的，但是为什么却是输出`2`呢？\n根据前面所提到的词法作用域指的是**作用域由书写代码时函数的位置来决定的，而不是代码执行引用的位置**。只要理解了这个概念，就能明白了上面的输出结果了。\n函数`foo`是在全局作用域下定义的，因此它的作用域是属于全局作用域的子作用域。函数`bar`也是一样，属于全局作用域的子作用域。\n虽然函数`foo`在函数`bar`中执行了(二者并不存在父子作用域的关系)，但是函数`fn`此时的父级作用域仍然是全局作用域。因此当引擎执行`console.log(a)`的声明时，会对变量`a`进行RHS查询。引擎在`foo`当前作用域寻找不到`a`，便往上级作用域（对`foo`而言便是全局作用域）寻找，在上级作用域找到了`a=2`，因此就输出了`2`。\n这也就是JavaScript没有动态作用域的原因。如果JavaScript支持动态作用域，那么最后的输出结果应该是`3`，而不是`2`。","source":"_posts/javascript/you-donot-konw-javascript-reading-notes-2.md","raw":"---\ntitle: 【你不知道的JavasSript(上)读书笔记】第2章：词法作用域\ndate: 2016-03-15 00:54:54\ntags:\n- JavaScript\n- JavaScript学习笔记\n---\n该系列是《你不知道的JavaScript（上）》的读书笔记。记录成文字，加深学习印象。\n<!-- more -->\n# 什么是词法作用域\n词法作用域就是定义在词法阶段的作用域。是不是很难理解呢、换句话说就是，词法作用域意味着**作用域由书写代码时函数的位置**来决定的。如果还不能理解的话，先以一个简单的例子来说明：\n```javascript\n    function fn1(a) {\n        var b = a * 2;\n\n        function fn2(c) {\n        \tconsole.log(a, b, c);\n        }\n        fn2(b * 3);\n    }\n    fn1(2);\t// 2, 4 ,12\n```\n上面这个例子包含着三个作用域\n* 全局作用域\n* fn1的作用域\n* fn2的作用域\n根据它们定义的位置，这三个作用域应该是逐级包含的关系。\n\n如果上面这个例子可以理解的话，那么再来看一个相对复杂一点的例子：\n```javascript\n    function foo() {\n        console.log(a);\n    }\n\n    function bar() {\n        var a = 3;\n        foo();\n    }\n    var a = 2;\n    bar(); // 2\n```\n最终的输出结果是`2`。可能会有人觉得应该输出`3`的，但是为什么却是输出`2`呢？\n根据前面所提到的词法作用域指的是**作用域由书写代码时函数的位置来决定的，而不是代码执行引用的位置**。只要理解了这个概念，就能明白了上面的输出结果了。\n函数`foo`是在全局作用域下定义的，因此它的作用域是属于全局作用域的子作用域。函数`bar`也是一样，属于全局作用域的子作用域。\n虽然函数`foo`在函数`bar`中执行了(二者并不存在父子作用域的关系)，但是函数`fn`此时的父级作用域仍然是全局作用域。因此当引擎执行`console.log(a)`的声明时，会对变量`a`进行RHS查询。引擎在`foo`当前作用域寻找不到`a`，便往上级作用域（对`foo`而言便是全局作用域）寻找，在上级作用域找到了`a=2`，因此就输出了`2`。\n这也就是JavaScript没有动态作用域的原因。如果JavaScript支持动态作用域，那么最后的输出结果应该是`3`，而不是`2`。","slug":"javascript/you-donot-konw-javascript-reading-notes-2","published":1,"updated":"2016-03-17T13:06:33.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7k7000krwtzshexphby"},{"title":"【JavaScript高程学习笔记】面向对象的程序设计之对象","date":"2016-02-25T16:45:53.000Z","_content":"本篇文章是学习《Javascript高级程序设计》中关于对象这一部分的学习笔记。\n<!-- more -->\n# 学习内容\n* 理解并创建对象\n* 理解继承\n# 一、理解对象\n对象本质是一组散列表由key-value值组成。而value可以是数据或者函数。可以使用**对象字面量**方法创建对象。\n```javascript\nvar person = {\n    name: 'superman',\n    age: 29,\n    sayName: function(){\n        alert(this.name);    \n    }\n}\n```\n*对象优化建议：*\n\n* **不使用delete操作符，如需要删除属性，直接对属性进行`null`赋值。因为在FF和chrome中，`null`赋值会快99%。**\n* **不要添加属性。定义好对象后，不要随便给对象添加属性，而是一开始就应该定义好对象的结构。这样的运行速度会快很多（FF快100%，Chrome快89%）。**\n\n# 二、创建对象\n创建对象有以下几种模式：\n* 工厂模式\n* 构造函数模式\n* 原型模式\n* 组合使用构造函数模式和原型模式\n* 动态原型模式\n* 寄生构造函数模式\n* 稳妥构造函数模式\n**要求能熟练掌握每种模式的写法，以及他们之间的区别。**\n## 1、工厂模式\n工厂模式是软件工厂领域一种广为人知的设计模式。特点是抽象了创建具体对象的过程。**工厂模式创建函数的例子**：\n```javascript\n//工厂模式\nfunction createPerson(name,age){\n    var obj = new Object(); //需要显式创建对象，并在最后返回该对象\n    obj.name = name;\n    obj.age = age;\n    obj.sayName = function(){\n            alert(this.name);\n    }\n    return obj; //返回该对象\n}\nvar person = createPerson(); //实例化\n```\n工厂模式解决了创建多个相似对象的问题，却没有解决对象识别的问题(即怎么知道一个对象的类型)。因此出现了构造函数模式。\n## 2、构造函数模式\n就好比Object和Array这种原生的构造函数，可以使用构造函数来创建对象。因此也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。**构造函数模式的例子**：\n```javascript\n//构造函数模式\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.sayName = function(){\n        alert(this.name);\n    }\n}\n//实例化\nvar person = new Person();\n```\n*构造函数与工厂模式的区别*\n* 无需显式创建对象；\n* 没有return语句 ；\n* 直接将属性和方法赋给了this对象。\n\n*使用 `new`调用构造函数会经历以下四个步骤*：\n* 创建一个新对象；\n* 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）\n* 执行构造函数中的代码（为这个新对象添加属性）\n* 返回新对象\n\n*构造函数存在的问题*\n使用构造函数时，每个方法都要在每个实例上重新创建一遍。这样会导致创建了多个完成相同任务的function。没有这个必要。因此有了原型模式来解决构造函数所产生的这些问题。\n## 3、原型模式\n我们创建的每个函数都有一个 `prototype(原型)`属性，这个属性是*一个指针，指向一个对象*，而这个对象的用途是包含可以由特定类型的*所有实例共享的属性和方法*。因此为了解决构造函数模式存在的问题，我们可以将通用的方法添加到prototype中，如下面的例子：\n```javascript\n//原型模式\nfunction Person(){\n}\nPerson.prototype = {\n     name : 'superman',\n     age : 29,\n     sayName : function(){\n        alert(this.name);\n    }     \n}\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.sayName == person2.sayName); // true\n```\n通过原型模式创建的对象，由于`sayName()`函数是加到`Person.prototype`上，所有的Person对象实例的`sayName()`都是共享的，因此都属于同一个实例。\n*原型对象存在的问题*：\n1、它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得相同的值。\n2、最大的问题是由于其共享的本性所导致的。由于原型中的属性都是被实例共享的，在属性为基本值的时候倒不会产生太大的问题。但如果属性是引用类型的时候，问题就凸显了。以下面的例子说明：\n```javascript\nfuntion Person(){\n}\nPerson.prototype = {\n    constructor: Person,\n    name: 'superman',\n    friends: ['superman', 'spiderman'],\n    sayName : function(){\n        alert(this.name);\n    }  \n};\nvar person1 = new Person();\nvar person2 = new Person();\nperson1.friends.push('Van'); //由于friends方法被所有实例共享，因此任何一个实例操作这个方法，都会影响到所有的实例调用这个方法。\nconsole.log(person1.friends);     //superman, spiderman, Van\nconsole.log(person2.friends);     //superman, spiderman, Van\nconsole.log(person1.friends === person2.friends);  // true;\n```\n这就是原型模式最大的问题。任何实例对原型上的方法进行操作都会影响的到所有实例对该方法的调用。\n因此引入了下面的这种模式：**组合使用构造函数模式和原型模式**\n## 4、组合使用构造函数模式和原型模式\n这种模式是创建自定义类型的最常见方式。构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。这样模式的优点便是，每个实例都会有自己的一份**实例属性的副本**，但同时又**共享着对方法的引用**，**最大限度地节省了内存**。同时这种模式还支持向构造函数传递参数，可谓急两种模式之长。如下面例子：\n```javascript\nfuntion Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.friends = [\"a\", \"b\"];\n}\nPerson.prototype = {\n    constructor: person,\n    sayName: function(){\n        alert(this.name);\n}\n}\n```\n这种构造函数和原型混成的模式，是目前使用最广泛的一种创建自定义类型的方法。\n\n## 5、动态原型模式\n所谓动态原型模式就是**把所有的信息都封装在构造函数中，而通过在构造函数中初始化原型**，又保持了同时使用构造函数和原型的优点。如下面例子：\n```javascript\n function Person(name, age){\n    //属性\n    this.name = name;\n    this.age = age;\n    //方法\n    if(typeof this.sayName !=  \"function\"){ //通过判断某个应该存在的方法是否有效，来决定是否需要初始化原型。\n        Person.prototype.sayName = function(){\n            alert(this.name);\n        }\n    }\n}\nvar friend = new Person('Nicholas', 29);\nfriend.sayName();          //Nicholas\n```\n动态原型模式可谓非常完美！仅在方法不存在时，才会将它添加到原型中。\n## 6、寄生构造函数模式\n写法与工厂模式一模一样，区别是在创建实例的时候，是通过`new`来创建，与构造函数的实例对象方法一致。这种模式可以在特殊情况下用来为对象创建构造函数。如下面例子：我们可以创建一个具有额外特殊方法的特殊数组。\n```javascript\nfunctio SpecialArray(){\n    //创建数组\n    var values = new Array();\n    // 添加值\n    values.push.apply(values, arguments);\n    //添加方法\n    values,toPipedString = funtion(){\n        return this.join(\"|\");\n    }\n    return values;\n}\nvar colors = new SpecialArray(\"red\", \"blue\", \"black\");\nalert(colors,toPipedString());    //\"red|blue|green\"\n```\n## 7、稳妥构造函数模式\n所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象。\n稳妥对象适用场景：一些安全环境或者在防止数据被其他应用篡改。如下面例子：\n```javacript\nfunction Person(){   \n    //创建要返回对象\n    var o = new Object();\n    //定义私有变量和函数\n    o.sayName = function(){\n        alert(name);    \n    }\n    return o;\n}\n\nvar person = Person(); //不使用new来实例化对象，跟工厂模式一样\nfriend.sayName();\n```\n\n\n","source":"_posts/javascript/javascript-learning-object.md","raw":"---\ntitle: 【JavaScript高程学习笔记】面向对象的程序设计之对象\ndate: 2016-02-26 00:45:53\ntags: \n- JavaScript高级程序设计学习笔记\n- 面向对象\n- 对象\n---\n本篇文章是学习《Javascript高级程序设计》中关于对象这一部分的学习笔记。\n<!-- more -->\n# 学习内容\n* 理解并创建对象\n* 理解继承\n# 一、理解对象\n对象本质是一组散列表由key-value值组成。而value可以是数据或者函数。可以使用**对象字面量**方法创建对象。\n```javascript\nvar person = {\n    name: 'superman',\n    age: 29,\n    sayName: function(){\n        alert(this.name);    \n    }\n}\n```\n*对象优化建议：*\n\n* **不使用delete操作符，如需要删除属性，直接对属性进行`null`赋值。因为在FF和chrome中，`null`赋值会快99%。**\n* **不要添加属性。定义好对象后，不要随便给对象添加属性，而是一开始就应该定义好对象的结构。这样的运行速度会快很多（FF快100%，Chrome快89%）。**\n\n# 二、创建对象\n创建对象有以下几种模式：\n* 工厂模式\n* 构造函数模式\n* 原型模式\n* 组合使用构造函数模式和原型模式\n* 动态原型模式\n* 寄生构造函数模式\n* 稳妥构造函数模式\n**要求能熟练掌握每种模式的写法，以及他们之间的区别。**\n## 1、工厂模式\n工厂模式是软件工厂领域一种广为人知的设计模式。特点是抽象了创建具体对象的过程。**工厂模式创建函数的例子**：\n```javascript\n//工厂模式\nfunction createPerson(name,age){\n    var obj = new Object(); //需要显式创建对象，并在最后返回该对象\n    obj.name = name;\n    obj.age = age;\n    obj.sayName = function(){\n            alert(this.name);\n    }\n    return obj; //返回该对象\n}\nvar person = createPerson(); //实例化\n```\n工厂模式解决了创建多个相似对象的问题，却没有解决对象识别的问题(即怎么知道一个对象的类型)。因此出现了构造函数模式。\n## 2、构造函数模式\n就好比Object和Array这种原生的构造函数，可以使用构造函数来创建对象。因此也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。**构造函数模式的例子**：\n```javascript\n//构造函数模式\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.sayName = function(){\n        alert(this.name);\n    }\n}\n//实例化\nvar person = new Person();\n```\n*构造函数与工厂模式的区别*\n* 无需显式创建对象；\n* 没有return语句 ；\n* 直接将属性和方法赋给了this对象。\n\n*使用 `new`调用构造函数会经历以下四个步骤*：\n* 创建一个新对象；\n* 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）\n* 执行构造函数中的代码（为这个新对象添加属性）\n* 返回新对象\n\n*构造函数存在的问题*\n使用构造函数时，每个方法都要在每个实例上重新创建一遍。这样会导致创建了多个完成相同任务的function。没有这个必要。因此有了原型模式来解决构造函数所产生的这些问题。\n## 3、原型模式\n我们创建的每个函数都有一个 `prototype(原型)`属性，这个属性是*一个指针，指向一个对象*，而这个对象的用途是包含可以由特定类型的*所有实例共享的属性和方法*。因此为了解决构造函数模式存在的问题，我们可以将通用的方法添加到prototype中，如下面的例子：\n```javascript\n//原型模式\nfunction Person(){\n}\nPerson.prototype = {\n     name : 'superman',\n     age : 29,\n     sayName : function(){\n        alert(this.name);\n    }     \n}\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.sayName == person2.sayName); // true\n```\n通过原型模式创建的对象，由于`sayName()`函数是加到`Person.prototype`上，所有的Person对象实例的`sayName()`都是共享的，因此都属于同一个实例。\n*原型对象存在的问题*：\n1、它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得相同的值。\n2、最大的问题是由于其共享的本性所导致的。由于原型中的属性都是被实例共享的，在属性为基本值的时候倒不会产生太大的问题。但如果属性是引用类型的时候，问题就凸显了。以下面的例子说明：\n```javascript\nfuntion Person(){\n}\nPerson.prototype = {\n    constructor: Person,\n    name: 'superman',\n    friends: ['superman', 'spiderman'],\n    sayName : function(){\n        alert(this.name);\n    }  \n};\nvar person1 = new Person();\nvar person2 = new Person();\nperson1.friends.push('Van'); //由于friends方法被所有实例共享，因此任何一个实例操作这个方法，都会影响到所有的实例调用这个方法。\nconsole.log(person1.friends);     //superman, spiderman, Van\nconsole.log(person2.friends);     //superman, spiderman, Van\nconsole.log(person1.friends === person2.friends);  // true;\n```\n这就是原型模式最大的问题。任何实例对原型上的方法进行操作都会影响的到所有实例对该方法的调用。\n因此引入了下面的这种模式：**组合使用构造函数模式和原型模式**\n## 4、组合使用构造函数模式和原型模式\n这种模式是创建自定义类型的最常见方式。构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。这样模式的优点便是，每个实例都会有自己的一份**实例属性的副本**，但同时又**共享着对方法的引用**，**最大限度地节省了内存**。同时这种模式还支持向构造函数传递参数，可谓急两种模式之长。如下面例子：\n```javascript\nfuntion Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.friends = [\"a\", \"b\"];\n}\nPerson.prototype = {\n    constructor: person,\n    sayName: function(){\n        alert(this.name);\n}\n}\n```\n这种构造函数和原型混成的模式，是目前使用最广泛的一种创建自定义类型的方法。\n\n## 5、动态原型模式\n所谓动态原型模式就是**把所有的信息都封装在构造函数中，而通过在构造函数中初始化原型**，又保持了同时使用构造函数和原型的优点。如下面例子：\n```javascript\n function Person(name, age){\n    //属性\n    this.name = name;\n    this.age = age;\n    //方法\n    if(typeof this.sayName !=  \"function\"){ //通过判断某个应该存在的方法是否有效，来决定是否需要初始化原型。\n        Person.prototype.sayName = function(){\n            alert(this.name);\n        }\n    }\n}\nvar friend = new Person('Nicholas', 29);\nfriend.sayName();          //Nicholas\n```\n动态原型模式可谓非常完美！仅在方法不存在时，才会将它添加到原型中。\n## 6、寄生构造函数模式\n写法与工厂模式一模一样，区别是在创建实例的时候，是通过`new`来创建，与构造函数的实例对象方法一致。这种模式可以在特殊情况下用来为对象创建构造函数。如下面例子：我们可以创建一个具有额外特殊方法的特殊数组。\n```javascript\nfunctio SpecialArray(){\n    //创建数组\n    var values = new Array();\n    // 添加值\n    values.push.apply(values, arguments);\n    //添加方法\n    values,toPipedString = funtion(){\n        return this.join(\"|\");\n    }\n    return values;\n}\nvar colors = new SpecialArray(\"red\", \"blue\", \"black\");\nalert(colors,toPipedString());    //\"red|blue|green\"\n```\n## 7、稳妥构造函数模式\n所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象。\n稳妥对象适用场景：一些安全环境或者在防止数据被其他应用篡改。如下面例子：\n```javacript\nfunction Person(){   \n    //创建要返回对象\n    var o = new Object();\n    //定义私有变量和函数\n    o.sayName = function(){\n        alert(name);    \n    }\n    return o;\n}\n\nvar person = Person(); //不使用new来实例化对象，跟工厂模式一样\nfriend.sayName();\n```\n\n\n","slug":"javascript/javascript-learning-object","published":1,"updated":"2016-03-05T17:29:59.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7kc000nrwtz8iosmob8"},{"title":"【JavaScript高程学习笔记】面向对象的程序设计之继承","date":"2016-03-05T17:27:43.000Z","_content":"本篇文章是学习《Javascript高级程序设计》中关于继承这一部分的学习笔记。\n<!-- more -->\n#继承\n许多OO语言都支持两种继承方式：接口继承和实现继承。而ECMAScript只支持**实现继承**，而且实现继承主要是依靠原型链来实现的。\n## 一、原型链\nECMAScript中继承的基本思想是利用原型让一个引用类型继承另外一个引用类型的属性和方法。\n让我们简单回顾一下原型、构造函数和实例之间的关系。\n每个构造函数都有一个原型对象`Prototype`，原型对象包含一个指向构造函数的指针，即`constructor`属性，这个属性指向的是`prototype`属性所在的函数（构造函数）。而构造函数的实例则包含一个指向原型对象的内部指针。\n那么如果让原型对象等于另一个类型的实例，则此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另外一个构造函数的指针。假如另外一个原型又是另外一个类型的实例，那么上述关系依然成立，如此层层推进，就构成原型链。如下面的例子：\n```javascript\n\tfunction Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n\tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n\n\tfunction Boy(){\n\t\tthis.sex = 'boy';\n\t}\n\tBoy.prototype = new Human();\t//将父类Human的实例赋给子类Boy的原型对象实现继承,子类 Boy就继承了Human以及Animal\n\tvar human = new Human();\n\tvar boy = new Boy();\n\tconsole.log(human)\n\tconsole.log(boy);\t// \n\tboy.run();    \t// I can run\n```\n**1、原型链搜索机制**\n从打印结果，如下图所示，可以看出，Boy的继承原型链，Human->Animal->Object（因为所有的对象都继承于Object）。所以Boy对象在执行run()方法的时候，能输出“I can run”的结果。而boy能找到run方法是基于`原型链搜索机制`。当boy调用run()方法时，首先会先在Boy的实例去寻找该方法或者属性。如果找不到该方法或属性，则会继续搜索实例的原型。如果再找不到，就继续往原型的原型寻找。在找不到的情况下，会一直搜索到原型链的末端才会停止，一般是Object对象。\n\n**2、确定原型和实例的关系**\n有两种方式可以确定原型和实例之间的关系。\n* instanceof操作符\n* isPrototypeOf()方法\n```javascript\n        console.log(boy instanceof Object); //true\n\tconsole.log(boy instanceof Animal); //true\n\tconsole.log(boy instanceof Human); //true\n\n\tconsole.log(Object.prototype.isPrototypeOf(boy)); //true\n\tconsole.log(Animal.prototype.isPrototypeOf(boy)); //true\n\tconsole.log(Human.prototype.isPrototypeOf(boy)); //true\n```\n**3、重写父类方法或者添加新方法**\n如果需要重写父类方法或者添加新方法，一定要放在**替换原型的语句之后**，而且在重写父类方法或者添加新方法的时候，**不能使用对象字面量创建**。因为如果使用对象字面量创建，就相当于重新创建了原型链，会导致原有的原型链失效。\n```javascript\n    function Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n\tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n\n\tHuman.prototype.eat = function(){\t//重写父类方法，语句要放在原型替换之后。\n\t\tconsole.log(\"I can eat override\");\n\t}\n\n\tHuman.prototype.speak = function(){  //添加新方法，且不能使用对象字面量添加方法\n\t\tconsole.log('Human can speak');\n\t}\n\tHuman.prototype = {\t //不能使用对象字面量添加\n\t\tspeak: function(){  \n\t\tconsole.log('Human can speak');\n\t}\n```\n**4、原型链存在的问题**\n跟之前创建对象的原型模式一样，正是由于原型共享被所有实例共享的特性，导致了在听过原型继承的时候，父类的属性是子类的原型，因此所有子类的实例对父类的属性操作时，都会影响到子类所有实例。如下面例子：\n```javascript\n    function Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.gender = [''];\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n    \tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n        var human1 = new Human();\n        var human1 = new Human();\n        human1.gender.push('male');\n        console.log(human2.gender);     //此时输出 male\n```\n这个例子中，human1对父类（即Human的原型）的gender属性添加了一个值“male”,由于原型的共享性，导致了Human的另外一个实例human2调用gender属性输出的值是刚刚human1添加过值的。\n原型链的第二个问题：在创建子类实例的时候，无法在不影响所有子类实例的情况下，向父类的构造函数传递参数。\n## 2、继承的方法\n### 1、借用构造函数\n实现思想：在子类内部调用超类构造函数，使用apply（）和call()\n```\nfunction SuperType(name){\n    this.color = ['red', 'blue', 'white'];\n    this.getName = function(){\n        console.log(name);\n    }\n}\nfunction SubType(){\n    //继承了SuperType\n    SuperType.call(this, 'Superman');\n}\n```\n使用借用构造函数继承可以保证了父类的属性和方法对每个子类而言都是独立的。同时还支持传递参数。\n但是该方法依然存在着问题，由于是通过在子类内部实例化父类构造函数的方式来实现继承，应该函数的复用就无从谈起。而且在父类原型中定义的方法，对于子类而言也是不可见的，结果导致所有类型都只能使用构造函数模式。因此很少单独使用借用构造函数模式。\n\n### 2、组合继承\n组合继承也称伪经典继承，是将借用构造函数和原型链的技术组合到一块。这种方式是最常用的继承模式。\n实现思路：使用原型链对**原型属性**和**原型方法**的继承，而通过借用构造函数来实现对**实例属性**的继承。如下面例子\n```javascript\nfunction SuperType(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n}\nfunction SubType(name, age){\n    SuperType.call(this, name);\n    this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType();\n\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n}\nvar sub1 = new SubType('superman1', '1');\nvar sub2 = new SubType('superman2', '2');\nsub1.colors.push('black');\nconsole.log(sub1.colors);    // ['red', 'blue', 'green', 'black']\nsub1.sayName();    //superman1\n\nsub2.colors.push('green');\nconsole.log(sub2.colors);    // ['red', 'blue', 'green', 'green']\nsub2.sayName();    //superman2\n```\n通过这种方式，即可以让子类的实例分别拥有自己的属性，又可以使用同样的方法。\n### 3、原型式继承\n实现思路：借助原型可以基于已有的对象创建新对象。如下面例子：\n```javascript\nfunction object(o){\n    function F(){\n        F.prototype = o;\n        return new F();\n    }\n}\nvar person = {\n    name: 'superman',\n    age: 22,\n    friends: ['1', '2', '3', '4']\n}\nvar anotherPerson = object(person);\n```\n### 4、寄生式继承\n### 5、寄生组合式继承\n\n\n","source":"_posts/javascript/javascript-inherit.md","raw":"---\ntitle: 【JavaScript高程学习笔记】面向对象的程序设计之继承\ndate: 2016-03-06 01:27:43\ntags:\n- JavaScript高级程序设计学习笔记\n- 面向对象\n- 继承\n---\n本篇文章是学习《Javascript高级程序设计》中关于继承这一部分的学习笔记。\n<!-- more -->\n#继承\n许多OO语言都支持两种继承方式：接口继承和实现继承。而ECMAScript只支持**实现继承**，而且实现继承主要是依靠原型链来实现的。\n## 一、原型链\nECMAScript中继承的基本思想是利用原型让一个引用类型继承另外一个引用类型的属性和方法。\n让我们简单回顾一下原型、构造函数和实例之间的关系。\n每个构造函数都有一个原型对象`Prototype`，原型对象包含一个指向构造函数的指针，即`constructor`属性，这个属性指向的是`prototype`属性所在的函数（构造函数）。而构造函数的实例则包含一个指向原型对象的内部指针。\n那么如果让原型对象等于另一个类型的实例，则此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另外一个构造函数的指针。假如另外一个原型又是另外一个类型的实例，那么上述关系依然成立，如此层层推进，就构成原型链。如下面的例子：\n```javascript\n\tfunction Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n\tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n\n\tfunction Boy(){\n\t\tthis.sex = 'boy';\n\t}\n\tBoy.prototype = new Human();\t//将父类Human的实例赋给子类Boy的原型对象实现继承,子类 Boy就继承了Human以及Animal\n\tvar human = new Human();\n\tvar boy = new Boy();\n\tconsole.log(human)\n\tconsole.log(boy);\t// \n\tboy.run();    \t// I can run\n```\n**1、原型链搜索机制**\n从打印结果，如下图所示，可以看出，Boy的继承原型链，Human->Animal->Object（因为所有的对象都继承于Object）。所以Boy对象在执行run()方法的时候，能输出“I can run”的结果。而boy能找到run方法是基于`原型链搜索机制`。当boy调用run()方法时，首先会先在Boy的实例去寻找该方法或者属性。如果找不到该方法或属性，则会继续搜索实例的原型。如果再找不到，就继续往原型的原型寻找。在找不到的情况下，会一直搜索到原型链的末端才会停止，一般是Object对象。\n\n**2、确定原型和实例的关系**\n有两种方式可以确定原型和实例之间的关系。\n* instanceof操作符\n* isPrototypeOf()方法\n```javascript\n        console.log(boy instanceof Object); //true\n\tconsole.log(boy instanceof Animal); //true\n\tconsole.log(boy instanceof Human); //true\n\n\tconsole.log(Object.prototype.isPrototypeOf(boy)); //true\n\tconsole.log(Animal.prototype.isPrototypeOf(boy)); //true\n\tconsole.log(Human.prototype.isPrototypeOf(boy)); //true\n```\n**3、重写父类方法或者添加新方法**\n如果需要重写父类方法或者添加新方法，一定要放在**替换原型的语句之后**，而且在重写父类方法或者添加新方法的时候，**不能使用对象字面量创建**。因为如果使用对象字面量创建，就相当于重新创建了原型链，会导致原有的原型链失效。\n```javascript\n    function Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n\tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n\n\tHuman.prototype.eat = function(){\t//重写父类方法，语句要放在原型替换之后。\n\t\tconsole.log(\"I can eat override\");\n\t}\n\n\tHuman.prototype.speak = function(){  //添加新方法，且不能使用对象字面量添加方法\n\t\tconsole.log('Human can speak');\n\t}\n\tHuman.prototype = {\t //不能使用对象字面量添加\n\t\tspeak: function(){  \n\t\tconsole.log('Human can speak');\n\t}\n```\n**4、原型链存在的问题**\n跟之前创建对象的原型模式一样，正是由于原型共享被所有实例共享的特性，导致了在听过原型继承的时候，父类的属性是子类的原型，因此所有子类的实例对父类的属性操作时，都会影响到子类所有实例。如下面例子：\n```javascript\n    function Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.gender = [''];\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n    \tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n        var human1 = new Human();\n        var human1 = new Human();\n        human1.gender.push('male');\n        console.log(human2.gender);     //此时输出 male\n```\n这个例子中，human1对父类（即Human的原型）的gender属性添加了一个值“male”,由于原型的共享性，导致了Human的另外一个实例human2调用gender属性输出的值是刚刚human1添加过值的。\n原型链的第二个问题：在创建子类实例的时候，无法在不影响所有子类实例的情况下，向父类的构造函数传递参数。\n## 2、继承的方法\n### 1、借用构造函数\n实现思想：在子类内部调用超类构造函数，使用apply（）和call()\n```\nfunction SuperType(name){\n    this.color = ['red', 'blue', 'white'];\n    this.getName = function(){\n        console.log(name);\n    }\n}\nfunction SubType(){\n    //继承了SuperType\n    SuperType.call(this, 'Superman');\n}\n```\n使用借用构造函数继承可以保证了父类的属性和方法对每个子类而言都是独立的。同时还支持传递参数。\n但是该方法依然存在着问题，由于是通过在子类内部实例化父类构造函数的方式来实现继承，应该函数的复用就无从谈起。而且在父类原型中定义的方法，对于子类而言也是不可见的，结果导致所有类型都只能使用构造函数模式。因此很少单独使用借用构造函数模式。\n\n### 2、组合继承\n组合继承也称伪经典继承，是将借用构造函数和原型链的技术组合到一块。这种方式是最常用的继承模式。\n实现思路：使用原型链对**原型属性**和**原型方法**的继承，而通过借用构造函数来实现对**实例属性**的继承。如下面例子\n```javascript\nfunction SuperType(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n}\nfunction SubType(name, age){\n    SuperType.call(this, name);\n    this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType();\n\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n}\nvar sub1 = new SubType('superman1', '1');\nvar sub2 = new SubType('superman2', '2');\nsub1.colors.push('black');\nconsole.log(sub1.colors);    // ['red', 'blue', 'green', 'black']\nsub1.sayName();    //superman1\n\nsub2.colors.push('green');\nconsole.log(sub2.colors);    // ['red', 'blue', 'green', 'green']\nsub2.sayName();    //superman2\n```\n通过这种方式，即可以让子类的实例分别拥有自己的属性，又可以使用同样的方法。\n### 3、原型式继承\n实现思路：借助原型可以基于已有的对象创建新对象。如下面例子：\n```javascript\nfunction object(o){\n    function F(){\n        F.prototype = o;\n        return new F();\n    }\n}\nvar person = {\n    name: 'superman',\n    age: 22,\n    friends: ['1', '2', '3', '4']\n}\nvar anotherPerson = object(person);\n```\n### 4、寄生式继承\n### 5、寄生组合式继承\n\n\n","slug":"javascript/javascript-inherit","published":1,"updated":"2016-03-05T17:31:04.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7kh000urwtzbzubwqzx"},{"title":"深入理解变量声明提升和函数声明提升","date":"2016-03-05T07:08:35.000Z","_content":"最近做题目遇到了关于变量声明提升和函数声明提升的知识点，觉得掌握得不是非常好，因此特地又翻开了犀牛书，重新深入学习，并整理成文章。\n<!-- more -->\n# 变量声明提升\n## 1、变量定义\n可以使用var定义变量，变量如果没有赋值，那变量的初始值为`undefined`。\n## 2、变量作用域\n变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数内有效。\n在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。\n**所有不使用var定义的变量都视为全局变量**\n## 3、函数作用域和声明提前\nJavaScript的函数作用是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说**变量在声明之前已经可用**，所有这特性称为`声明提前（hoisting）`，即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。如下面例子：\n_注释：`声明提前`是在JavaScript引擎的预编译时进行，是在代码开始运行之前。_\n```javascript\nvar scope = 'global';\nfunction f(){\n    console.log(scope);\n    var scope = 'local';\n    console.log('scope');\n}\n```\n由于函数内声明提升，所以上面的代码实际上是这样的\n```javascript\nvar scope = 'global';\nfunction f(){\n    var scope;    //变量声明提升到函数顶部\n    console.log(scope);\n    scope = 'local';    //变量初始化依然保留在原来的位置\n    console.log(scope);\n}\n```\n经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是`undefined`.第二个console.log(scope)语句之前，scope已经完成赋值为'local'，所以输出的结果是`local`。\n\n# 函数声明提升\n## 1、函数的两种创建方式\n* 函数声明\n* 函数表达式\n\n**函数声明语法**\n```javascript\nf('superman');\nfunction f(name){\n    console.log(name);\n}\n```\n运行上面的程序，控制台能打印出`supemran`。\n**函数表达式语法**\n```javascript\nf('superman');\nvar f= function(name){\n    console.log(name);\n}\n```\n\n运行上面的代码，会报错`Uncaught ReferenceError: f is not defined(…)`,错误信息显示说f没有被定义。\n 为什么同样的代码，函数声明和函数表达式存在着差异呢？\n这是因为，函数声明有一个非常重要的特征：`函数声明提升`，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（是不是跟变量提升非常类似）。正是因为这个特征，所以可以把函数声明放在调用它的语句后面。如下面例子，最终的输出结果应该是什么？：\n```javascript    \nvar getName = function(){\n    console.log(2);\n}\nfunction getName (){\n    console.log(1);\n}\ngetName();\n```\n可能会有人觉得最后输出的结果是`1`。让我们来分析一下，这个例子涉及到了`变量声明提升`和`函数声明提升`。正如前面说到的函数声明提升，函数声明`function getName(){}`的声明会被提前到顶部。而函数表达式`var getName = function(){}`则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。需要注意的是，**函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。**因此上面的函数可以转换成下面的样子:\n```javascript\nfunction getName(){    //函数声明提升到顶部\n    console.log(1);\n}\nvar getName;    //变量声明提升\n\ngetName = function(){    //变量赋值依然保留在原来的位置\n    console.log(2);\n}\ngetName();    // 最终输出：2\n```\n所以最终的输出结果是：`2`。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出`2`。\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript/javascript-hoisting.md","raw":"---\ntitle: 深入理解变量声明提升和函数声明提升\ndate: 2016-03-05 15:08:35\ntags:\n- JavaScript学习笔记\n---\n最近做题目遇到了关于变量声明提升和函数声明提升的知识点，觉得掌握得不是非常好，因此特地又翻开了犀牛书，重新深入学习，并整理成文章。\n<!-- more -->\n# 变量声明提升\n## 1、变量定义\n可以使用var定义变量，变量如果没有赋值，那变量的初始值为`undefined`。\n## 2、变量作用域\n变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数内有效。\n在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。\n**所有不使用var定义的变量都视为全局变量**\n## 3、函数作用域和声明提前\nJavaScript的函数作用是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说**变量在声明之前已经可用**，所有这特性称为`声明提前（hoisting）`，即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。如下面例子：\n_注释：`声明提前`是在JavaScript引擎的预编译时进行，是在代码开始运行之前。_\n```javascript\nvar scope = 'global';\nfunction f(){\n    console.log(scope);\n    var scope = 'local';\n    console.log('scope');\n}\n```\n由于函数内声明提升，所以上面的代码实际上是这样的\n```javascript\nvar scope = 'global';\nfunction f(){\n    var scope;    //变量声明提升到函数顶部\n    console.log(scope);\n    scope = 'local';    //变量初始化依然保留在原来的位置\n    console.log(scope);\n}\n```\n经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是`undefined`.第二个console.log(scope)语句之前，scope已经完成赋值为'local'，所以输出的结果是`local`。\n\n# 函数声明提升\n## 1、函数的两种创建方式\n* 函数声明\n* 函数表达式\n\n**函数声明语法**\n```javascript\nf('superman');\nfunction f(name){\n    console.log(name);\n}\n```\n运行上面的程序，控制台能打印出`supemran`。\n**函数表达式语法**\n```javascript\nf('superman');\nvar f= function(name){\n    console.log(name);\n}\n```\n\n运行上面的代码，会报错`Uncaught ReferenceError: f is not defined(…)`,错误信息显示说f没有被定义。\n 为什么同样的代码，函数声明和函数表达式存在着差异呢？\n这是因为，函数声明有一个非常重要的特征：`函数声明提升`，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（是不是跟变量提升非常类似）。正是因为这个特征，所以可以把函数声明放在调用它的语句后面。如下面例子，最终的输出结果应该是什么？：\n```javascript    \nvar getName = function(){\n    console.log(2);\n}\nfunction getName (){\n    console.log(1);\n}\ngetName();\n```\n可能会有人觉得最后输出的结果是`1`。让我们来分析一下，这个例子涉及到了`变量声明提升`和`函数声明提升`。正如前面说到的函数声明提升，函数声明`function getName(){}`的声明会被提前到顶部。而函数表达式`var getName = function(){}`则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。需要注意的是，**函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。**因此上面的函数可以转换成下面的样子:\n```javascript\nfunction getName(){    //函数声明提升到顶部\n    console.log(1);\n}\nvar getName;    //变量声明提升\n\ngetName = function(){    //变量赋值依然保留在原来的位置\n    console.log(2);\n}\ngetName();    // 最终输出：2\n```\n所以最终的输出结果是：`2`。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出`2`。\n\n\n\n\n\n\n\n\n\n","slug":"javascript/javascript-hoisting","published":1,"updated":"2016-03-12T15:50:41.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7kn000zrwtzej7r01u0"},{"title":"【读书笔记】JavaScript闭包的理解","date":"2016-03-19T16:41:34.000Z","_content":"以前一直都不能完全理解闭包的概念，于是就专门学习了下闭包，整理成这篇文章。\n<!-- more -->\n在学习JavaScript中，有一个概念一直困扰着我，它就是**闭包**。今天就彻底学习学习什么是闭包。\n参考资料：\n阮一峰老师的闭包教程: http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n# 为什么会有闭包？\n由于JavaScript的变量作用域的特点，函数内部作用域可以访问外部作用域的变量，而外部作用域却无权访问内部作用域的局部变量。那如果我们想要在函数作用域外访问到函数内部的变量时，该怎么办。\n因此解决的办法就是在函数的内部再创建一个函数，这样就可以在内部函数中访问函数的内部变量，这时候再将内部函数作为返回值的话，那么就可以在函数外去访问到函数的内部变量。这就是**函数的闭包**。\n# 什么是闭包？\n先来看看对于函数的闭包，经典的书籍都是怎么定义的：\n**闭包是指有权访问另外一个函数作用域中的变量的函数。**-----《JavaScript高级程序设计（第3版）》\n**函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中被称为闭包。**-----《JavaScript权威指南（第6版）》\n**当函数可以记住并访问所有的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。**-----《你不知道的JavaScript（上）》\n发现了没有，上面三个关于**闭包**虽然描述的方式不同，但是对闭包定义的本质是相同的：**闭包就是能够读取其他函数内部变量的函数**。\n阮老师将定义更加简洁得定义为：**定义在一个函数内部的函数**（由于在JavaScript中，只有函数内部的子函数才可以读取函数内部的变量）。\n先来看一个简单的例子，清晰地展示了闭包：\n```javascript\nfunction foo(){\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    return bar;\n}\nvar baz = foo();\nbaz.bar();    //2 ——这就是闭包的效果，在foo()函数作用域却能访问到函数内部变量a的值\n```\n# 闭包有什么用途\n1. 匿名自执行函数\n2. 缓存\n3. 实现封装\n4. 实现面向对象中的对象\n\n_关于闭包的用途，下一篇文章将详细介绍。_\n# 闭包注意事项\n## 1、闭包性能问题 \n由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能导致内存占用过多。\n虽然V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存。但也应避免大量使用闭包。\n## 2、闭包与变量\nJavaScript作用域导致了一个副作用，即闭包只能取得包含函数中的任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。如下面的例子：\n```javascript\nfunction createFunctions(){\n\tvar result = new Array();\n\tfor(var i = 0; i< 10; i ++){\n\t\tresult[i] = function(){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn result;\n}\nconsole.log(createFunctions()[1]());    //10，其实数组的每个值都是输出10\n```\n这个函数返回了一个数组，从表面上看，每个函数都应该返回自己的索引值，但实际上却是每个函数都返回了10。这是为什么呢？\n因为每个函数的作用域链中都包含着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用这保存变量i的统一变量对象，所以每个函数内部i的值都是10。\n我们可以通过创建另外一个匿名函数来解决这个问题，如下所示\n```javascript\nfunction createFunctions() {\n    var result = new Array();\n    for (var i = 0; i < 10; i++) {\n        result[i] = function(num) {\n            return function(){\n            \treturn num;\n            };\n        }(i);\n    }\n    return result;\n}\n```\n改进之后，我们并没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该函数的结果赋值给数组。而这个匿名函数有一个参数，也就是最终函数要返回的值。在调用每个匿名函数时，我们传入变量i。在这个匿名函数内部，又创建并返回了一个访问num的闭包，这样一来，result数组中的每个函数都有自己的num变量的一个副本，因此就可以各自不同的值。\n## 3、闭包与this对象\n我们都知道`this`对象是基于函数运行时的执行环境绑定的，在全局函数中，`this`等于`window`。但是在匿名函数中，其执行环境具有全局局限性，因此'this'通常指的是'window'。来比较下下面两个例子：\n```javascript\nvar name = 'The window';\nvar object = {\n    name: 'My Object',\n    getNameFunc: function() {\n        return function() {\n            return this.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()()); //The window\n```\n```javascript\nvar name = 'The window';\nvar object = {\n    name: 'My Object',\n    getNameFunc: function() {\n        var self = this;\n        return function() {\n            return self.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()()); //My Object\n```\n\n# 闭包小测\n\n```javascript\n    function fun(n, o) {\n        console.log(o);\n        return {\n            fun: function(m) {\n                return fun(m, n);\n            }\n        };\n    }\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n问着三行，a、b、c分别输出什么\n```\n答案请[猛戳](http://www.cnblogs.com/xxcanghai/p/4991870.html)\n参考资料：大部分人都会做错的经典JS闭包面试题 http://www.cnblogs.com/xxcanghai/p/4991870.html\n\n\n\n","source":"_posts/javascript/javascript-closure.md","raw":"---\ntitle: 【读书笔记】JavaScript闭包的理解\ndate: 2016-03-20 00:41:34\ntags:\n- JavaScript学习笔记\n---\n以前一直都不能完全理解闭包的概念，于是就专门学习了下闭包，整理成这篇文章。\n<!-- more -->\n在学习JavaScript中，有一个概念一直困扰着我，它就是**闭包**。今天就彻底学习学习什么是闭包。\n参考资料：\n阮一峰老师的闭包教程: http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n# 为什么会有闭包？\n由于JavaScript的变量作用域的特点，函数内部作用域可以访问外部作用域的变量，而外部作用域却无权访问内部作用域的局部变量。那如果我们想要在函数作用域外访问到函数内部的变量时，该怎么办。\n因此解决的办法就是在函数的内部再创建一个函数，这样就可以在内部函数中访问函数的内部变量，这时候再将内部函数作为返回值的话，那么就可以在函数外去访问到函数的内部变量。这就是**函数的闭包**。\n# 什么是闭包？\n先来看看对于函数的闭包，经典的书籍都是怎么定义的：\n**闭包是指有权访问另外一个函数作用域中的变量的函数。**-----《JavaScript高级程序设计（第3版）》\n**函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中被称为闭包。**-----《JavaScript权威指南（第6版）》\n**当函数可以记住并访问所有的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。**-----《你不知道的JavaScript（上）》\n发现了没有，上面三个关于**闭包**虽然描述的方式不同，但是对闭包定义的本质是相同的：**闭包就是能够读取其他函数内部变量的函数**。\n阮老师将定义更加简洁得定义为：**定义在一个函数内部的函数**（由于在JavaScript中，只有函数内部的子函数才可以读取函数内部的变量）。\n先来看一个简单的例子，清晰地展示了闭包：\n```javascript\nfunction foo(){\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    return bar;\n}\nvar baz = foo();\nbaz.bar();    //2 ——这就是闭包的效果，在foo()函数作用域却能访问到函数内部变量a的值\n```\n# 闭包有什么用途\n1. 匿名自执行函数\n2. 缓存\n3. 实现封装\n4. 实现面向对象中的对象\n\n_关于闭包的用途，下一篇文章将详细介绍。_\n# 闭包注意事项\n## 1、闭包性能问题 \n由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能导致内存占用过多。\n虽然V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存。但也应避免大量使用闭包。\n## 2、闭包与变量\nJavaScript作用域导致了一个副作用，即闭包只能取得包含函数中的任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。如下面的例子：\n```javascript\nfunction createFunctions(){\n\tvar result = new Array();\n\tfor(var i = 0; i< 10; i ++){\n\t\tresult[i] = function(){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn result;\n}\nconsole.log(createFunctions()[1]());    //10，其实数组的每个值都是输出10\n```\n这个函数返回了一个数组，从表面上看，每个函数都应该返回自己的索引值，但实际上却是每个函数都返回了10。这是为什么呢？\n因为每个函数的作用域链中都包含着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用这保存变量i的统一变量对象，所以每个函数内部i的值都是10。\n我们可以通过创建另外一个匿名函数来解决这个问题，如下所示\n```javascript\nfunction createFunctions() {\n    var result = new Array();\n    for (var i = 0; i < 10; i++) {\n        result[i] = function(num) {\n            return function(){\n            \treturn num;\n            };\n        }(i);\n    }\n    return result;\n}\n```\n改进之后，我们并没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该函数的结果赋值给数组。而这个匿名函数有一个参数，也就是最终函数要返回的值。在调用每个匿名函数时，我们传入变量i。在这个匿名函数内部，又创建并返回了一个访问num的闭包，这样一来，result数组中的每个函数都有自己的num变量的一个副本，因此就可以各自不同的值。\n## 3、闭包与this对象\n我们都知道`this`对象是基于函数运行时的执行环境绑定的，在全局函数中，`this`等于`window`。但是在匿名函数中，其执行环境具有全局局限性，因此'this'通常指的是'window'。来比较下下面两个例子：\n```javascript\nvar name = 'The window';\nvar object = {\n    name: 'My Object',\n    getNameFunc: function() {\n        return function() {\n            return this.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()()); //The window\n```\n```javascript\nvar name = 'The window';\nvar object = {\n    name: 'My Object',\n    getNameFunc: function() {\n        var self = this;\n        return function() {\n            return self.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()()); //My Object\n```\n\n# 闭包小测\n\n```javascript\n    function fun(n, o) {\n        console.log(o);\n        return {\n            fun: function(m) {\n                return fun(m, n);\n            }\n        };\n    }\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n问着三行，a、b、c分别输出什么\n```\n答案请[猛戳](http://www.cnblogs.com/xxcanghai/p/4991870.html)\n参考资料：大部分人都会做错的经典JS闭包面试题 http://www.cnblogs.com/xxcanghai/p/4991870.html\n\n\n\n","slug":"javascript/javascript-closure","published":1,"updated":"2016-03-19T16:43:27.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7kr0011rwtzm32uakbw"},{"title":"深入理解JavaScript中的call和apply","date":"2016-04-20T15:20:35.000Z","_content":"本文利用主动提问的学习方法来学习JavaScript中的call和apply\n<!-- more -->\n#  学习之前的主动提问\n昨天get的新技能，通过主动提问来学习。\n![](http://7xr6yj.com1.z0.glb.clouddn.com/aritcle-review-insight-3.png)\n## call和apply是什么\n`call`和`apply`都是属于Function.prototype的一个方法。它是在JavaScript引擎内实现的，因为是原型上的方法，因此对于每个Function对象的实例，都共享这两个方法。\n## call和apply有什么作用\n根据MDN上对于JavaScript.call()的定义\n> call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法\n\n`apply`和`call`作用一样。也就是说它们具有动态改变函数运行时的上下文，可以将一个函数的对象上下文从初始的上下文改变为由指定的this值所指定的对象。\n## call和apply的用法\n`apply`和`call`的作用与用法几乎一样，它们的区别就在于方法**传递的参数不同**。`call()`传递的是参数是任意的，而`apply()`传递的参数必须为数组\n### call()语法\n> fun.call(thisArg[, arg1[, arg2[, ...]]])\n\n#### thisArg\n在fun函数运行时指定的this值，需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于**非严格模式下**，则指定为null和undefined的this值会指定指向全局对象（在浏览器中则是window对象），同时值为原始值（Number，string，boolean）的this值会指向该原始值的自动包装对象。\n\n#### arg1, arg2, arg3, ...\n传递给fun函数的指定的参数列表\n### apply()语法\n> fun.call(thisArg[ arg1, arg2,...])\n\n## call和apply的用法\ntalk is cheap，show me the code。让我们先抛开上面复杂的解释，通过代码来解释。写一个hello world:\n```javascript\n;(function () {\n\tvar  printA = {\n\t\tprint: function(p1, p2){\n\t\tconsole.log(p1 +\" \"+ p2);\n\t\t}\n\t}\n\t\n\tvar printB = {\n\t\tprint: function(p1,p2){\n\t\t\tprintA.print.call(this, p1, p2);\t\n\t\t}\t\n\t}\n\tprintB.print('hello', 'worldB');\t//hello worldB\n})();\n```\n最后的输出结果是hello worldB。很显然，在printB.print方法中，并没有输出结果的console.log()语句，但是在printB.print函数内部，通过printA.print.call()的方式，借用了printA.print方法。\ncall就是借用别人的方法、对象来调用，就像调用自己的方法一样。\n## call和apply的应用场景\n这里引用Mozilla的例子\n### 使用call方法调用父构造函数\n```javascript\nfunction Product(name, price) {\n\t  this.name = name;\n\t  this.price = price;\n\n\t  if (price < 0) {\n\t    throw RangeError('Cannot create product ' +\n\t                      this.name + ' with a negative price');\n\t  }\n\n\t  return this;\n\t}\n\n\tfunction Food(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'food';\n\t}\n\n\tFood.prototype = Object.create(Product.prototype);\n\tFood.prototype.constructor = Food; // Reset the constructor from Product to Food\n\n\tfunction Toy(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'toy';\n\t}\n\n\tToy.prototype = Object.create(Product.prototype);\n\tToy.prototype.constructor = Toy; // Reset the constructor from Product to Toy\n\n\tvar cheese = new Food('feta', 5);\n\tvar fun = new Toy('robot', 40);\n```\n### 使用call方法调用匿名函数\n在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为this值传入那个匿名函数（普通参数就可以），目的是为了演示call的用法。\n```javascript\nvar animals = [\n  {species: 'Lion', name: 'King'},\n  {species: 'Whale', name: 'Fail'}\n];\n \nfor (var i = 0; i < animals.length; i++) {\n  (function (i) {\n    this.print = function () {\n      console.log('#' + i  + ' ' + this.species + ': ' + this.name);\n    }\n    this.print();\n  }).call(animals[i], i);\n}\n```\n\n### 使用call方法调用匿名函数并且指定上下文的'this'\n在下面的例子中，当调用 greet 方法的时候，该方法的 this 值会绑定到 i 对象。\n\n```javascript\nfunction greet() {\n  var reply = [this.person, 'Is An Awesome', this.role].join(' ');\n  console.log(reply);\n}\n \nvar i = {\n  person: 'Douglas Crockford', role: 'Javascript Developer'\n};\n \ngreet.call(i); // Douglas Crockford Is An Awesome Javascript Developer\n```\n\n## 参考资料\n>关于javascript中apply()和call()方法的区别：http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html\n>Function.prototype.call():：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call","source":"_posts/javascript/javascirpt-call-method.md","raw":"---\ntitle: 深入理解JavaScript中的call和apply\ndate: 2016-04-20 23:20:35\ntags:\n- JavaScript\n---\n本文利用主动提问的学习方法来学习JavaScript中的call和apply\n<!-- more -->\n#  学习之前的主动提问\n昨天get的新技能，通过主动提问来学习。\n![](http://7xr6yj.com1.z0.glb.clouddn.com/aritcle-review-insight-3.png)\n## call和apply是什么\n`call`和`apply`都是属于Function.prototype的一个方法。它是在JavaScript引擎内实现的，因为是原型上的方法，因此对于每个Function对象的实例，都共享这两个方法。\n## call和apply有什么作用\n根据MDN上对于JavaScript.call()的定义\n> call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法\n\n`apply`和`call`作用一样。也就是说它们具有动态改变函数运行时的上下文，可以将一个函数的对象上下文从初始的上下文改变为由指定的this值所指定的对象。\n## call和apply的用法\n`apply`和`call`的作用与用法几乎一样，它们的区别就在于方法**传递的参数不同**。`call()`传递的是参数是任意的，而`apply()`传递的参数必须为数组\n### call()语法\n> fun.call(thisArg[, arg1[, arg2[, ...]]])\n\n#### thisArg\n在fun函数运行时指定的this值，需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于**非严格模式下**，则指定为null和undefined的this值会指定指向全局对象（在浏览器中则是window对象），同时值为原始值（Number，string，boolean）的this值会指向该原始值的自动包装对象。\n\n#### arg1, arg2, arg3, ...\n传递给fun函数的指定的参数列表\n### apply()语法\n> fun.call(thisArg[ arg1, arg2,...])\n\n## call和apply的用法\ntalk is cheap，show me the code。让我们先抛开上面复杂的解释，通过代码来解释。写一个hello world:\n```javascript\n;(function () {\n\tvar  printA = {\n\t\tprint: function(p1, p2){\n\t\tconsole.log(p1 +\" \"+ p2);\n\t\t}\n\t}\n\t\n\tvar printB = {\n\t\tprint: function(p1,p2){\n\t\t\tprintA.print.call(this, p1, p2);\t\n\t\t}\t\n\t}\n\tprintB.print('hello', 'worldB');\t//hello worldB\n})();\n```\n最后的输出结果是hello worldB。很显然，在printB.print方法中，并没有输出结果的console.log()语句，但是在printB.print函数内部，通过printA.print.call()的方式，借用了printA.print方法。\ncall就是借用别人的方法、对象来调用，就像调用自己的方法一样。\n## call和apply的应用场景\n这里引用Mozilla的例子\n### 使用call方法调用父构造函数\n```javascript\nfunction Product(name, price) {\n\t  this.name = name;\n\t  this.price = price;\n\n\t  if (price < 0) {\n\t    throw RangeError('Cannot create product ' +\n\t                      this.name + ' with a negative price');\n\t  }\n\n\t  return this;\n\t}\n\n\tfunction Food(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'food';\n\t}\n\n\tFood.prototype = Object.create(Product.prototype);\n\tFood.prototype.constructor = Food; // Reset the constructor from Product to Food\n\n\tfunction Toy(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'toy';\n\t}\n\n\tToy.prototype = Object.create(Product.prototype);\n\tToy.prototype.constructor = Toy; // Reset the constructor from Product to Toy\n\n\tvar cheese = new Food('feta', 5);\n\tvar fun = new Toy('robot', 40);\n```\n### 使用call方法调用匿名函数\n在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为this值传入那个匿名函数（普通参数就可以），目的是为了演示call的用法。\n```javascript\nvar animals = [\n  {species: 'Lion', name: 'King'},\n  {species: 'Whale', name: 'Fail'}\n];\n \nfor (var i = 0; i < animals.length; i++) {\n  (function (i) {\n    this.print = function () {\n      console.log('#' + i  + ' ' + this.species + ': ' + this.name);\n    }\n    this.print();\n  }).call(animals[i], i);\n}\n```\n\n### 使用call方法调用匿名函数并且指定上下文的'this'\n在下面的例子中，当调用 greet 方法的时候，该方法的 this 值会绑定到 i 对象。\n\n```javascript\nfunction greet() {\n  var reply = [this.person, 'Is An Awesome', this.role].join(' ');\n  console.log(reply);\n}\n \nvar i = {\n  person: 'Douglas Crockford', role: 'Javascript Developer'\n};\n \ngreet.call(i); // Douglas Crockford Is An Awesome Javascript Developer\n```\n\n## 参考资料\n>关于javascript中apply()和call()方法的区别：http://www.cnblogs.com/fighting_cp/archive/2010/09/20/1831844.html\n>Function.prototype.call():：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call","slug":"javascript/javascirpt-call-method","published":1,"updated":"2016-04-30T15:14:24.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7kv0013rwtzhnph571h"},{"title":"【面试总结】2016-4-3-宅米面试总结","date":"2016-04-04T08:48:13.000Z","_content":"经过几场面试后发现，面试官对于你如何学习新框架的过程都比较有兴趣，因为这可以考察出一个人的学习能力。以下是宅米面试过程的一些记录。\n<!-- more -->\n## 1.说说你是如何学习AngularJS\n主要是考查学习能力，通过你对一门新框架的学习方式来判断你的学习能力。\n我的回答：先是通过基本基本的书籍（如《AngularJS权威教程》）去入门，然后上手做项目。在做项目的过程中，遇到问题就查看官网api文档。再根据具体的知识，去翻阅不同的书籍进行补充（如《AngularJS Essentials》、《AngularJS Up & Running》）\n在入门之后，再阅读《AngularJS深度剖析与最佳实践》深入理解AngularJS，同时通过各种论坛收集并了解有关AngularJS的一些类库并使用（如按需加载库：ocLazyLoad）\n## 2.在AngularJS开发中遇到哪些坑？如何解决？\n关于AngularJS开发中遇到的坑已经整理成文章，详见[关于AngularJS的一些坑](http://superman66.github.io/2016/04/04/angular-collect/)\n\n## 3.脏检查机制，哪些事件会引起脏检查？点击一个函数是否会引起脏检查？\n我的回答：大概描述了“脏检查”机制的原理，并回答了input值变化会引起脏检查。但是对于ng-click是否会引起dirth check 却不知道。\n### 1、脏检查机制原理\n“脏检查”是AngularJS中最核心的机制之一，它是实现双向绑定、MVVM模式的重要基础。用一句话来概括“脏检查机制”：\nAngularJS将双向绑定转换为一堆watch表达式，然后递归检查这些watch表达式的结果是否变了，如果变了，则执行相应的watch函数。等到Model的值不再变化，也就不会再有watcher函数被触发，一个完整的digest循环就结束了。这时，浏览器就会重新渲染DOM来体现model的改变。\n### 2、哪些事件会引起脏检查？\n* Model的值发生改变\n* `ngClick`、`ngSubmit`、`ngChange`等事件指令，`$http`、`$resource`这类外部Ajax数据获取的回调函数以及`$timeout`、`$interval`\n\n## 4.知道angular2吗？（考察行业新技术的了解）\n\n大概了解过，但并未具体开始深入学习。\n\n## 5、微信开发中遇到哪些坑？是如何解决的？（踩坑过程是一次提升的过程，因此总结你踩坑的过程就显得非常重要）\n\n用户在js-sdk签名完成之前如果进行分享操作，将会导致分享设置的失效？\n解决办法：在未签名成功之前，隐藏右上角的菜单。\n# 总结\n记得公司一位大神说过，每个人都应该去经历面试。因为在一个环境待久了，自我意识很容易膨胀，陷入坐井观天的状态，无法意识到自身的不足。因此出去面试可以让你发现自己知识体系中薄弱的地方。在面试结束后，找出这些薄弱的地方，再一一去学习、巩固。这样的过程对于个人成长是很有帮助的。\n去宅米的面试应该是我面试的第4家公司了。经历过前面三次面试的磨练，这次面试自己还是存在比较大的信心。因为前一天晚上接到面试通知后，得知他们的项目前端也是采用AngularJS框架，便去他们的网站查看项目结构、代码等，做到心中有数（还发现了一个他们微信端网站存的问题，在面试中指出来，并提出了解决方案）。同时也做了一些相应的面试准备。因此在整个面试过程中进行得非常顺利。\n","source":"_posts/interview/zhaimi-interview-summary.md","raw":"---\ntitle: 【面试总结】2016-4-3-宅米面试总结\ndate: 2016-04-04 16:48:13\ntags: 面试总结\n---\n经过几场面试后发现，面试官对于你如何学习新框架的过程都比较有兴趣，因为这可以考察出一个人的学习能力。以下是宅米面试过程的一些记录。\n<!-- more -->\n## 1.说说你是如何学习AngularJS\n主要是考查学习能力，通过你对一门新框架的学习方式来判断你的学习能力。\n我的回答：先是通过基本基本的书籍（如《AngularJS权威教程》）去入门，然后上手做项目。在做项目的过程中，遇到问题就查看官网api文档。再根据具体的知识，去翻阅不同的书籍进行补充（如《AngularJS Essentials》、《AngularJS Up & Running》）\n在入门之后，再阅读《AngularJS深度剖析与最佳实践》深入理解AngularJS，同时通过各种论坛收集并了解有关AngularJS的一些类库并使用（如按需加载库：ocLazyLoad）\n## 2.在AngularJS开发中遇到哪些坑？如何解决？\n关于AngularJS开发中遇到的坑已经整理成文章，详见[关于AngularJS的一些坑](http://superman66.github.io/2016/04/04/angular-collect/)\n\n## 3.脏检查机制，哪些事件会引起脏检查？点击一个函数是否会引起脏检查？\n我的回答：大概描述了“脏检查”机制的原理，并回答了input值变化会引起脏检查。但是对于ng-click是否会引起dirth check 却不知道。\n### 1、脏检查机制原理\n“脏检查”是AngularJS中最核心的机制之一，它是实现双向绑定、MVVM模式的重要基础。用一句话来概括“脏检查机制”：\nAngularJS将双向绑定转换为一堆watch表达式，然后递归检查这些watch表达式的结果是否变了，如果变了，则执行相应的watch函数。等到Model的值不再变化，也就不会再有watcher函数被触发，一个完整的digest循环就结束了。这时，浏览器就会重新渲染DOM来体现model的改变。\n### 2、哪些事件会引起脏检查？\n* Model的值发生改变\n* `ngClick`、`ngSubmit`、`ngChange`等事件指令，`$http`、`$resource`这类外部Ajax数据获取的回调函数以及`$timeout`、`$interval`\n\n## 4.知道angular2吗？（考察行业新技术的了解）\n\n大概了解过，但并未具体开始深入学习。\n\n## 5、微信开发中遇到哪些坑？是如何解决的？（踩坑过程是一次提升的过程，因此总结你踩坑的过程就显得非常重要）\n\n用户在js-sdk签名完成之前如果进行分享操作，将会导致分享设置的失效？\n解决办法：在未签名成功之前，隐藏右上角的菜单。\n# 总结\n记得公司一位大神说过，每个人都应该去经历面试。因为在一个环境待久了，自我意识很容易膨胀，陷入坐井观天的状态，无法意识到自身的不足。因此出去面试可以让你发现自己知识体系中薄弱的地方。在面试结束后，找出这些薄弱的地方，再一一去学习、巩固。这样的过程对于个人成长是很有帮助的。\n去宅米的面试应该是我面试的第4家公司了。经历过前面三次面试的磨练，这次面试自己还是存在比较大的信心。因为前一天晚上接到面试通知后，得知他们的项目前端也是采用AngularJS框架，便去他们的网站查看项目结构、代码等，做到心中有数（还发现了一个他们微信端网站存的问题，在面试中指出来，并提出了解决方案）。同时也做了一些相应的面试准备。因此在整个面试过程中进行得非常顺利。\n","slug":"interview/zhaimi-interview-summary","published":1,"updated":"2016-04-04T09:14:35.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7ky0015rwtzhajszill"},{"title":"Hexo博客搭建教程（四）：Hexo优化与个性化","date":"2016-02-23T14:24:11.000Z","_content":"前面的文章介绍了如何打造一个属于自己的博客。但是这个博客还只是拥有基本的功能。对于一个站点而言，我们还需要很多功能来完善它，比如需要网站访问统计数据，网站评论功能等。这篇文章将从以下几个方面介绍如何自定义你的博客。\n* 添加统计代码\n* 添加多说评论功能\n* 如何添加本地图片\n<!-- more -->\n# 添加统计代码\n无数据，不运营。对于一个站点而言，网站的访问数据十分重要，数据分析是网站运营的一部分。虽然这只是一个博客，但我们也可以将其当做一个网站来运营。\n要想统计网站的访问数据，一般通过第三方数据分析网站，添加相应的统计代码来进行数据统计。由于google analytics会出现被墙的原因以及统计数据不够及时（一般需要第二天才能看到报表），因此我采用了[CNZZ数据专家](http://www.cnzz.com/)的数据统计功能。（至于为啥不用百度统计，由于百度全家桶实在是呵呵。。。）。\n## 获得CNZZ统计代码\n没有账号的自行去注册。注册完，填写你的博客站点信息之后，拿到CNZZ提供的统计代码。\n## 编辑 `themes/yilia/_config.yml`文件\n```yml\ncnzz_tongji: true  # 开启cnzz统计\ngoogle_analytics: ''\n```\n## 新建`cnzz_tongji.ejs`文件\n在`themes/yilia/layout/_partial/`文件夹下新建文件`cnzz_tongji.ejs`，文件内容如下:\n```ejs\n<% if(theme.cnzz_tongji) {%>\n\t<script type=\"text/javascript\"> \n\t//cnzz analytics code\n\t</script>\n<%}%>\n```\n## 将`cnzz_tongji.ejs`添加到`head.ejs`\n打开位于`themes/yilia/layout/_partial/`文件夹下的`head.ejs`，在`</head>`之前添加以下代码，将统计代码添加到页面中\n```ejs\n<%- partial/cnzz_tongji%>\n```\n添加后便可以去[CNZZ数据专家](http://www.cnzz.com/)查看博客的访问数据统计了。\n\n# 添加多说评论功能\n##登录多说，获取key，并将key添加到配置文件中\n如下图：箭头所指的就是你的多说的key(注意:后面的.duoshuo.com不需要)\n![](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_duoshuo_example.png)\n将你的域名填写到`themes/yilia/_config.yml`中\n```\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: your-key\n```\n\n# 添加本地图片\n对于source文件下的内容，hexo会在public文件夹下生成相应的内容。所以要想插入本地图片到博客中，只需要在`source`文件夹下新建`images`文件夹，把要插入的图片放入该文件夹即可。\n假设图片的路径为:`images/pic.png`,在文章中就可以这么来引用：\n`![text](/images/pic.png)`\n这样就可以在文章中插入本地图片了。\n\n","source":"_posts/hexo/hexo-guide-4.md","raw":"---\ntitle: Hexo博客搭建教程（四）：Hexo优化与个性化\ndate: 2016-02-23 22:24:11\ntags: Hexo\n---\n前面的文章介绍了如何打造一个属于自己的博客。但是这个博客还只是拥有基本的功能。对于一个站点而言，我们还需要很多功能来完善它，比如需要网站访问统计数据，网站评论功能等。这篇文章将从以下几个方面介绍如何自定义你的博客。\n* 添加统计代码\n* 添加多说评论功能\n* 如何添加本地图片\n<!-- more -->\n# 添加统计代码\n无数据，不运营。对于一个站点而言，网站的访问数据十分重要，数据分析是网站运营的一部分。虽然这只是一个博客，但我们也可以将其当做一个网站来运营。\n要想统计网站的访问数据，一般通过第三方数据分析网站，添加相应的统计代码来进行数据统计。由于google analytics会出现被墙的原因以及统计数据不够及时（一般需要第二天才能看到报表），因此我采用了[CNZZ数据专家](http://www.cnzz.com/)的数据统计功能。（至于为啥不用百度统计，由于百度全家桶实在是呵呵。。。）。\n## 获得CNZZ统计代码\n没有账号的自行去注册。注册完，填写你的博客站点信息之后，拿到CNZZ提供的统计代码。\n## 编辑 `themes/yilia/_config.yml`文件\n```yml\ncnzz_tongji: true  # 开启cnzz统计\ngoogle_analytics: ''\n```\n## 新建`cnzz_tongji.ejs`文件\n在`themes/yilia/layout/_partial/`文件夹下新建文件`cnzz_tongji.ejs`，文件内容如下:\n```ejs\n<% if(theme.cnzz_tongji) {%>\n\t<script type=\"text/javascript\"> \n\t//cnzz analytics code\n\t</script>\n<%}%>\n```\n## 将`cnzz_tongji.ejs`添加到`head.ejs`\n打开位于`themes/yilia/layout/_partial/`文件夹下的`head.ejs`，在`</head>`之前添加以下代码，将统计代码添加到页面中\n```ejs\n<%- partial/cnzz_tongji%>\n```\n添加后便可以去[CNZZ数据专家](http://www.cnzz.com/)查看博客的访问数据统计了。\n\n# 添加多说评论功能\n##登录多说，获取key，并将key添加到配置文件中\n如下图：箭头所指的就是你的多说的key(注意:后面的.duoshuo.com不需要)\n![](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_duoshuo_example.png)\n将你的域名填写到`themes/yilia/_config.yml`中\n```\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: your-key\n```\n\n# 添加本地图片\n对于source文件下的内容，hexo会在public文件夹下生成相应的内容。所以要想插入本地图片到博客中，只需要在`source`文件夹下新建`images`文件夹，把要插入的图片放入该文件夹即可。\n假设图片的路径为:`images/pic.png`,在文章中就可以这么来引用：\n`![text](/images/pic.png)`\n这样就可以在文章中插入本地图片了。\n\n","slug":"hexo/hexo-guide-4","published":1,"updated":"2016-05-04T14:56:20.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7l10018rwtzfi4itbn2"},{"title":"Hexo博客搭建教程（三）：Hexo博客代码版本控制","date":"2016-02-22T14:03:43.000Z","_content":"由于Hexo只会将生成后的public文件夹部署到github上，导致无法对博客进行代码版本控制。同时如果需要备份代码的话，只能通过其他手段来实现。\n本文介绍了如何利用github分支对代码进行版本控制，同时起到备份代码的作用。\n<!-- more -->\n# 解决思路\n实现Hexo博客代码版本控制以及备份的思路如下：\n通过新建一个`source`分支用于专门存放hexo代码。原先的`master`分支依然不变，作为hexo 部署的分支。\n每次在部署后，再把代码提交到`source`分支。\n# 实现步骤\n## 1、本地创建git 仓库\n```bash\ngit init\n```\n## 2、添加远程库\n```bash\ngit remote add origin <git repository url>\n```\n## 3、创建source分支\n```bash\ngit checkout -b source\n```\n## 4、提交文件及分支，并push到远程仓库\n```bash\ngit add *\ngit commit -m 'message'\ngit push origin source \n```\n其中`source`为分支名称。\n\n这样就建立了代码版本控制分支。之后只要将博客在部署到github之后，将代码push到`source`分支上。代码如下：\n```bash\ngit add *\ngit commit -m \"udpate site\"\ngit push origin source\n```\n# 问题记录\n如果你使用了第三方主题，在进行代码提交的时候，是无法将第三方主题提交到你的github repository中，会出现 `untracked content`的提示。\n这是因为第三方主题本身也是一个git项目。你无法将别人的git项目直接通过add 和commit的方式提交到你自己的git repository。\n也就说，你无法提交处于 `untracked`状态的文件。\n解决办法：\n* 添加 `submodule`的方式，将主题作为submodule提交到你的git repository\n* 删除主题文件夹下的`.git`文件夹。如果这时候还不能提交，可以新建个文件夹，随便命名，将主题文件夹内的东西复制到新建的文件夹。再通过`git add`提交就可以了。","source":"_posts/hexo/hexo-guide-3.md","raw":"---\ntitle: Hexo博客搭建教程（三）：Hexo博客代码版本控制\ndate: 2016-02-22 22:03:43\ntags: Hexo\n---\n由于Hexo只会将生成后的public文件夹部署到github上，导致无法对博客进行代码版本控制。同时如果需要备份代码的话，只能通过其他手段来实现。\n本文介绍了如何利用github分支对代码进行版本控制，同时起到备份代码的作用。\n<!-- more -->\n# 解决思路\n实现Hexo博客代码版本控制以及备份的思路如下：\n通过新建一个`source`分支用于专门存放hexo代码。原先的`master`分支依然不变，作为hexo 部署的分支。\n每次在部署后，再把代码提交到`source`分支。\n# 实现步骤\n## 1、本地创建git 仓库\n```bash\ngit init\n```\n## 2、添加远程库\n```bash\ngit remote add origin <git repository url>\n```\n## 3、创建source分支\n```bash\ngit checkout -b source\n```\n## 4、提交文件及分支，并push到远程仓库\n```bash\ngit add *\ngit commit -m 'message'\ngit push origin source \n```\n其中`source`为分支名称。\n\n这样就建立了代码版本控制分支。之后只要将博客在部署到github之后，将代码push到`source`分支上。代码如下：\n```bash\ngit add *\ngit commit -m \"udpate site\"\ngit push origin source\n```\n# 问题记录\n如果你使用了第三方主题，在进行代码提交的时候，是无法将第三方主题提交到你的github repository中，会出现 `untracked content`的提示。\n这是因为第三方主题本身也是一个git项目。你无法将别人的git项目直接通过add 和commit的方式提交到你自己的git repository。\n也就说，你无法提交处于 `untracked`状态的文件。\n解决办法：\n* 添加 `submodule`的方式，将主题作为submodule提交到你的git repository\n* 删除主题文件夹下的`.git`文件夹。如果这时候还不能提交，可以新建个文件夹，随便命名，将主题文件夹内的东西复制到新建的文件夹。再通过`git add`提交就可以了。","slug":"hexo/hexo-guide-3","published":1,"updated":"2016-02-23T15:24:06.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7l6001brwtz7lhol8mw"},{"title":"Hexo博客搭建教程（二）：Hexo博客的配置、使用","date":"2016-02-21T14:41:24.000Z","_content":"本文主要介绍如何对Hexo博客站点进行个性化的设置、如何安装主题以及主题的设置。\n\n<!-- more -->\n经过上一篇文章，我们已经学会如何搭建Hexo博客以及将博客部署到github上了。这篇文章主要讲如何对自己的博客站点进行个性化配置以及如何发表新文章。\n博客的配置一个是站点的配置:`d:\\hexo\\_config.yml`，一个是主题的配置:`d:\\hexo\\themes\\yilia\\_config.yml`\n## 站点的配置\n```yml\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Superman的博客 #站定的名称\nsubtitle: 超人不会飞 #站点的副标题\ndescription: 超人前端学习博客 #站点的描述\nauthor: Superman \nemail: supermanchc@gmail.com\nlanguage: zh-Hans # 语言 使用中文需要使用zh-Hans\ntimezone:  #默认操作系统的时间\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n##url 在没有绑定域名前，不需要填写\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory 目录格式，不修改\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 写作布局，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Extensions 配置主题\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n\n# Deployment 配置部署github站点，改为自己的github repository\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/superman66/superman66.github.io.git\n  branch: master\n```\n## 安装新主题\nHexo此时用的是默认的主题，如果需要更换主题，可以去[主题市场](https://github.com/tommy351/hexo/wiki/Themes)挑选自己喜爱的主题。这里以安装`yilia`主题为例。\n#### 安装\n\n``` bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n#### 配置\n\n修改hexo根目录下 `_config.yml` 的themes: \n```yml\n# Extensions 配置主题\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n```\n\n#### 更新\n\n``` bash\ncd themes/yilia\ngit pull\n```\n## 配置主题\n这样就为你的博客站点安装了新的主题。接下来对主题进行配置\n主题配置文件在主目录下的`_config.yml`：\n```\n# Header\nmenu:\n  主页: /\n  所有文章: /archives\n  # 随笔: /tags/随笔\n\n# SubNav\nsubnav:\n  github: \"#\"\n  weibo: \"#\"\n  rss: \"#\"\n  zhihu: \"#\"\n  #douban: \"#\"\n  #mail: \"#\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\nrss: /atom.xml\n\n# Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n# Miscellaneous\ngoogle_analytics: ''\nfavicon: /favicon.png\n\n#你的头像url\navatar: \"\"\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n#是否开启友情链接\n#不开启——\n#friends: false\n#开启——\nfriends:\n  奥巴马的博客: http://localhost:4000/\n  卡卡的美丽传说: http://localhost:4000/\n  本泽马的博客: http://localhost:4000/\n  吉格斯的博客: http://localhost:4000/\n  习大大大不同: http://localhost:4000/\n  托蒂的博客: http://localhost:4000/\n\n#是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n```\n\n","source":"_posts/hexo/hexo-guide-2.md","raw":"---\ntitle: Hexo博客搭建教程（二）：Hexo博客的配置、使用\ndate: 2016-02-21 22:41:24\ntags: Hexo\n---\n本文主要介绍如何对Hexo博客站点进行个性化的设置、如何安装主题以及主题的设置。\n\n<!-- more -->\n经过上一篇文章，我们已经学会如何搭建Hexo博客以及将博客部署到github上了。这篇文章主要讲如何对自己的博客站点进行个性化配置以及如何发表新文章。\n博客的配置一个是站点的配置:`d:\\hexo\\_config.yml`，一个是主题的配置:`d:\\hexo\\themes\\yilia\\_config.yml`\n## 站点的配置\n```yml\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Superman的博客 #站定的名称\nsubtitle: 超人不会飞 #站点的副标题\ndescription: 超人前端学习博客 #站点的描述\nauthor: Superman \nemail: supermanchc@gmail.com\nlanguage: zh-Hans # 语言 使用中文需要使用zh-Hans\ntimezone:  #默认操作系统的时间\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n##url 在没有绑定域名前，不需要填写\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory 目录格式，不修改\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 写作布局，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Extensions 配置主题\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n\n# Deployment 配置部署github站点，改为自己的github repository\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/superman66/superman66.github.io.git\n  branch: master\n```\n## 安装新主题\nHexo此时用的是默认的主题，如果需要更换主题，可以去[主题市场](https://github.com/tommy351/hexo/wiki/Themes)挑选自己喜爱的主题。这里以安装`yilia`主题为例。\n#### 安装\n\n``` bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n#### 配置\n\n修改hexo根目录下 `_config.yml` 的themes: \n```yml\n# Extensions 配置主题\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n```\n\n#### 更新\n\n``` bash\ncd themes/yilia\ngit pull\n```\n## 配置主题\n这样就为你的博客站点安装了新的主题。接下来对主题进行配置\n主题配置文件在主目录下的`_config.yml`：\n```\n# Header\nmenu:\n  主页: /\n  所有文章: /archives\n  # 随笔: /tags/随笔\n\n# SubNav\nsubnav:\n  github: \"#\"\n  weibo: \"#\"\n  rss: \"#\"\n  zhihu: \"#\"\n  #douban: \"#\"\n  #mail: \"#\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\nrss: /atom.xml\n\n# Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n# Miscellaneous\ngoogle_analytics: ''\nfavicon: /favicon.png\n\n#你的头像url\navatar: \"\"\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n#是否开启友情链接\n#不开启——\n#friends: false\n#开启——\nfriends:\n  奥巴马的博客: http://localhost:4000/\n  卡卡的美丽传说: http://localhost:4000/\n  本泽马的博客: http://localhost:4000/\n  吉格斯的博客: http://localhost:4000/\n  习大大大不同: http://localhost:4000/\n  托蒂的博客: http://localhost:4000/\n\n#是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n```\n\n","slug":"hexo/hexo-guide-2","published":1,"updated":"2016-02-22T14:07:48.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7la001drwtz8zr1zfvc"},{"title":"Hexo博客搭建教程（一）：Hexo介绍及搭建","date":"2016-02-21T13:33:34.000Z","_content":"终于有了自己的github博客了。记录下搭建Github.io博客的过程以及当中所遇到的坑。\n\n<!-- more -->\n# Hexo是什么\nHexo是一个基于nodejs快速、简洁且高效的博客框架。可以方便的生成静态网页文件托管到github pages。具有超快渲染速度、支持GitHub Flavored Markdown语法、一键部署等优点，同时还拥有强大的插件系统，方便用户进行定制化开发。\n# Hexo 安装\n本教程只针对windows用户。\n## 安装前提\n在安装Hexo之前，请先安装\n* Node.js\n* Git\n\n## 安装 Git\n下载[msysgit](https://git-for-windows.github.io/)进行安装即可。\n## 安装 Nodejs\n在windows下安装nodejs非常简单，直接去[官网](https://nodejs.org/)下载进行安装即可。\n## 安装 Hexo\nHexo安装也很简单。在Git和Node.js都安装后，直接使用npm进行安装即可\n```bash\nnpm install -g hexo-cli\n```\n## 创建Hexo文件夹\n在你喜爱的文件夹下，如（`D:\\hexo`）,右键选择`git bash`,执行以下命令。便会自动新建所有的文件\n```bash\nhexo init\n```\n## 安装所依赖的包\n```bash\nnpm install\n```\n## 本地查看\n到这一步，你已经在本地安装了Hexo博客。你可以通过以下的命令在本地查看博客。\n### 生成静态文件\n```bash\nhexo generate\n```\n### 运行服务\n```bash\nhexo server\n```\n此时在浏览器中输入`localhost:4000`，便可以看到博客了。至此，本地博客已经搭建好了。但是此时博客还只是在本地，别人是无法访问的。\n\n# Github部署\n## 注册Github账号\n有账号的人跳过，没有的话[注册](https://github.com/)下也很简单。\n## 创建 repository\n在个人github主页右下角点击 `New repository`,创建一个新的repository。\n新的repository的名字应该跟你github账号的名字一样。比如我的github账号是`superman66`，\n那么新的repository的名字就应该为`superman66.github.io`。\n## 部署\n进入博客所在的文件夹(如`D:\\hexo`)，找到_config.yml文件，修改以下的配置，将下面的`superman66`都换成你自己的账户名。\n```\ndeploy:\n  type: git\n  repository: https://github.com/superman66/superman66.github.io.git\n  branch: master\n```\n*注意：hexo 3.0以下，type要写成 `github`*\n这个参数是用来配置网站一键部署的。让你只需要一条命令就可以将网站部署到服务器上。\n配置文件修改之后，执行一下命令便可以完成部署了。\n```bash\nhexo generate\nhexo deploy\n```\n\n### hexo常用命令\n* `hexo new \"post_name\"`用于生成新的文章；\n* `hexo generate`用于生成静态文件；\n* `hexo server` 用于启动本地服务；\n* `hexo deploy`用于将生成的静态文件部署到repository上。\n\n同时这四个命令还支持简写\n `hexo g` === `hexo generate`\n `hexo s` === `hexo server`\n `hexo d` === `hexo deploy`\n `hexo n` === `hexo new`\n 至此，你已经将本地的博客部署到github上。你可以通过username.github.io(`username`换成你自己的账户名)来访问你的博客了 \n\n ## 问题记录\n 在部署过程中，执行`hexo d`进行部署的时候，出现以下的错误\n **`hexo bash: /dev/tty: No such device or address`**\n ### 解决办法：\n 安装github for Window，点击这里进行[下载](https://github-windows.s3.amazonaws.com/GitHubSetup.exe),使用git shell再执行`hexo d`命令进行部署即可。\n **ps:由于github for windows 在国内安装很容易失败，自己尝试了很久也都没装上。不过网上已经有人提供了github for windows离线版，有兴趣的人可以前往[下载](http://www.cnblogs.com/fantacity/p/4347472.html)**\n ### 问题的原因：\n google找到的说法是，由于window安装的git版本问题导致的。\n","source":"_posts/hexo/hexo-guide-1.md","raw":"---\ntitle: Hexo博客搭建教程（一）：Hexo介绍及搭建\ndate: 2016-02-21 21:33:34\ntags: Hexo\n---\n终于有了自己的github博客了。记录下搭建Github.io博客的过程以及当中所遇到的坑。\n\n<!-- more -->\n# Hexo是什么\nHexo是一个基于nodejs快速、简洁且高效的博客框架。可以方便的生成静态网页文件托管到github pages。具有超快渲染速度、支持GitHub Flavored Markdown语法、一键部署等优点，同时还拥有强大的插件系统，方便用户进行定制化开发。\n# Hexo 安装\n本教程只针对windows用户。\n## 安装前提\n在安装Hexo之前，请先安装\n* Node.js\n* Git\n\n## 安装 Git\n下载[msysgit](https://git-for-windows.github.io/)进行安装即可。\n## 安装 Nodejs\n在windows下安装nodejs非常简单，直接去[官网](https://nodejs.org/)下载进行安装即可。\n## 安装 Hexo\nHexo安装也很简单。在Git和Node.js都安装后，直接使用npm进行安装即可\n```bash\nnpm install -g hexo-cli\n```\n## 创建Hexo文件夹\n在你喜爱的文件夹下，如（`D:\\hexo`）,右键选择`git bash`,执行以下命令。便会自动新建所有的文件\n```bash\nhexo init\n```\n## 安装所依赖的包\n```bash\nnpm install\n```\n## 本地查看\n到这一步，你已经在本地安装了Hexo博客。你可以通过以下的命令在本地查看博客。\n### 生成静态文件\n```bash\nhexo generate\n```\n### 运行服务\n```bash\nhexo server\n```\n此时在浏览器中输入`localhost:4000`，便可以看到博客了。至此，本地博客已经搭建好了。但是此时博客还只是在本地，别人是无法访问的。\n\n# Github部署\n## 注册Github账号\n有账号的人跳过，没有的话[注册](https://github.com/)下也很简单。\n## 创建 repository\n在个人github主页右下角点击 `New repository`,创建一个新的repository。\n新的repository的名字应该跟你github账号的名字一样。比如我的github账号是`superman66`，\n那么新的repository的名字就应该为`superman66.github.io`。\n## 部署\n进入博客所在的文件夹(如`D:\\hexo`)，找到_config.yml文件，修改以下的配置，将下面的`superman66`都换成你自己的账户名。\n```\ndeploy:\n  type: git\n  repository: https://github.com/superman66/superman66.github.io.git\n  branch: master\n```\n*注意：hexo 3.0以下，type要写成 `github`*\n这个参数是用来配置网站一键部署的。让你只需要一条命令就可以将网站部署到服务器上。\n配置文件修改之后，执行一下命令便可以完成部署了。\n```bash\nhexo generate\nhexo deploy\n```\n\n### hexo常用命令\n* `hexo new \"post_name\"`用于生成新的文章；\n* `hexo generate`用于生成静态文件；\n* `hexo server` 用于启动本地服务；\n* `hexo deploy`用于将生成的静态文件部署到repository上。\n\n同时这四个命令还支持简写\n `hexo g` === `hexo generate`\n `hexo s` === `hexo server`\n `hexo d` === `hexo deploy`\n `hexo n` === `hexo new`\n 至此，你已经将本地的博客部署到github上。你可以通过username.github.io(`username`换成你自己的账户名)来访问你的博客了 \n\n ## 问题记录\n 在部署过程中，执行`hexo d`进行部署的时候，出现以下的错误\n **`hexo bash: /dev/tty: No such device or address`**\n ### 解决办法：\n 安装github for Window，点击这里进行[下载](https://github-windows.s3.amazonaws.com/GitHubSetup.exe),使用git shell再执行`hexo d`命令进行部署即可。\n **ps:由于github for windows 在国内安装很容易失败，自己尝试了很久也都没装上。不过网上已经有人提供了github for windows离线版，有兴趣的人可以前往[下载](http://www.cnblogs.com/fantacity/p/4347472.html)**\n ### 问题的原因：\n google找到的说法是，由于window安装的git版本问题导致的。\n","slug":"hexo/hexo-guide-1","published":1,"updated":"2016-04-04T07:05:14.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7ld001frwtzysl5vfho"},{"title":"Git规范","date":"2016-04-09T13:41:17.000Z","_content":"本文是目前所在公司所遵循的Git规范总结\n<!-- more -->\n经过半年的开发，现在公司内部已逐渐形成比较规范的Git规范，从分支到工作流程到发布打Tag，都形成了一套规范。特此总结下。\n# Git规范\n主要从以下三个方面介绍Git规范：\n* 分支模型\n* 工作流程\n    * Feature(新需求开发流程)\n    * Bugfix（Bug修复流程）\n* Tag规范\n# 分支模型\n 每个项目都必须要有master、dev分支。\n每个开发人员拥有一个属于自己的分支，如superman。\n如果多人共同开发一个功能，那么可以共享一个分支。\n## master分支\nmaster分支只能存在**release版本**的代码，并需要对每个release**打对应的tag**。\n## dev分支\ndev分支由master分支checkout，它的作用主要是日常开发合并代码，并与master分支做合并。\n## 开发人员自己的分支\n开发人员自己的分支，从dev分支checkout，是自己负责的功能分支的上游。\n\n# 工作流程\n开发人员在进行开发或者修复bug之前，必须要先从dev分支上拉取最新的代码。\n## Feature（新需求开发流程）\n当有新需求需要开发的时：\n1. 每个开发人员在自己的分支上checkout一个新的feature分支，如在superman的分支checkout；\n2. 在新的feature分支上进行开发；\n3. 新功能开发完毕后合并到自己的分支；\n4. 所有的人员的分支合并到dev分支，并进行测试；\n5. 测试通过后，合并到master分支，并打tag（tag示例：`REG_20160408_01`）。\n\n## Bugfix（Bug修复流程）\n这里又区分线上的Bug和开发测试阶段的Bug\n### 线上的Bug\n1. 开发人员从master分支chekcout一个新的bugfix分支，命名为：dev_bugfix（如有必，可以添加日期后缀dev_bugfix_20160409）；\n2. 开发人员在该分支上进行Bug修复；\n3. Bug修复后，提交测试；\n4. 测试通过后，合并到master分支，并打tag（tag示例：`REG_20160409_01`，如果是紧急程度非常高的Bug，可用`HOTFIX_20160409_01`）；\n5. 将master分支合并到dev分支，确保dev分支拥有master分支最新的代码。\n\n### 开发测试阶段的Bug\n1. 根据Bug所属的功能分支，分配到对应的开发人员；\n2. 开发人员直接在新feature所属的分支上进行Bug修复；\n3. Bug修复后，合并到自己的分支上，再合并到dev分支上；\n4. 提交测试。\n\n# Tag命名规范\n## 格式：`前缀_日期_序号`\n* 前缀：表示项目的各个阶段\n    * DEV：表示开发阶段，不可发布线上版本，一般用于开发完成后提测打的tag\n    * REG：表示常规发布，可以发布线上版本\n    * HOT：表示紧急修复，经测试通过后可以发布线上版本\n    * QUICK：表示纯web形式的发布，不涉及db变化\n* 日期：一般为当天的日期\n* 序号：两位数字，从01开始递增。因为一天内可能会有多个tag。\n示例：`REG_20160408_01`\n\n","source":"_posts/git/git-standard.md","raw":"---\ntitle: Git规范\ndate: 2016-04-09 21:41:17\ntags:\n- Git\n- Git规范\n---\n本文是目前所在公司所遵循的Git规范总结\n<!-- more -->\n经过半年的开发，现在公司内部已逐渐形成比较规范的Git规范，从分支到工作流程到发布打Tag，都形成了一套规范。特此总结下。\n# Git规范\n主要从以下三个方面介绍Git规范：\n* 分支模型\n* 工作流程\n    * Feature(新需求开发流程)\n    * Bugfix（Bug修复流程）\n* Tag规范\n# 分支模型\n 每个项目都必须要有master、dev分支。\n每个开发人员拥有一个属于自己的分支，如superman。\n如果多人共同开发一个功能，那么可以共享一个分支。\n## master分支\nmaster分支只能存在**release版本**的代码，并需要对每个release**打对应的tag**。\n## dev分支\ndev分支由master分支checkout，它的作用主要是日常开发合并代码，并与master分支做合并。\n## 开发人员自己的分支\n开发人员自己的分支，从dev分支checkout，是自己负责的功能分支的上游。\n\n# 工作流程\n开发人员在进行开发或者修复bug之前，必须要先从dev分支上拉取最新的代码。\n## Feature（新需求开发流程）\n当有新需求需要开发的时：\n1. 每个开发人员在自己的分支上checkout一个新的feature分支，如在superman的分支checkout；\n2. 在新的feature分支上进行开发；\n3. 新功能开发完毕后合并到自己的分支；\n4. 所有的人员的分支合并到dev分支，并进行测试；\n5. 测试通过后，合并到master分支，并打tag（tag示例：`REG_20160408_01`）。\n\n## Bugfix（Bug修复流程）\n这里又区分线上的Bug和开发测试阶段的Bug\n### 线上的Bug\n1. 开发人员从master分支chekcout一个新的bugfix分支，命名为：dev_bugfix（如有必，可以添加日期后缀dev_bugfix_20160409）；\n2. 开发人员在该分支上进行Bug修复；\n3. Bug修复后，提交测试；\n4. 测试通过后，合并到master分支，并打tag（tag示例：`REG_20160409_01`，如果是紧急程度非常高的Bug，可用`HOTFIX_20160409_01`）；\n5. 将master分支合并到dev分支，确保dev分支拥有master分支最新的代码。\n\n### 开发测试阶段的Bug\n1. 根据Bug所属的功能分支，分配到对应的开发人员；\n2. 开发人员直接在新feature所属的分支上进行Bug修复；\n3. Bug修复后，合并到自己的分支上，再合并到dev分支上；\n4. 提交测试。\n\n# Tag命名规范\n## 格式：`前缀_日期_序号`\n* 前缀：表示项目的各个阶段\n    * DEV：表示开发阶段，不可发布线上版本，一般用于开发完成后提测打的tag\n    * REG：表示常规发布，可以发布线上版本\n    * HOT：表示紧急修复，经测试通过后可以发布线上版本\n    * QUICK：表示纯web形式的发布，不涉及db变化\n* 日期：一般为当天的日期\n* 序号：两位数字，从01开始递增。因为一天内可能会有多个tag。\n示例：`REG_20160408_01`\n\n","slug":"git/git-standard","published":1,"updated":"2016-04-09T15:39:18.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7lh001hrwtz3iophjty"},{"title":"随笔系列","date":"2016-02-21T06:38:42.000Z","_content":"# 随笔\n待完善。。。","source":"_posts/essays/write.md","raw":"---\ntitle: 随笔系列\ndate: 2016-02-21 14:38:42\ntags: 随笔\n---\n# 随笔\n待完善。。。","slug":"essays/write","published":1,"updated":"2016-02-21T13:44:14.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7lm001mrwtzl8qg5zhk"},{"title":"2016阅读书单","date":"2016-04-30T14:58:19.000Z","_content":"记录2016阅读过的书籍\n<!-- more -->\n# 2016-04-阅读列表\n## 《暗时间》\n详见暗时间读书笔记[查看笔记](http://supemran66.github.io/2016/04/30/essays/darktime-reading-note/)\n# 2016-03-阅读列表\n## 《高危地带》\n一本讲述了埃博拉病毒的产生以及历史。对埃博拉这种强大的病毒有了比较全面的认识，原来这世界上还存在着比艾滋病还厉害的病毒。同样是目前尚无医学治疗方法的病毒，艾滋病和埃博拉比较起来可是温柔得太多太多。艾滋病会有潜伏期，而且艾滋病只是攻击人身体的免疫系统，对人类其它器官并不会产生致命性伤害。而埃博拉病毒则不同，发病期短至5到7天，同时埃博拉会攻击人类的肝脏等器官，感染者将承受巨大的痛苦并死去。\n## 《你不知道的JavaScript（上）》\n作为JavaScript界风头很大的新书，又怎么能错过呢？看到早读课的“21天阅读行动”的书单中包含这本书，但是还是没有去报名参加。自己默默根据自身情况进行选择性阅读，主要集中在第一部分：作用域和闭包，以及第二部分第一章：关于this。\n虽然进度不快，但每一章都看得非常仔细并做了读书笔记。非常不错的一本书，特别是关于javascript的作用域这部分的内容，用非常易懂的语言解释了内在的原理。如果你对js的作用域和变量提升相关问题还有困惑，那么你应该阅读这本书了。\n* 【你不知道的JavasSript(上)读书笔记】第1章：作用域（[查看笔记](http://superman66.github.io/2016/03/12/you-donot-konw-javascript-reading-notes/)）\n* 【你不知道的JavasSript(上)读书笔记】第2章：词法作用域（[查看笔记](http://superman66.github.io/2016/03/15/you-donot-konw-javascript-reading-notes-2/)）\n## 《JavaScript高级程序设计（第三版）》\nJavaScript的经典之作，依然采用按需阅读+读书笔记方式进行学习。主要学习了`面向对象程序设计`和`事件`这两章。`面对对象程序设计`这一章讲得非常详细，深入理解了创建对象的8种方式，以及理解了JavaScript中关于原型链继承的问题。\n* 【JavaScript高程学习笔记】面向对象的程序设计之继承（[查看笔记](http://superman66.github.io/2016/03/06/javascript-inherit/)）\n* 【JavaScript高程学习笔记】面向对象的程序设计之对象（[查看笔记](http://superman66.github.io/2016/02/26/javascript-learning-object)）\n## 《JavaScript权威指南》\n这本书的权威性就不用多说了。确实是一本质量非常高的书。结合上面两本书，深入学习了作用域和变量提升。\n* 深入理解变量声明提升和函数声明提升([查看笔记](http://superman66.github.io/2016/03/05/javascript-hoisting/))\n# 2016-02-阅读列表\n## 《把时间当朋友》- 很不错的一本关于时间与精力的书。\n\n书中有个观点非常有意思：利用黄金分割法来规划你的时间。如果你一天可以规划的时间有10个小时，那么大概用6.18小时去工作学习，剩下的大约3.82小时去享受欢乐。我们总想着一直保持高效率的运转，但这是不切实际的。所以不妨试试这个方法来规划你的时间。\n\n## 《当我跑步时，我谈些什么》- 村上春树的经典之作\n\n喜欢就一个理由，不喜欢却有千千万万的借口。为什么我现在还没有开始跑步呢，可能是自己还没找到一个可以为之坚持的理由吧！\n\n## 《高效程序员的45个习惯》- 论程序猿的自我修养\n\n程序猿学习应该是迭代和增量式学习。每天用一定时间来学习新技术，不需要很多时间，但要经常进行。记录新的技术，在计划时间学习。ps:这不就是互联网的节奏嘛，快速迭代，小步快跑。\n\n## 《小强升职记》 - 这名字无力吐槽了，但是不能以貌取人\n\n\n实操性非常强的一本书，感谢这本书让我获得了行动计划的习惯。当然了，书中还提到很多非常行之有效的办法，只不过我没学到。\n\n## 《程序员跳槽全攻略》 - 其实是我想跳槽了\n\n\n就算是不想跳槽的程序猿也值得看一看。因为总有一天你也会面临跳槽的问题。\n\n## 《人类简史》 - 别被名字吓到了，内容和文字非常浅显易懂！\n\n“现代人类的各种破坏大自然的行为，被很多人称呼是“自然的毁灭”。然而，这其实并不能算是“毁灭”，而只是“改变”。自然是无法“毁灭”的。6500万年前，一颗陨石让恐龙灭绝，但却为哺乳类动物开启了一条康庄大道。今天，人类正在让许多物种灭绝，甚至可能包括自己。但即使如此，还是有某些生物过得生龙活虎。举例来说，老鼠和蟑螂可说是正在全盛时期。如果今天发生核灾而让世界末日降临，这些顽强的动物很有可能就会从闷烧的废墟里爬出来，准备好继续将自己的DNA传给千代万代。或许，现在的6500万年后，会有一群高智商的老鼠心怀感激地回顾人类造成的这场灾难，就像我们现在感谢那颗杀死恐龙的陨石一般。” 细思极恐！\n","source":"_posts/essays/reading-list-2016.md","raw":"---\ntitle: 2016阅读书单\ndate: 2016-04-30 22:58:19\ntags:\n- 阅读书单\n- 随笔\n---\n记录2016阅读过的书籍\n<!-- more -->\n# 2016-04-阅读列表\n## 《暗时间》\n详见暗时间读书笔记[查看笔记](http://supemran66.github.io/2016/04/30/essays/darktime-reading-note/)\n# 2016-03-阅读列表\n## 《高危地带》\n一本讲述了埃博拉病毒的产生以及历史。对埃博拉这种强大的病毒有了比较全面的认识，原来这世界上还存在着比艾滋病还厉害的病毒。同样是目前尚无医学治疗方法的病毒，艾滋病和埃博拉比较起来可是温柔得太多太多。艾滋病会有潜伏期，而且艾滋病只是攻击人身体的免疫系统，对人类其它器官并不会产生致命性伤害。而埃博拉病毒则不同，发病期短至5到7天，同时埃博拉会攻击人类的肝脏等器官，感染者将承受巨大的痛苦并死去。\n## 《你不知道的JavaScript（上）》\n作为JavaScript界风头很大的新书，又怎么能错过呢？看到早读课的“21天阅读行动”的书单中包含这本书，但是还是没有去报名参加。自己默默根据自身情况进行选择性阅读，主要集中在第一部分：作用域和闭包，以及第二部分第一章：关于this。\n虽然进度不快，但每一章都看得非常仔细并做了读书笔记。非常不错的一本书，特别是关于javascript的作用域这部分的内容，用非常易懂的语言解释了内在的原理。如果你对js的作用域和变量提升相关问题还有困惑，那么你应该阅读这本书了。\n* 【你不知道的JavasSript(上)读书笔记】第1章：作用域（[查看笔记](http://superman66.github.io/2016/03/12/you-donot-konw-javascript-reading-notes/)）\n* 【你不知道的JavasSript(上)读书笔记】第2章：词法作用域（[查看笔记](http://superman66.github.io/2016/03/15/you-donot-konw-javascript-reading-notes-2/)）\n## 《JavaScript高级程序设计（第三版）》\nJavaScript的经典之作，依然采用按需阅读+读书笔记方式进行学习。主要学习了`面向对象程序设计`和`事件`这两章。`面对对象程序设计`这一章讲得非常详细，深入理解了创建对象的8种方式，以及理解了JavaScript中关于原型链继承的问题。\n* 【JavaScript高程学习笔记】面向对象的程序设计之继承（[查看笔记](http://superman66.github.io/2016/03/06/javascript-inherit/)）\n* 【JavaScript高程学习笔记】面向对象的程序设计之对象（[查看笔记](http://superman66.github.io/2016/02/26/javascript-learning-object)）\n## 《JavaScript权威指南》\n这本书的权威性就不用多说了。确实是一本质量非常高的书。结合上面两本书，深入学习了作用域和变量提升。\n* 深入理解变量声明提升和函数声明提升([查看笔记](http://superman66.github.io/2016/03/05/javascript-hoisting/))\n# 2016-02-阅读列表\n## 《把时间当朋友》- 很不错的一本关于时间与精力的书。\n\n书中有个观点非常有意思：利用黄金分割法来规划你的时间。如果你一天可以规划的时间有10个小时，那么大概用6.18小时去工作学习，剩下的大约3.82小时去享受欢乐。我们总想着一直保持高效率的运转，但这是不切实际的。所以不妨试试这个方法来规划你的时间。\n\n## 《当我跑步时，我谈些什么》- 村上春树的经典之作\n\n喜欢就一个理由，不喜欢却有千千万万的借口。为什么我现在还没有开始跑步呢，可能是自己还没找到一个可以为之坚持的理由吧！\n\n## 《高效程序员的45个习惯》- 论程序猿的自我修养\n\n程序猿学习应该是迭代和增量式学习。每天用一定时间来学习新技术，不需要很多时间，但要经常进行。记录新的技术，在计划时间学习。ps:这不就是互联网的节奏嘛，快速迭代，小步快跑。\n\n## 《小强升职记》 - 这名字无力吐槽了，但是不能以貌取人\n\n\n实操性非常强的一本书，感谢这本书让我获得了行动计划的习惯。当然了，书中还提到很多非常行之有效的办法，只不过我没学到。\n\n## 《程序员跳槽全攻略》 - 其实是我想跳槽了\n\n\n就算是不想跳槽的程序猿也值得看一看。因为总有一天你也会面临跳槽的问题。\n\n## 《人类简史》 - 别被名字吓到了，内容和文字非常浅显易懂！\n\n“现代人类的各种破坏大自然的行为，被很多人称呼是“自然的毁灭”。然而，这其实并不能算是“毁灭”，而只是“改变”。自然是无法“毁灭”的。6500万年前，一颗陨石让恐龙灭绝，但却为哺乳类动物开启了一条康庄大道。今天，人类正在让许多物种灭绝，甚至可能包括自己。但即使如此，还是有某些生物过得生龙活虎。举例来说，老鼠和蟑螂可说是正在全盛时期。如果今天发生核灾而让世界末日降临，这些顽强的动物很有可能就会从闷烧的废墟里爬出来，准备好继续将自己的DNA传给千代万代。或许，现在的6500万年后，会有一群高智商的老鼠心怀感激地回顾人类造成的这场灾难，就像我们现在感谢那颗杀死恐龙的陨石一般。” 细思极恐！\n","slug":"essays/reading-list-2016","published":1,"updated":"2016-04-30T15:41:35.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7lq001prwtzr616ld00"},{"title":"关于离职的思考","date":"2016-04-07T13:35:32.000Z","_content":"关于离职过程的思考\n<!-- more -->\n　　在拿到了宅米的offer之后，便向上司提出了离职了。这是我在添米提的第二次离职。相比较上一次，这次的提出离职的过程让我思考颇多，跟上司，跟CEO直接对话沟通。也跟爸爸、姐姐交流了我的想法和困惑。思考能不断成长，记录总结则能巩固你的思考结果。 \n　　提出离职后，先是被上司谈话了。真的是晓之以情动之以理，希望我能留下来。作为一名资深程序员，大公司和创业公司都待过的他，给出的建议确实非常得中肯。其中他提到如何看待跳槽的本质我觉得非常有道理。对于不同的人跳槽是有不同的目的。如果你是为了钱而跳槽，那么跳槽的本质就要回归到钱上面了。薪资只是一个衡量的维度，并不能因为对方的薪资看起来比较高，就觉得性价比更高。但其实不然，更应该比较的是你的时薪。他以一个很典型的例子举例说明了这个问题： \n　　“有两份工作A和B，A月薪10k，但是很轻松，有比较多的时间可以自我成长；B月薪有15k，但是工作时间久，经常晚上和周末加班。如果比较月薪的话，B似乎占有优势，但是我们将A、B工作分别转换成时薪再来对比一下。这里假设A每日工作8个小时，每周工作5天，每个月算4周，时薪为(8x5x4)/10000 = 62.5；B则是996（早上9点到晚上9点，每周上6天），时薪为 （12x6x4）/15000 = 52”。通过比较时薪就可以看出来，其实B工作的时薪并没有比A工作高。因此在跳槽的时候，如果更看重薪资的涨幅的话，那么你就不应该作为时薪的比较。默默算了下自己的时薪只有53元/小时，还得继续努力！ \n　　上司谈话结束后，又接着被CEO约谈了。先是一番好话说尽，然后加薪，比对方公司给的多（能被挽留说明你有存在的价值）。谈完薪资后，CEO就开始在传授着一些人生道理。果然听君一席话胜读十年书。CEO很少给我们灌心灵鸡汤，反而一直都是在灌输着心灵毒药，让我们认清现实的世界。其中几点我感触颇深：\n\n认清你自己 \n　　虽然说任何时候认清自己都不算晚，但是如果你在28岁就认清自己要走的道理和在35岁认清可有着巨大的差别。28岁的你可以无牵绊得去追逐自己的内心，但是35岁的你如果想要继续follow your heart，可能就显得力不从心了。所以越早认清你自己要走的道理越好。从技术角度出发，有两种典型的职业发展轨迹：专家技术型和技术转管理型。对于专家技术型，并不是每个人都适合，也不是每个人都能做到的。能做到专家的永远只有少数人。想要成为专家跟努力和天赋都分不开的。 \n　　相比之下，技术转管理型倒更符合大部分人的轨迹。因为你的能力即使再强，也只能说是你的单兵作战能力强。但现在这个社会需要的是连接和团队协作。每个研究技术到一个高度后的it人员，在后面的职业生涯中肯定会遇到如何带团队的问题。带一个团队你要懂技术、拥有良好的沟通能力（很多技术人员沟通能力确实有待提高，自勉~），管理能力、情商还不能太低（情商低的人基本上都不受欢迎）等等一些能力。都说管理是一门技术、一门艺术。因此如果你认清了自己要走的这条道路之后，已经可以预见到在未来你会碰到带团队的问题，那么你为什么不从现在就去开始培养这些能力？\n关于投资和理财 \n　　30岁之前拼命赚钱，30岁之后用一部分资产做投资来获得收益，利用工作来获得现金流维持正常生活的运转。这样就可以保证了一定程度上的财务自由。\n选择比努力更重要 \n　　我想要跳槽的那家公司是做校园Ｏ2O，我现在待的公司是做互联网金融。CEO就谈到，他觉得互联网金融这个领域中国还开始处于起步阶段，因为中国的金融正在朝着金融市场化的方向在发展。所以互联网金融还是存在比较多的机会。而校园O2O是消费场景，面对的是广大的用户。经过美团和大众点评的合并，O2O这个行业已经进入了红海阶段。因此在选择一家公司的时候，不仅要看公司的软硬条件是否符合自己的预期，也要判断市场行业的趋势，毕竟如果方向选择对了，那么剩下的就是努力的问题了。\n这次算是和CEO进行一次比较深入的对话。沟通交流最奇妙的地方就在于能让1+1产生大于2的效果。","source":"_posts/essays/leave-office.md","raw":"---\ntitle: 关于离职的思考\ndate: 2016-04-07 21:35:32\ntags:\n- 随笔\n---\n关于离职过程的思考\n<!-- more -->\n　　在拿到了宅米的offer之后，便向上司提出了离职了。这是我在添米提的第二次离职。相比较上一次，这次的提出离职的过程让我思考颇多，跟上司，跟CEO直接对话沟通。也跟爸爸、姐姐交流了我的想法和困惑。思考能不断成长，记录总结则能巩固你的思考结果。 \n　　提出离职后，先是被上司谈话了。真的是晓之以情动之以理，希望我能留下来。作为一名资深程序员，大公司和创业公司都待过的他，给出的建议确实非常得中肯。其中他提到如何看待跳槽的本质我觉得非常有道理。对于不同的人跳槽是有不同的目的。如果你是为了钱而跳槽，那么跳槽的本质就要回归到钱上面了。薪资只是一个衡量的维度，并不能因为对方的薪资看起来比较高，就觉得性价比更高。但其实不然，更应该比较的是你的时薪。他以一个很典型的例子举例说明了这个问题： \n　　“有两份工作A和B，A月薪10k，但是很轻松，有比较多的时间可以自我成长；B月薪有15k，但是工作时间久，经常晚上和周末加班。如果比较月薪的话，B似乎占有优势，但是我们将A、B工作分别转换成时薪再来对比一下。这里假设A每日工作8个小时，每周工作5天，每个月算4周，时薪为(8x5x4)/10000 = 62.5；B则是996（早上9点到晚上9点，每周上6天），时薪为 （12x6x4）/15000 = 52”。通过比较时薪就可以看出来，其实B工作的时薪并没有比A工作高。因此在跳槽的时候，如果更看重薪资的涨幅的话，那么你就不应该作为时薪的比较。默默算了下自己的时薪只有53元/小时，还得继续努力！ \n　　上司谈话结束后，又接着被CEO约谈了。先是一番好话说尽，然后加薪，比对方公司给的多（能被挽留说明你有存在的价值）。谈完薪资后，CEO就开始在传授着一些人生道理。果然听君一席话胜读十年书。CEO很少给我们灌心灵鸡汤，反而一直都是在灌输着心灵毒药，让我们认清现实的世界。其中几点我感触颇深：\n\n认清你自己 \n　　虽然说任何时候认清自己都不算晚，但是如果你在28岁就认清自己要走的道理和在35岁认清可有着巨大的差别。28岁的你可以无牵绊得去追逐自己的内心，但是35岁的你如果想要继续follow your heart，可能就显得力不从心了。所以越早认清你自己要走的道理越好。从技术角度出发，有两种典型的职业发展轨迹：专家技术型和技术转管理型。对于专家技术型，并不是每个人都适合，也不是每个人都能做到的。能做到专家的永远只有少数人。想要成为专家跟努力和天赋都分不开的。 \n　　相比之下，技术转管理型倒更符合大部分人的轨迹。因为你的能力即使再强，也只能说是你的单兵作战能力强。但现在这个社会需要的是连接和团队协作。每个研究技术到一个高度后的it人员，在后面的职业生涯中肯定会遇到如何带团队的问题。带一个团队你要懂技术、拥有良好的沟通能力（很多技术人员沟通能力确实有待提高，自勉~），管理能力、情商还不能太低（情商低的人基本上都不受欢迎）等等一些能力。都说管理是一门技术、一门艺术。因此如果你认清了自己要走的这条道路之后，已经可以预见到在未来你会碰到带团队的问题，那么你为什么不从现在就去开始培养这些能力？\n关于投资和理财 \n　　30岁之前拼命赚钱，30岁之后用一部分资产做投资来获得收益，利用工作来获得现金流维持正常生活的运转。这样就可以保证了一定程度上的财务自由。\n选择比努力更重要 \n　　我想要跳槽的那家公司是做校园Ｏ2O，我现在待的公司是做互联网金融。CEO就谈到，他觉得互联网金融这个领域中国还开始处于起步阶段，因为中国的金融正在朝着金融市场化的方向在发展。所以互联网金融还是存在比较多的机会。而校园O2O是消费场景，面对的是广大的用户。经过美团和大众点评的合并，O2O这个行业已经进入了红海阶段。因此在选择一家公司的时候，不仅要看公司的软硬条件是否符合自己的预期，也要判断市场行业的趋势，毕竟如果方向选择对了，那么剩下的就是努力的问题了。\n这次算是和CEO进行一次比较深入的对话。沟通交流最奇妙的地方就在于能让1+1产生大于2的效果。","slug":"essays/leave-office","published":1,"updated":"2016-04-09T14:50:04.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7lu001trwtzik0ifeup"},{"title":"【随笔】入坑机械键盘","date":"2016-03-21T16:21:48.000Z","_content":"入手人生第二机械键盘\n<!-- more -->\n前天晚上在别人的博客上看到了介绍**酷冷至尊XT**的文章，有半价filco之称。最致命的就是他给键盘拍的照片，深深地吸引了我。原来机械键盘还可以拍得这么好看。立马就去京东买下了这把键盘：酷冷至尊 XT 红轴，因为我已经有一把青轴了，那键盘敲击声和段落感简直爽。\n键盘到手后第一件事就是为键盘拍照，毕竟我可是看了照片才决定要买的。拿出单反，换上50mm的镜头，打上黄色的灯光。原来我特么也可以将一个键盘拍得这么好看。\n\n\n----------------------------\n![](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_keyboard-1.jpg)\n\n\n----------------------------\n![2](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_keyboard-2.jpg)\n\n\n----------------------------\n这世界上有两样是用了就再也不回去的东西，一个是固态硬盘（这年头没装个ssd都不好意思说你是写代码的），另外一个就是机械键盘。\n一开始可能你还无法感受到机械键盘和薄膜键盘的区别。等到时间一久之后，再用回薄膜键盘，那手感简直弱爆了。在买回这把机械键盘后，我已经把家里所有的薄膜键盘都扔了，再也不要用它们了。就是这么任性！\n\n\n","source":"_posts/essays/essays-mechanical-keyboard.md","raw":"---\ntitle: 【随笔】入坑机械键盘\ndate: 2016-03-22 00:21:48\ntags:\n- 随笔\n- 机械键盘\n---\n入手人生第二机械键盘\n<!-- more -->\n前天晚上在别人的博客上看到了介绍**酷冷至尊XT**的文章，有半价filco之称。最致命的就是他给键盘拍的照片，深深地吸引了我。原来机械键盘还可以拍得这么好看。立马就去京东买下了这把键盘：酷冷至尊 XT 红轴，因为我已经有一把青轴了，那键盘敲击声和段落感简直爽。\n键盘到手后第一件事就是为键盘拍照，毕竟我可是看了照片才决定要买的。拿出单反，换上50mm的镜头，打上黄色的灯光。原来我特么也可以将一个键盘拍得这么好看。\n\n\n----------------------------\n![](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_keyboard-1.jpg)\n\n\n----------------------------\n![2](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_keyboard-2.jpg)\n\n\n----------------------------\n这世界上有两样是用了就再也不回去的东西，一个是固态硬盘（这年头没装个ssd都不好意思说你是写代码的），另外一个就是机械键盘。\n一开始可能你还无法感受到机械键盘和薄膜键盘的区别。等到时间一久之后，再用回薄膜键盘，那手感简直弱爆了。在买回这把机械键盘后，我已经把家里所有的薄膜键盘都扔了，再也不要用它们了。就是这么任性！\n\n\n","slug":"essays/essays-mechanical-keyboard","published":1,"updated":"2016-03-21T16:55:54.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7lx001vrwtz64xvu53d"},{"title":"《暗时间》读书笔记","date":"2016-04-30T14:58:21.000Z","_content":"这本书是从刘未鹏8年的博客文章中精选出来的，主要关于心智模式、学习方法和时间利用，《暗时间》的书名便来自于此。这篇文章便是我在看完《暗时间》后的读书笔记。\n<!-- more -->\n一本豆瓣评分8.5分的书，忘记是从哪个地方了解到这本书，只记得被暗时间这个书名吸引了，于是第一时间看起来了。第一篇顺着目录，挑着感兴趣的话题读了一遍。第二遍的时候，从头到尾，一字一句得看完了。本来这篇读书笔记应该在更早的几天就该完成了，可是总是想着等做完思维导图才开始动笔写。然而这思维导图憋了几天也没完成，于是索性先放弃思维导图，转向写文章了\n\n>《暗时间》以心理学、认知科学和神经科学为主要角度，对学习心理学的意义、日常生活中人们如何进行思考，不同的思维方式会带来怎样的价值，何种学习方法才是有效的，以及在数学和计算机科学学习过程中如何分析问题并解决问题都做了详细的阐述，强调人们需要主动训练自身的反思能力并掌握有效的思考方法。\n\n看一本书，如果不能迭代你的认知与知识的话，那就不能叫学习，只能称为娱乐。因为你只是在重复了解你原本就已经知道的知识。下面的几个部分是我看完《暗时间》后的被迭代的。\n## 暗时间是什么\n作者用了比较大的篇幅介绍了暗时间的意义。其中有一个比喻非常形象：\n> 如果你有一台计算机，你装了一个系统之后就整天把他搁置在那里，你觉得这台计算机被实际使用了吗？没有，因为CPU整天运行的就是空闲进程。运行空闲进程也是一天，运行大数据量计算的程序也是一天，对于CPU来说同样的一天，价值却是完全不一样。\n\n非常生动形象的比喻。了解过计算机的人一看这个比喻就立马明白了什么是暗时间的意义。作者接着又举了一个更普通的例子来说明：\n>如果你正在学习一门专业，你使用自己所投入的天数来衡量，很容易就产生一种错觉，认为投入了不少时间，然而其实，“投入时间”这个说法本身就是荒唐的，实际投入的是时间和效率的乘积。\n\n通过上面两个举例，相信你可以很明了暗时间有什么意义了。作者认为，所谓**暗时间就是你的思维时间**，你走路，买菜，洗脸洗手，坐公交，逛街、出游、吃饭、睡觉所有的这些时间都可以成为暗时间，你可以充分利用这些时间思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将产生庞大的效应。能够充分利用暗时间的人将无形中多出一大块生命。牛逼的人不仅在自己擅长的领域非常牛逼，连在“业务、兴趣“的领域也特别的牛逼。每每看到这样的人，总是会疑惑，他们怎么哪里来的这么多时间，居然可以在这么多个领域达到如此卓越的地步。或许其中一个原因就是牛逼的人特别善于利用暗时间。\n这是一个非常具有实用价值的概念。尤其是在移动互联网空前发达的今天，随处可见低头一族。吃饭时刷刷朋友圈，看看新闻；等车时刷刷微博；挤地铁时又掏出手机刷着各种公众号文章。大部分的暗时间已经被手机占领了，每天接触着大量的信息，却没有花时间消化，那么多信息你只是看过而已，如果没有进一步的回顾、整理以及内化，看过的文章其实没有在你脑子留下任何有价值的信息。信息过载等同于没有信息。\n现在的我已经逐渐在学习排除干扰因素，增加暗时间来思考了。\n* 关闭朋友圈，减少每天频繁刷朋友圈的次数\n* 每天早上等公交，等地铁的时间用来思考，千万别看手机\n* 地铁拥挤的时候无法看书，也将其纳入暗时间，用来思考。思考的内容包括但不限于：今天的工作计划、近期的阅读计划、待写的文章、人生思考等。\n* 其他暗时间还在慢慢纳入\n\n要想充分利用好暗时间，还需要一个非常重要的技能：**专注，不仅包括能快速进入专注的状态，还包括能够长期保持专注状态。这两个是高效学习最重要的习惯**。\n不得不承认，专注力已经作为一种稀缺资源了。生活中充满着各种分散你注意力的事物，qq消息，邮件提醒，微信消息提醒，朋友圈动态提醒等等太多了。稍微没有控制住，你的注意力就被分散，你就无法专注了。解决这个办法很简单：杜绝一切干扰因素，关闭手机提醒、邮件提醒、qq消息提醒、微信消息提醒，甚至在必要的时候可以断网。\n除了专注，还有一个高效的习惯：**抗干扰**。\n>只有超强的抗干扰能力，才能有效地利用起前面提到的各种暗时间。\n\n因为大多数的暗时间都是处于室外复杂，喧闹的环境，干扰的因素很多。还好抗干扰能力也是可以练习出来的。\n于我而言，现在每天上班的地铁时间，就是我高效看书的时间。一开始也是无法专心在那么嘈杂的环境下安心专注得看书，但经过近半年的训练，在地铁中，现在已经能非常快速得进入阅读状态了。事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法。另外作者还提到，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。\n\n## 设计自己的进度条\n设计进度条其实和流行的GTD方法学类似，其核心理念在于\n>如果你把任务分割了，你就有了进度条，你就知道，事情是在不断紧张，你总会完成任务或到达你的目标，你会有一个时间估计。反之，如果没有这个分割，整个的任务或目标对你而言就只有两种状态——“完成”和“未完成”\n\n有接触过GTD（Get Thing Done）的人都明白，GTD的方法论就是记录下你所有要做的事，然后再去安排、执行（这是最初级的阶段）。更深入一点的GTD则是：列下所有要做的事，**对每件事都进行拆分**。对于要做的这件事，你可以实际采取的下一步行动是什么。以此类推，每一步都去分析**下一步行动**。到最后的结果便是，一件事就会被拆分成多个下一步行动，每一个行动都是可以实际做到的。这样下来，Get Thing Done就是一件顺理成章的事。\n\n如果我们对于任务或者目标没有进行合理得设计进度条，那么在目标达到之前，你的状态就会一直都是“未完成”，一次又一次的未完成会耗尽你的耐心，让你下意识的产生“这事什么时候才能完成呢？“的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的，这样导致的后果就是你会心生怯意，不敢进一步投入时间，免得血本无归。在这要的心理下，不少人就会选择保守策略——退出。设计进度条就是基于人的这种心理弱点，如果你对整个目标的几个重大步骤都有清晰的界定，能够对每个步骤的耗时作出靠谱的上界估计，你就不会被不确定的未来，不确定的时间投入感到恐惧。就会心生退意。\n所以作者就提出了\n>不要过早退出循环\n\n因为即使是设计了进度条，在遇到困难时，大部分的人依然会想到退出、逃避。我们在尝试新事物的时候，会遇到各种各样的困难，不同的人会在碰壁不同的次数之后退出。\n>用程序员喜欢的话就是，我们都在for循环，区别在于你是什么情况下break；有的人退出阙值高，这是能坚持的一类人；有的人退出阙值低，一遇到困难就退出了。\n\n最喜欢这种用程序比喻了，高度贴切。就好比笑点有高有低，坚持阙值也有高有低，下次要放弃之前，先问问自己“难道你是容易放弃的人吗？”。\n>过早退出是一切失败的根源\n\n## 靠专业技能的成功最具有可复制性\n如果说世界上有一种成功可以复制，那也只有靠专业技能的成功可以称得上这种成功了。因为它只需要的只是你在一个领域坚持不懈地专注下去，只需要选择一个不算不太靠谱的方向，然后专心致志得专下去，最后必然能成为高手或者绝顶高手。世界上有很多成功带有偶然因素和运气成分或出身环境，但至少这一样，被无数人复制了无数遍，否则就不会存在学校和教育了。\n\n## 为什么你应该（从现在开始）写博客\n因为写博客有很多好处，却没有任何明显的坏处。\n* 能够交到很多志同道合的朋友\n* 写博客就是对你思考结果、学习结果的再次整理\n 自从开始开通博客之后，每次都会将学习过程记录成博客。每次在写博客的过程中，为了能让自己可以表达更清楚明了，又会趋使我去深入了解。\n* 教是最好的学；\n>为了让一个不明白的人做到明白，你必须要知道从明白到不明白他究竟需要掌握哪些概念，这就迫使我们对我们大脑中的整个知识体系来个寻根究底，把大脑中的那些我们知道，但不知道自己知道的潜在概念或假设都挖出来，把它们从内隐记忆拉扯到外显记忆中。因为只有完全知道，并知道自己知道一切来龙去脉的人，才能真正把一件事情讲得通通透透。\n* 激励你去持续学习和思考\n刚开始可能觉得没有什么内容可以写，这个时候，为了更新博客，我会去逼迫自己为了写而写。看完一本书，会逼迫自己写点读书笔记（就好比这篇文章）；学完一个知识后，我会逼迫自己将学习过程、总结记录下来。写的过程，又促使我进行了二次思考和学习。\n* 学会持之以恒的做一件事情\n如果有什么是我希望坚持做下去的话，那么写博客将会是我的第一选择。\n* 一个长期的价值博客是一份很好的简历。\n作为程序员，拥有自己的网站或者博客，你已经比大多数人进步了。如果能长期坚持写下去，那更是超越了全国90%的用户了（数字纯属杜撰）。一个好的博客就应该如同朋友圈，新朋友通过朋友圈可以大致了解你；博客则是一个让别人了解自己的窗口。（这里的简历指广义上的简历：别人了解自己的窗口）\n\n## 什么才是你不可替代性和核心竞争力\n物依稀为贵，这条最基本经济学铁律已是深入人心。人才在社会上的本质就是一种商品，而商品的稀缺性决定着商品的价值。稀缺性，换种说法就是不可替代性。不可替代性越强，价格就会越高。\n那么如何构筑自己的个人知识体系，提高自己的稀缺性呢？\n作者通过观察得出一个观点：\n>个人的核心竞争力是他独特的个性、知识、经验组合。如果这种组合\n1、绝无仅有\n2、在实践中有价值\n3、具有可持续发展性\n那你就具有核心竞争力。\n\n作者认为以下的知识技能组合是具有相当程度的不可替代性：\n>1、专业技能：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。\n2、跨领域的技能：解决问题的能力，创新思维，判断与决策能力，Critical-Thinking(批判性思维)，表达沟通能力，Open Mind等。\n3、学习能力：严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如果培养学习能力，就是持续学习和思考新知识\n4、性格要素：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑等等\n\n不管所处哪个行业，上面所说的四个技能都是适用的。作为程序员，专业技能这点是毋庸置疑的。但也千万别忘了培养后面三种技能。专业技能决定了你能走多远，而后面的技能却决定着你能飞多高。\n\n## 精彩摘录\n>1、兴趣遍地都是，专注和持之以恒才是真正稀缺的。\n2、人与人的差距不在资质上，而在花在思考的时间与思考的深度上\n3、靠专业技能的成功是最具有可复制性的\n4、大学期间，最不缺的就是业余时间，最缺的就是专注精神，非凡的注意力造就非凡的专家\n\n参考资料\n来源： http://baike.baidu.com/subview/3147362/11243902.htm#viewPageContent","source":"_posts/essays/darktime-reading-note.md","raw":"---\ntitle: 《暗时间》读书笔记\ndate: 2016-04-30 22:58:21\ntags:\n- 随笔\n- 读书笔记\n---\n这本书是从刘未鹏8年的博客文章中精选出来的，主要关于心智模式、学习方法和时间利用，《暗时间》的书名便来自于此。这篇文章便是我在看完《暗时间》后的读书笔记。\n<!-- more -->\n一本豆瓣评分8.5分的书，忘记是从哪个地方了解到这本书，只记得被暗时间这个书名吸引了，于是第一时间看起来了。第一篇顺着目录，挑着感兴趣的话题读了一遍。第二遍的时候，从头到尾，一字一句得看完了。本来这篇读书笔记应该在更早的几天就该完成了，可是总是想着等做完思维导图才开始动笔写。然而这思维导图憋了几天也没完成，于是索性先放弃思维导图，转向写文章了\n\n>《暗时间》以心理学、认知科学和神经科学为主要角度，对学习心理学的意义、日常生活中人们如何进行思考，不同的思维方式会带来怎样的价值，何种学习方法才是有效的，以及在数学和计算机科学学习过程中如何分析问题并解决问题都做了详细的阐述，强调人们需要主动训练自身的反思能力并掌握有效的思考方法。\n\n看一本书，如果不能迭代你的认知与知识的话，那就不能叫学习，只能称为娱乐。因为你只是在重复了解你原本就已经知道的知识。下面的几个部分是我看完《暗时间》后的被迭代的。\n## 暗时间是什么\n作者用了比较大的篇幅介绍了暗时间的意义。其中有一个比喻非常形象：\n> 如果你有一台计算机，你装了一个系统之后就整天把他搁置在那里，你觉得这台计算机被实际使用了吗？没有，因为CPU整天运行的就是空闲进程。运行空闲进程也是一天，运行大数据量计算的程序也是一天，对于CPU来说同样的一天，价值却是完全不一样。\n\n非常生动形象的比喻。了解过计算机的人一看这个比喻就立马明白了什么是暗时间的意义。作者接着又举了一个更普通的例子来说明：\n>如果你正在学习一门专业，你使用自己所投入的天数来衡量，很容易就产生一种错觉，认为投入了不少时间，然而其实，“投入时间”这个说法本身就是荒唐的，实际投入的是时间和效率的乘积。\n\n通过上面两个举例，相信你可以很明了暗时间有什么意义了。作者认为，所谓**暗时间就是你的思维时间**，你走路，买菜，洗脸洗手，坐公交，逛街、出游、吃饭、睡觉所有的这些时间都可以成为暗时间，你可以充分利用这些时间思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将产生庞大的效应。能够充分利用暗时间的人将无形中多出一大块生命。牛逼的人不仅在自己擅长的领域非常牛逼，连在“业务、兴趣“的领域也特别的牛逼。每每看到这样的人，总是会疑惑，他们怎么哪里来的这么多时间，居然可以在这么多个领域达到如此卓越的地步。或许其中一个原因就是牛逼的人特别善于利用暗时间。\n这是一个非常具有实用价值的概念。尤其是在移动互联网空前发达的今天，随处可见低头一族。吃饭时刷刷朋友圈，看看新闻；等车时刷刷微博；挤地铁时又掏出手机刷着各种公众号文章。大部分的暗时间已经被手机占领了，每天接触着大量的信息，却没有花时间消化，那么多信息你只是看过而已，如果没有进一步的回顾、整理以及内化，看过的文章其实没有在你脑子留下任何有价值的信息。信息过载等同于没有信息。\n现在的我已经逐渐在学习排除干扰因素，增加暗时间来思考了。\n* 关闭朋友圈，减少每天频繁刷朋友圈的次数\n* 每天早上等公交，等地铁的时间用来思考，千万别看手机\n* 地铁拥挤的时候无法看书，也将其纳入暗时间，用来思考。思考的内容包括但不限于：今天的工作计划、近期的阅读计划、待写的文章、人生思考等。\n* 其他暗时间还在慢慢纳入\n\n要想充分利用好暗时间，还需要一个非常重要的技能：**专注，不仅包括能快速进入专注的状态，还包括能够长期保持专注状态。这两个是高效学习最重要的习惯**。\n不得不承认，专注力已经作为一种稀缺资源了。生活中充满着各种分散你注意力的事物，qq消息，邮件提醒，微信消息提醒，朋友圈动态提醒等等太多了。稍微没有控制住，你的注意力就被分散，你就无法专注了。解决这个办法很简单：杜绝一切干扰因素，关闭手机提醒、邮件提醒、qq消息提醒、微信消息提醒，甚至在必要的时候可以断网。\n除了专注，还有一个高效的习惯：**抗干扰**。\n>只有超强的抗干扰能力，才能有效地利用起前面提到的各种暗时间。\n\n因为大多数的暗时间都是处于室外复杂，喧闹的环境，干扰的因素很多。还好抗干扰能力也是可以练习出来的。\n于我而言，现在每天上班的地铁时间，就是我高效看书的时间。一开始也是无法专心在那么嘈杂的环境下安心专注得看书，但经过近半年的训练，在地铁中，现在已经能非常快速得进入阅读状态了。事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法。另外作者还提到，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。\n\n## 设计自己的进度条\n设计进度条其实和流行的GTD方法学类似，其核心理念在于\n>如果你把任务分割了，你就有了进度条，你就知道，事情是在不断紧张，你总会完成任务或到达你的目标，你会有一个时间估计。反之，如果没有这个分割，整个的任务或目标对你而言就只有两种状态——“完成”和“未完成”\n\n有接触过GTD（Get Thing Done）的人都明白，GTD的方法论就是记录下你所有要做的事，然后再去安排、执行（这是最初级的阶段）。更深入一点的GTD则是：列下所有要做的事，**对每件事都进行拆分**。对于要做的这件事，你可以实际采取的下一步行动是什么。以此类推，每一步都去分析**下一步行动**。到最后的结果便是，一件事就会被拆分成多个下一步行动，每一个行动都是可以实际做到的。这样下来，Get Thing Done就是一件顺理成章的事。\n\n如果我们对于任务或者目标没有进行合理得设计进度条，那么在目标达到之前，你的状态就会一直都是“未完成”，一次又一次的未完成会耗尽你的耐心，让你下意识的产生“这事什么时候才能完成呢？“的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的，这样导致的后果就是你会心生怯意，不敢进一步投入时间，免得血本无归。在这要的心理下，不少人就会选择保守策略——退出。设计进度条就是基于人的这种心理弱点，如果你对整个目标的几个重大步骤都有清晰的界定，能够对每个步骤的耗时作出靠谱的上界估计，你就不会被不确定的未来，不确定的时间投入感到恐惧。就会心生退意。\n所以作者就提出了\n>不要过早退出循环\n\n因为即使是设计了进度条，在遇到困难时，大部分的人依然会想到退出、逃避。我们在尝试新事物的时候，会遇到各种各样的困难，不同的人会在碰壁不同的次数之后退出。\n>用程序员喜欢的话就是，我们都在for循环，区别在于你是什么情况下break；有的人退出阙值高，这是能坚持的一类人；有的人退出阙值低，一遇到困难就退出了。\n\n最喜欢这种用程序比喻了，高度贴切。就好比笑点有高有低，坚持阙值也有高有低，下次要放弃之前，先问问自己“难道你是容易放弃的人吗？”。\n>过早退出是一切失败的根源\n\n## 靠专业技能的成功最具有可复制性\n如果说世界上有一种成功可以复制，那也只有靠专业技能的成功可以称得上这种成功了。因为它只需要的只是你在一个领域坚持不懈地专注下去，只需要选择一个不算不太靠谱的方向，然后专心致志得专下去，最后必然能成为高手或者绝顶高手。世界上有很多成功带有偶然因素和运气成分或出身环境，但至少这一样，被无数人复制了无数遍，否则就不会存在学校和教育了。\n\n## 为什么你应该（从现在开始）写博客\n因为写博客有很多好处，却没有任何明显的坏处。\n* 能够交到很多志同道合的朋友\n* 写博客就是对你思考结果、学习结果的再次整理\n 自从开始开通博客之后，每次都会将学习过程记录成博客。每次在写博客的过程中，为了能让自己可以表达更清楚明了，又会趋使我去深入了解。\n* 教是最好的学；\n>为了让一个不明白的人做到明白，你必须要知道从明白到不明白他究竟需要掌握哪些概念，这就迫使我们对我们大脑中的整个知识体系来个寻根究底，把大脑中的那些我们知道，但不知道自己知道的潜在概念或假设都挖出来，把它们从内隐记忆拉扯到外显记忆中。因为只有完全知道，并知道自己知道一切来龙去脉的人，才能真正把一件事情讲得通通透透。\n* 激励你去持续学习和思考\n刚开始可能觉得没有什么内容可以写，这个时候，为了更新博客，我会去逼迫自己为了写而写。看完一本书，会逼迫自己写点读书笔记（就好比这篇文章）；学完一个知识后，我会逼迫自己将学习过程、总结记录下来。写的过程，又促使我进行了二次思考和学习。\n* 学会持之以恒的做一件事情\n如果有什么是我希望坚持做下去的话，那么写博客将会是我的第一选择。\n* 一个长期的价值博客是一份很好的简历。\n作为程序员，拥有自己的网站或者博客，你已经比大多数人进步了。如果能长期坚持写下去，那更是超越了全国90%的用户了（数字纯属杜撰）。一个好的博客就应该如同朋友圈，新朋友通过朋友圈可以大致了解你；博客则是一个让别人了解自己的窗口。（这里的简历指广义上的简历：别人了解自己的窗口）\n\n## 什么才是你不可替代性和核心竞争力\n物依稀为贵，这条最基本经济学铁律已是深入人心。人才在社会上的本质就是一种商品，而商品的稀缺性决定着商品的价值。稀缺性，换种说法就是不可替代性。不可替代性越强，价格就会越高。\n那么如何构筑自己的个人知识体系，提高自己的稀缺性呢？\n作者通过观察得出一个观点：\n>个人的核心竞争力是他独特的个性、知识、经验组合。如果这种组合\n1、绝无仅有\n2、在实践中有价值\n3、具有可持续发展性\n那你就具有核心竞争力。\n\n作者认为以下的知识技能组合是具有相当程度的不可替代性：\n>1、专业技能：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。\n2、跨领域的技能：解决问题的能力，创新思维，判断与决策能力，Critical-Thinking(批判性思维)，表达沟通能力，Open Mind等。\n3、学习能力：严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如果培养学习能力，就是持续学习和思考新知识\n4、性格要素：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑等等\n\n不管所处哪个行业，上面所说的四个技能都是适用的。作为程序员，专业技能这点是毋庸置疑的。但也千万别忘了培养后面三种技能。专业技能决定了你能走多远，而后面的技能却决定着你能飞多高。\n\n## 精彩摘录\n>1、兴趣遍地都是，专注和持之以恒才是真正稀缺的。\n2、人与人的差距不在资质上，而在花在思考的时间与思考的深度上\n3、靠专业技能的成功是最具有可复制性的\n4、大学期间，最不缺的就是业余时间，最缺的就是专注精神，非凡的注意力造就非凡的专家\n\n参考资料\n来源： http://baike.baidu.com/subview/3147362/11243902.htm#viewPageContent","slug":"essays/darktime-reading-note","published":1,"updated":"2016-04-30T15:10:49.397Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7m1001zrwtzcv80iaj9"},{"title":"《如何培养技术洞见力》-读后感","date":"2016-04-19T15:22:59.000Z","_content":"本篇文章是阅读文章《如何培养技术洞见力》之后的总结\n<!-- more -->\n# 前言\n前几天从开发者头条看到了《如何培养技术洞见力》这篇文章，文中提到了为什么同样是看了一篇文章，听完一场演讲或者是看完一本书，普通人只是会觉得“哇哦，好厉害，好有道理”。然而那些所谓的大神却能从这些信息中获取到最有用的信息，而不只是赞叹。为什么会产生这种区别呢？作者认为最本质的原因在于：他们能够基于信息做有效的深度思考，而这种深度思考能力最直接的体现就是“洞见力”。所谓“洞见力”就是指一个人对某件事物的认知程度和ta自己的“分析结论”，是个人主观的看法和评价。洞见力的不同决定了一个人的思想深度。事实证明，一个人如果没有自己具备独立的深度思考能力，就很难有自己的洞见甚至创造。\n___\n# 那么这种洞见力该如何培养呢？\n作者提出了几个观点：\n* 主动提出问题（又分为如何能主动提出问题和提出有深度的问题）\n* 系统思考\n* 深度阅读培养洞见\n\n以我现在的阅历，我能主动吸收的是“主动提出问题”这个建议。文中说到大部分精彩的演讲和文章都有一个共同点：“自问自答”。不管是演讲或者文章，它们都是在提出问题，并对其进行回答，表达自己的思想观点，这是一种典型的问题求解释式的思维模式。作者以《当谈论Feature Team时我们在谈论什么》这篇文章为例，通过思维导图的形式说明了整篇文章其实就是在回答Feature Team的各种问题。还有《学习的逻辑学》这篇文章也是如此。\n![](http://7xr6yj.com1.z0.glb.clouddn.com/aritcle-review-insight-1.png)\n![](http://7xr6yj.com1.z0.glb.clouddn.com/aritcle-review-insight-2.png)\n\n___\n所以大家发现了没有。自问自答是一种非常好的学习方式。根据**目标管理的SMART原则**，建立一个目标需要具体的、可度量的、可实现的、现实性、有时限这五个原则。通过**主动提出问题**这种学习方式正好解决了具体的，可度量这两个原则。因为主动提问不仅为你的学习订下了学习目标（我要把这些问题都搞明白，解决），而且还将你的学习过程分解为一个个具体的，可衡量的小问题。\n突然明白了以前上学时做阅读时的一个技巧，先看问题再去看文章，带着问题看文章。只可惜这般醒悟来得有点晚，但不迟，从现在开始行动还来得及。\n所以我要开始尝试用这种“主动提问”的方法去学习任何东西。对于任何学习目标，都可以尝试从以下三个类型去提出问题：\n \n* What类型\n* How类型\n* Why类型\n\n现学现卖，我通过这种主动提问的方法，来学习JavaScript的call和apply。下面是我提出的问题\n![](http://7xr6yj.com1.z0.glb.clouddn.com/aritcle-review-insight-3.png)\n\n\n有了这些问题，就可以增强学习的目标性，也可以在你学习完成后，衡量对这些知识的掌握程度。\n \n## 文章地址\n>《如何培养技术洞见力？》http://insights.thoughtworkers.org/insight/\n ","source":"_posts/essays/article-review-insight.md","raw":"---\ntitle: 《如何培养技术洞见力》-读后感\ndate: 2016-04-19 23:22:59\ntags:\n- 随笔\n- 读后感\n- 读书笔记\n---\n本篇文章是阅读文章《如何培养技术洞见力》之后的总结\n<!-- more -->\n# 前言\n前几天从开发者头条看到了《如何培养技术洞见力》这篇文章，文中提到了为什么同样是看了一篇文章，听完一场演讲或者是看完一本书，普通人只是会觉得“哇哦，好厉害，好有道理”。然而那些所谓的大神却能从这些信息中获取到最有用的信息，而不只是赞叹。为什么会产生这种区别呢？作者认为最本质的原因在于：他们能够基于信息做有效的深度思考，而这种深度思考能力最直接的体现就是“洞见力”。所谓“洞见力”就是指一个人对某件事物的认知程度和ta自己的“分析结论”，是个人主观的看法和评价。洞见力的不同决定了一个人的思想深度。事实证明，一个人如果没有自己具备独立的深度思考能力，就很难有自己的洞见甚至创造。\n___\n# 那么这种洞见力该如何培养呢？\n作者提出了几个观点：\n* 主动提出问题（又分为如何能主动提出问题和提出有深度的问题）\n* 系统思考\n* 深度阅读培养洞见\n\n以我现在的阅历，我能主动吸收的是“主动提出问题”这个建议。文中说到大部分精彩的演讲和文章都有一个共同点：“自问自答”。不管是演讲或者文章，它们都是在提出问题，并对其进行回答，表达自己的思想观点，这是一种典型的问题求解释式的思维模式。作者以《当谈论Feature Team时我们在谈论什么》这篇文章为例，通过思维导图的形式说明了整篇文章其实就是在回答Feature Team的各种问题。还有《学习的逻辑学》这篇文章也是如此。\n![](http://7xr6yj.com1.z0.glb.clouddn.com/aritcle-review-insight-1.png)\n![](http://7xr6yj.com1.z0.glb.clouddn.com/aritcle-review-insight-2.png)\n\n___\n所以大家发现了没有。自问自答是一种非常好的学习方式。根据**目标管理的SMART原则**，建立一个目标需要具体的、可度量的、可实现的、现实性、有时限这五个原则。通过**主动提出问题**这种学习方式正好解决了具体的，可度量这两个原则。因为主动提问不仅为你的学习订下了学习目标（我要把这些问题都搞明白，解决），而且还将你的学习过程分解为一个个具体的，可衡量的小问题。\n突然明白了以前上学时做阅读时的一个技巧，先看问题再去看文章，带着问题看文章。只可惜这般醒悟来得有点晚，但不迟，从现在开始行动还来得及。\n所以我要开始尝试用这种“主动提问”的方法去学习任何东西。对于任何学习目标，都可以尝试从以下三个类型去提出问题：\n \n* What类型\n* How类型\n* Why类型\n\n现学现卖，我通过这种主动提问的方法，来学习JavaScript的call和apply。下面是我提出的问题\n![](http://7xr6yj.com1.z0.glb.clouddn.com/aritcle-review-insight-3.png)\n\n\n有了这些问题，就可以增强学习的目标性，也可以在你学习完成后，衡量对这些知识的掌握程度。\n \n## 文章地址\n>《如何培养技术洞见力？》http://insights.thoughtworkers.org/insight/\n ","slug":"essays/article-review-insight","published":1,"updated":"2016-04-30T15:15:39.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7m60023rwtzukq4dyx6"},{"title":"基于AngularJS的markdown编辑器","date":"2016-04-14T16:08:41.000Z","_content":"基于AngularJS实现了一个在线markdown编辑器的功能\n<!-- more -->\n由于这段时间已经是变成了markdown重度使用者了，因此就想着自己折腾一个markdown编辑器，发布在github pages上面。这样就可以实现了一个在线markdown编辑器。\n# 技术栈\n* AngularJS：这个就不用过多介绍了；\n* marked.js（https://github.com/chjj/marked）： 将markdown代码编译成HTML的插件；\n* highlight.js：代码高亮插件\n# 实现的目标\n* 在线编辑markdown，实时生成预览\n* 实现语法高亮显示（未完成）\n* 实现黑色主题（未完成）\n* 实现下载markdown文件和HTML文件（未完成）\n* gulp构建网站发布到git-pages\n# 实现原理\n编译markdown代码，我选择`marked.js`， 当然你也可以选择其他插件，也是一样能将markdown代码编译成HTML。\n由于AngularJS双向绑定的机制，因此可以非常方便得实现了实时生成预览。话不多说，用代码来讲解整个过程。\n## 界面实现\n参照现有的在线markdown编辑器，大多数采用的都是左右分栏的布局，左边是编辑器，右边是预览区。因此我也采用了这样的布局模式。\n![](http://7xr6yj.com1.z0.glb.clouddn.com/angular-markdown-1.png)\n此外，还需要对右边预览区添加必要的CSS样式，比如`h1`~`h6`元素样式的定义、代码样式`pre`  `code`的定义等。\n```css\nh1, h2, h3, h4, h5, h6 {\n    font-family: 'Old Standard TT', serif;\n    font-weight: bold;\n    border-bottom: 1px solid #eee;\n}\n \nh3 {\n    border-bottom: 1px solid #ddd;\n}\npre {\n    white-space: pre-wrap; /* css-3 */\n    white-space: -moz-pre-wrap; /* Mozilla, since 1999 */\n    white-space: -pre-wrap; /* Opera 4-6 */\n    white-space: -o-pre-wrap; /* Opera 7 */\n    word-wrap: break-word; /* Internet Explorer 5.5+ */\n    background-color: #f8f8f8;\n    border: 1px solid #dfdfdf;\n    margin-top: 1.5em;\n    margin-bottom: 1.5em;\n    padding: 0.125rem 0.3125rem 0.0625rem;\n}\n \npre code {\n    background-color: transparent;\n    border: 0;\n    padding: 0;\n}\n```\n## markdown实时预览\n给左边的`textarea`绑定一个`ng-model`，这样就可以实时获取到输入的值，并且可以实时显示在右边的预览区。如下面代码：\n```html\n<div ng-controller=\"EditorController as vm\">\n    <h3 class=\"title\">基于angular的markdown编辑器</h3>\n    <div class=\"container\" >\n    <textarea id=\"editor\" ng-model=\"vm.editor\"></textarea>\n        <div id=\"preview\" >{{vm.editor}}</div>\n    </div>\n</div>\n```\n这样就可以实现左边的编辑器和右边的预览区实时同步了。那么接下来我们还需要做的就是将预览区的markdown代码编译成HTML代码。由于需要实时监听左边的输入框，因此我们可以在预览区的变量中添加一个过滤器：\n```html\n<div id=\"preview\" >{{vm.editor  | render}}</div>\n```\n在过滤器`render`中，我们调用`marked.js`将输入的markdown代码转换为html代码。`marked.js`的使用也非常简单，`marked.js`会启用下面的默认配置（所以不需要你再手动配置）\n```javascirpt\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: true,\n  smartLists: true,\n  smartypants: false\n});\ndocument.getElementById('content').innerHTML =\n      marked('# Marked in browser\\n\\nRendered by **marked**.');  //在浏览器中可以这么使用\n```\n因此我们就可以这么在过滤器中调用`marked.js`的方法，如下面\n```javascirpt\n    .filter('render', [ function () {\n            return function (input) {\n                if (input.length != 0) {\n                    input = marked(input);\n                }\n                return input;\n            }\n        }])\n```\n那么到这里是不是就可以将markdown代码编译成HTML代码了呢？当然不是的。会出现下面的这种情况，显示出HTML代码：\n![](http://7xr6yj.com1.z0.glb.clouddn.com/angular.gif)\n由于`marked`方法返回的是HTML代码，而在AngularJS中，出于安全考虑，会转义发现的任何HTML内容以阻止HTML注入攻击。因此如果要正常显示的话，需要对HTML进行处理。这样采用AngularJS自带的`$sce`服务：\n```javascript\n    .filter('render', ['$sce', function ($sce) {    //依赖注入$sce\n            return function (input) {\n                if (input.length != 0) {\n                    input = marked(input);\n                }\n                return $sce.trustAsHtml(input);    //返回值用trustAsHtml()处理\n            }\n        }])\n```\n同时，HTML中也需要更改：\n```html\n<div id=\"preview\" ng-bind-html=\"vm.editor | render\"></div>    //使用指令ng-bind-html来绑定变量\n```\n到这里，一个markdown编辑器就打造完成了。来看看效果吧！\n![](http://7xr6yj.com1.z0.glb.clouddn.com/angular-markdown.gif)\n也可以点击[在线演示](http://superman66.github.io/angular-markdown/app/#/editor)，查看效果。\n项目github地址：https://github.com/superman66/angular-markdown\n# 总结：\n实现起来比较简单，主要是利用了` marked.js`插件。\n## 待优化\n* 还需要添加代码高亮的优化\n* 支持以`md`格式和`html`格保存文件到本地\n\n","source":"_posts/angular/angular-markdown.md","raw":"---\ntitle: 基于AngularJS的markdown编辑器\ndate: 2016-04-15 00:08:41\ntags:\n- AngularJS\n- markdown\n---\n基于AngularJS实现了一个在线markdown编辑器的功能\n<!-- more -->\n由于这段时间已经是变成了markdown重度使用者了，因此就想着自己折腾一个markdown编辑器，发布在github pages上面。这样就可以实现了一个在线markdown编辑器。\n# 技术栈\n* AngularJS：这个就不用过多介绍了；\n* marked.js（https://github.com/chjj/marked）： 将markdown代码编译成HTML的插件；\n* highlight.js：代码高亮插件\n# 实现的目标\n* 在线编辑markdown，实时生成预览\n* 实现语法高亮显示（未完成）\n* 实现黑色主题（未完成）\n* 实现下载markdown文件和HTML文件（未完成）\n* gulp构建网站发布到git-pages\n# 实现原理\n编译markdown代码，我选择`marked.js`， 当然你也可以选择其他插件，也是一样能将markdown代码编译成HTML。\n由于AngularJS双向绑定的机制，因此可以非常方便得实现了实时生成预览。话不多说，用代码来讲解整个过程。\n## 界面实现\n参照现有的在线markdown编辑器，大多数采用的都是左右分栏的布局，左边是编辑器，右边是预览区。因此我也采用了这样的布局模式。\n![](http://7xr6yj.com1.z0.glb.clouddn.com/angular-markdown-1.png)\n此外，还需要对右边预览区添加必要的CSS样式，比如`h1`~`h6`元素样式的定义、代码样式`pre`  `code`的定义等。\n```css\nh1, h2, h3, h4, h5, h6 {\n    font-family: 'Old Standard TT', serif;\n    font-weight: bold;\n    border-bottom: 1px solid #eee;\n}\n \nh3 {\n    border-bottom: 1px solid #ddd;\n}\npre {\n    white-space: pre-wrap; /* css-3 */\n    white-space: -moz-pre-wrap; /* Mozilla, since 1999 */\n    white-space: -pre-wrap; /* Opera 4-6 */\n    white-space: -o-pre-wrap; /* Opera 7 */\n    word-wrap: break-word; /* Internet Explorer 5.5+ */\n    background-color: #f8f8f8;\n    border: 1px solid #dfdfdf;\n    margin-top: 1.5em;\n    margin-bottom: 1.5em;\n    padding: 0.125rem 0.3125rem 0.0625rem;\n}\n \npre code {\n    background-color: transparent;\n    border: 0;\n    padding: 0;\n}\n```\n## markdown实时预览\n给左边的`textarea`绑定一个`ng-model`，这样就可以实时获取到输入的值，并且可以实时显示在右边的预览区。如下面代码：\n```html\n<div ng-controller=\"EditorController as vm\">\n    <h3 class=\"title\">基于angular的markdown编辑器</h3>\n    <div class=\"container\" >\n    <textarea id=\"editor\" ng-model=\"vm.editor\"></textarea>\n        <div id=\"preview\" >{{vm.editor}}</div>\n    </div>\n</div>\n```\n这样就可以实现左边的编辑器和右边的预览区实时同步了。那么接下来我们还需要做的就是将预览区的markdown代码编译成HTML代码。由于需要实时监听左边的输入框，因此我们可以在预览区的变量中添加一个过滤器：\n```html\n<div id=\"preview\" >{{vm.editor  | render}}</div>\n```\n在过滤器`render`中，我们调用`marked.js`将输入的markdown代码转换为html代码。`marked.js`的使用也非常简单，`marked.js`会启用下面的默认配置（所以不需要你再手动配置）\n```javascirpt\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: true,\n  smartLists: true,\n  smartypants: false\n});\ndocument.getElementById('content').innerHTML =\n      marked('# Marked in browser\\n\\nRendered by **marked**.');  //在浏览器中可以这么使用\n```\n因此我们就可以这么在过滤器中调用`marked.js`的方法，如下面\n```javascirpt\n    .filter('render', [ function () {\n            return function (input) {\n                if (input.length != 0) {\n                    input = marked(input);\n                }\n                return input;\n            }\n        }])\n```\n那么到这里是不是就可以将markdown代码编译成HTML代码了呢？当然不是的。会出现下面的这种情况，显示出HTML代码：\n![](http://7xr6yj.com1.z0.glb.clouddn.com/angular.gif)\n由于`marked`方法返回的是HTML代码，而在AngularJS中，出于安全考虑，会转义发现的任何HTML内容以阻止HTML注入攻击。因此如果要正常显示的话，需要对HTML进行处理。这样采用AngularJS自带的`$sce`服务：\n```javascript\n    .filter('render', ['$sce', function ($sce) {    //依赖注入$sce\n            return function (input) {\n                if (input.length != 0) {\n                    input = marked(input);\n                }\n                return $sce.trustAsHtml(input);    //返回值用trustAsHtml()处理\n            }\n        }])\n```\n同时，HTML中也需要更改：\n```html\n<div id=\"preview\" ng-bind-html=\"vm.editor | render\"></div>    //使用指令ng-bind-html来绑定变量\n```\n到这里，一个markdown编辑器就打造完成了。来看看效果吧！\n![](http://7xr6yj.com1.z0.glb.clouddn.com/angular-markdown.gif)\n也可以点击[在线演示](http://superman66.github.io/angular-markdown/app/#/editor)，查看效果。\n项目github地址：https://github.com/superman66/angular-markdown\n# 总结：\n实现起来比较简单，主要是利用了` marked.js`插件。\n## 待优化\n* 还需要添加代码高亮的优化\n* 支持以`md`格式和`html`格保存文件到本地\n\n","slug":"angular/angular-markdown","published":1,"updated":"2016-04-14T16:25:35.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7mg0028rwtzrpyrrtxq"},{"title":"基于localStorage和AngularJS的markdown简易笔记本","date":"2016-05-04T14:36:21.000Z","_content":"这是基于AngularJS实现的简易markdown笔记本。具有添加、删除分类，添加、删除笔记本，添加标签，全屏显示等功能。后续将完善更多功能。\n<!-- more -->\n在之前markdown编辑器的基础上，再演化成一个基于localStorage的markdown简易笔记本。\n上一篇基于AngularJS打造的markdown笔记本[点击这里查看](http://superman66.github.io/2016/04/15/angular/angular-markdown/)\n先来看效果图：\n![angular](/images/angular-markdown-note.gif)\n# 已完成功能列表\n* 添加和删除分类\n* 添加和删除笔记本\n* 笔记本编辑与保存\n* 支持全屏编辑\n* 笔记本可以添加多个标签、删除标签\n# 功能待完善列表\n* 支持分类和笔记本的右键菜单（菜单包括：重命名、删除、添加）\n* 支持多级分类\n*  支持移动端布局\n\n# 知识点记录\n## CSS布局\n##### 1、左边两列固定宽度，右边一列宽度自适应。如下图所示\n![angular](/images/angluar-markdown-note-1.png)\n代码如下：\n```html    \n    <style>\n        *{\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t\tbox-sizing: border-box;\n\t}\n\t.sub{\n\t\tfloat: left;\n\t\twidth: 200px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\n\t\theight: 200px;\n\t}\n\t.extra{\n\t\tfloat: left;\n\t\twidth: 300px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\t\n\t\theight: 200px;\n\t}\n\t.main{\n\t\twidth: 100%;\n\t\theight: 200px;\n\t\tpadding-left: 500px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\t\n\t}\n    </style>\n\n\t\t<div class=\"sub\">sub</div>\n\t\t<div class=\"extra\">extra</div>\n\t\t<div class=\"main\">main</div>\n```\n左边两列通过float属性使其固定在左边。最右边一列设置padding值为左边两列的宽度和，同时设置宽度为100%。这样就可以实现了左边两列固定宽度，右边一列宽度自适应。\n##### 2、左右两列固定，中间一列自适应，如下图所示\n![angular](/images/angluar-markdown-note-2.png)\n代码如下：\n```html    \n    <style>\n\t*{\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t\tbox-sizing: border-box;\n\t}\n\t.sub{\n\t\tfloat: left;\n\t\twidth: 200px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\n\t\theight: 200px;\n\t}\n\t.extra{\n\t\tfloat: right;\n\t\twidth: 300px;\n\t\tbackground: #444;\n\t\tborder: 1px solid #ddd;\t\n\t\theight: 200px;\n\t}\n\t.main{\n\t\twidth: 100%;\n\t\theight: 200px;\n\t\tbackground: #888;\n\t\tborder: 1px solid #ddd;\t\n\t}\n    </style>\n\n\t\t<div class=\"sub\">sub</div>\n\t\t<div class=\"extra\">extra</div>\n\t\t<div class=\"main\">main</div>\n```\n第二种布局html部分并没有改变，只对CSS进行了改变。去掉`.main`的padding-left属性值，`.extra`的float属性值由left改为right。\n##### 3、左边一列自适应，右边两列固定宽度。如下图所示\n![angular](/images/angluar-markdown-note-3.png)\n代码如下：\n```html    \n    <style>\n        *{\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t\tbox-sizing: border-box;\n\t}\n\t.sub{\n\t\tfloat: right;\n\t\twidth: 200px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\n\t\theight: 200px;\n\t}\n\t.extra{\n\t\tfloat: right;\n\t\twidth: 300px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\t\n\t\theight: 200px;\n\t}\n\t.main{\n\t\twidth: 100%;\n\t\theight: 200px;\n\t\tpadding-right: 500px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\t\n\t}\n    </style>\n\n\t\t<div class=\"sub\">sub</div>\n\t\t<div class=\"extra\">extra</div>\n\t\t<div class=\"main\">main</div>\n```\n这种布局与第一种布局类似，HTML结构依然保持不变，只不过是`.sub`和`,extra`的float属性改为right，`.main`的padding值改为`padding-right:500px`\n## 基于localStorage存储数据\n由于没有接入数据库，因此采用的是localStorage本地存储。localStorage是基于key-value的JSON格式进行存储，类似于NoSql数据库。为了模拟后台的增删改查API，写了一个data-Service来封装增删改查的方法。\n在写Service的过程中，思维一直受到之前关系型数据库的影响，总是想采用关系型数据库那套增删改查的方法来实现。对比一下，有几个差异点：\n* 自增长id\n    之前在使用MySQL数据库的时候，每条记录会有一个自增长id的，而且这个自增长id是不可逆的，删除了这条记录后，这个id也不会被回收。后续再添加的记录的id是在之前id的基础上递增的。而在localStorage中，则没有自增长id的机制。因此必须模拟实现自增长id。实现机制：每次要添加数据的时候，先去遍历该列表，获取该列表的长度length。如果length不等于的话，则id=length+1。如果length=0，id=1；\n* 读取数据\n    基于JSON的存储，在存储列表数据时一般采用数组，而数组里面再包含一个个对象来存储数据。如果需要根据id来获取相对应对象所在的值，就需要通过先通过查找该id在整个数组中的索引值，再通过这个索引值去得到该对象。\n```javascript\n  {\n    \"id\": 4,    //标识该条记录的唯一id\n    \"name\": \"4\",\n    \"noteList\": [\n      {\n        \"id\": 1,\n        \"title\": \"4-1\",\n        \"createTime\": \"2016-04-26 22:52:59\",\n        \"updateTime\": \"2016-04-26 22:52:59\"\n      },\n      {\n        \"id\": 2,\n        \"title\": \"4-2\",\n        \"createTime\": \"2016-04-26 22:54:09\",\n        \"updateTime\": \"2016-04-26 22:54:09\"\n      }\n    ]\n  }\n```\n* 删除数据\n    删除数据则是采用了数组的方法splice。因为使用splice()删除数据，数组会根据需要减小它们的索引值，并自动减少数组的长度，可以避免产生稀疏数组。\n    \n## ECMAScript5的数组方法\n在操作localStorage数据的过程中，使用到了ECMAScript5的一些方法，比如forEach()，filter()等。之前也是没有接触过。具体关于JavaScript数组将会在另外一篇文章中详细说明。\n* forEach()\n* map()\n* filter()\n* every()和some()\n* reduce()和reduceRight()\n* indexOf()和lastIndexOf()\n\n项目地址：http://superman66.github.io/angular-markdown/app/index.html#/index\n","source":"_posts/angular/angular-markdown-note.md","raw":"---\ntitle: 基于localStorage和AngularJS的markdown简易笔记本\ndate: 2016-05-04 22:36:21\ntags:\n- AngularJS\n- markdown\n---\n这是基于AngularJS实现的简易markdown笔记本。具有添加、删除分类，添加、删除笔记本，添加标签，全屏显示等功能。后续将完善更多功能。\n<!-- more -->\n在之前markdown编辑器的基础上，再演化成一个基于localStorage的markdown简易笔记本。\n上一篇基于AngularJS打造的markdown笔记本[点击这里查看](http://superman66.github.io/2016/04/15/angular/angular-markdown/)\n先来看效果图：\n![angular](/images/angular-markdown-note.gif)\n# 已完成功能列表\n* 添加和删除分类\n* 添加和删除笔记本\n* 笔记本编辑与保存\n* 支持全屏编辑\n* 笔记本可以添加多个标签、删除标签\n# 功能待完善列表\n* 支持分类和笔记本的右键菜单（菜单包括：重命名、删除、添加）\n* 支持多级分类\n*  支持移动端布局\n\n# 知识点记录\n## CSS布局\n##### 1、左边两列固定宽度，右边一列宽度自适应。如下图所示\n![angular](/images/angluar-markdown-note-1.png)\n代码如下：\n```html    \n    <style>\n        *{\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t\tbox-sizing: border-box;\n\t}\n\t.sub{\n\t\tfloat: left;\n\t\twidth: 200px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\n\t\theight: 200px;\n\t}\n\t.extra{\n\t\tfloat: left;\n\t\twidth: 300px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\t\n\t\theight: 200px;\n\t}\n\t.main{\n\t\twidth: 100%;\n\t\theight: 200px;\n\t\tpadding-left: 500px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\t\n\t}\n    </style>\n\n\t\t<div class=\"sub\">sub</div>\n\t\t<div class=\"extra\">extra</div>\n\t\t<div class=\"main\">main</div>\n```\n左边两列通过float属性使其固定在左边。最右边一列设置padding值为左边两列的宽度和，同时设置宽度为100%。这样就可以实现了左边两列固定宽度，右边一列宽度自适应。\n##### 2、左右两列固定，中间一列自适应，如下图所示\n![angular](/images/angluar-markdown-note-2.png)\n代码如下：\n```html    \n    <style>\n\t*{\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t\tbox-sizing: border-box;\n\t}\n\t.sub{\n\t\tfloat: left;\n\t\twidth: 200px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\n\t\theight: 200px;\n\t}\n\t.extra{\n\t\tfloat: right;\n\t\twidth: 300px;\n\t\tbackground: #444;\n\t\tborder: 1px solid #ddd;\t\n\t\theight: 200px;\n\t}\n\t.main{\n\t\twidth: 100%;\n\t\theight: 200px;\n\t\tbackground: #888;\n\t\tborder: 1px solid #ddd;\t\n\t}\n    </style>\n\n\t\t<div class=\"sub\">sub</div>\n\t\t<div class=\"extra\">extra</div>\n\t\t<div class=\"main\">main</div>\n```\n第二种布局html部分并没有改变，只对CSS进行了改变。去掉`.main`的padding-left属性值，`.extra`的float属性值由left改为right。\n##### 3、左边一列自适应，右边两列固定宽度。如下图所示\n![angular](/images/angluar-markdown-note-3.png)\n代码如下：\n```html    \n    <style>\n        *{\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t\tbox-sizing: border-box;\n\t}\n\t.sub{\n\t\tfloat: right;\n\t\twidth: 200px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\n\t\theight: 200px;\n\t}\n\t.extra{\n\t\tfloat: right;\n\t\twidth: 300px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\t\n\t\theight: 200px;\n\t}\n\t.main{\n\t\twidth: 100%;\n\t\theight: 200px;\n\t\tpadding-right: 500px;\n\t\tbackground: #eee;\n\t\tborder: 1px solid #ddd;\t\n\t}\n    </style>\n\n\t\t<div class=\"sub\">sub</div>\n\t\t<div class=\"extra\">extra</div>\n\t\t<div class=\"main\">main</div>\n```\n这种布局与第一种布局类似，HTML结构依然保持不变，只不过是`.sub`和`,extra`的float属性改为right，`.main`的padding值改为`padding-right:500px`\n## 基于localStorage存储数据\n由于没有接入数据库，因此采用的是localStorage本地存储。localStorage是基于key-value的JSON格式进行存储，类似于NoSql数据库。为了模拟后台的增删改查API，写了一个data-Service来封装增删改查的方法。\n在写Service的过程中，思维一直受到之前关系型数据库的影响，总是想采用关系型数据库那套增删改查的方法来实现。对比一下，有几个差异点：\n* 自增长id\n    之前在使用MySQL数据库的时候，每条记录会有一个自增长id的，而且这个自增长id是不可逆的，删除了这条记录后，这个id也不会被回收。后续再添加的记录的id是在之前id的基础上递增的。而在localStorage中，则没有自增长id的机制。因此必须模拟实现自增长id。实现机制：每次要添加数据的时候，先去遍历该列表，获取该列表的长度length。如果length不等于的话，则id=length+1。如果length=0，id=1；\n* 读取数据\n    基于JSON的存储，在存储列表数据时一般采用数组，而数组里面再包含一个个对象来存储数据。如果需要根据id来获取相对应对象所在的值，就需要通过先通过查找该id在整个数组中的索引值，再通过这个索引值去得到该对象。\n```javascript\n  {\n    \"id\": 4,    //标识该条记录的唯一id\n    \"name\": \"4\",\n    \"noteList\": [\n      {\n        \"id\": 1,\n        \"title\": \"4-1\",\n        \"createTime\": \"2016-04-26 22:52:59\",\n        \"updateTime\": \"2016-04-26 22:52:59\"\n      },\n      {\n        \"id\": 2,\n        \"title\": \"4-2\",\n        \"createTime\": \"2016-04-26 22:54:09\",\n        \"updateTime\": \"2016-04-26 22:54:09\"\n      }\n    ]\n  }\n```\n* 删除数据\n    删除数据则是采用了数组的方法splice。因为使用splice()删除数据，数组会根据需要减小它们的索引值，并自动减少数组的长度，可以避免产生稀疏数组。\n    \n## ECMAScript5的数组方法\n在操作localStorage数据的过程中，使用到了ECMAScript5的一些方法，比如forEach()，filter()等。之前也是没有接触过。具体关于JavaScript数组将会在另外一篇文章中详细说明。\n* forEach()\n* map()\n* filter()\n* every()和some()\n* reduce()和reduceRight()\n* indexOf()和lastIndexOf()\n\n项目地址：http://superman66.github.io/angular-markdown/app/index.html#/index\n","slug":"angular/angular-markdown-note","published":1,"updated":"2016-05-04T14:50:45.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7mn002crwtz3ogns999"},{"title":"AngularJS动态加载模块和依赖","date":"2016-02-24T14:23:54.000Z","_content":"由于AngularJS是单页面应用框架，在正常的情况下，会在访问页面的时候将所有的CSS、JavaScript文件都加载进来。文件不多的时候，页面启动速度倒不会影响太多。但是一旦文件数太多或者加载的第三方库比较大的时候，就会影响页面启动速度。因此对于应用规模大、文件数比较多或者加载的第三方库比较大的时候，采用动态加载JS或者动态加载模块会极大提升页面的启动速度。本文将介绍如何利用ocLazyLoad实现动态加载。\n<!-- more -->\nAngularJS动态加载依赖第三方库：[ocLazyLoad](https://oclazyload.readme.io/docs)。ocLazyLoad是一个第三方库，支持AngularJS动态加载`module`、`service`、`directive`以及静态文件。\n### 安装ocLazyLoad\n可通过npm或者bower进行安装\n```bash\nnpm install oclazyload\nbower install oclazyload\n```\n### 将`ocLazyLoad` module 添加到你的应用中\n```javascript\nangular.module('myApp',['oc.lazyLoad']);\n```\n### 配置 `ocLazyLoad`\n你可以在 `config`函数中配置 `$ocLazyLoadProvider`,配置文件如下\n```bash\n.config(['$ocLazyLoadProvider', function($ocLazyLoadProvider){\n    $ocLazyLoadProvider.config({\n        debug: true,\n        events: true,\n        modules: [\n            {\n                name: 'TestModule',\n                files: ['test.js']\n            }\n        ]\n    })\n}])\n```\n* debug: 用来开启debug模式。布尔值，默认是false。当开启debug模式时，$ocLazyLoad会打印出所有的错误到console控制台上。\n* events：当你动态加载了module的时候，$ocLazyLoad会广播相应的事件。布尔值，默认为false。\n* modules：用于定义你需要动态加载的模块。定义每个模块的名字需要唯一。\nmodules必须要用**数组**的形式，其中files也必须以**数组**的形式存在，哪怕只需要加载一个文件\n\n### 在路由当中加载module\n```bash\n    .config(['$routeProvider', function($routeProvider) {\n        $routeProvider.otherwise('/index');\n        $routeProvider.when('/index', {\n            templateUrl: 'index.html',\n            controller: 'IndexController',\n            resolve: { //  resolve 里的属性如果返回的是 promise对象，那么resolve将会在view加载之前执行\n                loadMyCtrl: ['$ocLazyLoad', function($ocLazyLoad) {\n                    // 在这里可以延迟加载任何文件或者刚才预定义的modules\n                    return $ocLazyLoad.load('TestModule'); //加载刚才定义的TestModule\n                    /*return $ocLazyLoad.load([   // 如果要加载多个module，需要写成数组的形式\n                        'TestModule',\n                        'MainModule'\n                        ]);*/\n                }]\n            }\n        })\n    }])\n```\nresolve设置的属性可以被注入到Controller当中。如果resolve返回的是promise对象的话，那么它们将在控制器加载以及$routeChangeSuccess被触发之前执行。\n**$ocLazyLoad就是利用这个原理hack，进行动态加载**。\n`resolve`的值可以是：\n* key，the value of key 是会被注入到Controller的依赖的名字；\n* factory，即可以是一个service的名字，也可以是一个返回值，它是会被注入到控制器中的函\n数或可以被resolve的promise对象。\n\n通过这样的配置，就可以实现了AngularJS动态加载模块和依赖。但是$ocLazyLoad提供的功能更加丰富，不止动态加载模块和依赖，还能动态加载service，diretive等。更多的功能，可以访问[$ocLazyLoad官网](https://oclazyload.readme.io)\n","source":"_posts/angular/angular-lazyload.md","raw":"---\ntitle: AngularJS动态加载模块和依赖\ndate: 2016-02-24 22:23:54\ntags: \n- AngularJS\n- 动态加载\n---\n由于AngularJS是单页面应用框架，在正常的情况下，会在访问页面的时候将所有的CSS、JavaScript文件都加载进来。文件不多的时候，页面启动速度倒不会影响太多。但是一旦文件数太多或者加载的第三方库比较大的时候，就会影响页面启动速度。因此对于应用规模大、文件数比较多或者加载的第三方库比较大的时候，采用动态加载JS或者动态加载模块会极大提升页面的启动速度。本文将介绍如何利用ocLazyLoad实现动态加载。\n<!-- more -->\nAngularJS动态加载依赖第三方库：[ocLazyLoad](https://oclazyload.readme.io/docs)。ocLazyLoad是一个第三方库，支持AngularJS动态加载`module`、`service`、`directive`以及静态文件。\n### 安装ocLazyLoad\n可通过npm或者bower进行安装\n```bash\nnpm install oclazyload\nbower install oclazyload\n```\n### 将`ocLazyLoad` module 添加到你的应用中\n```javascript\nangular.module('myApp',['oc.lazyLoad']);\n```\n### 配置 `ocLazyLoad`\n你可以在 `config`函数中配置 `$ocLazyLoadProvider`,配置文件如下\n```bash\n.config(['$ocLazyLoadProvider', function($ocLazyLoadProvider){\n    $ocLazyLoadProvider.config({\n        debug: true,\n        events: true,\n        modules: [\n            {\n                name: 'TestModule',\n                files: ['test.js']\n            }\n        ]\n    })\n}])\n```\n* debug: 用来开启debug模式。布尔值，默认是false。当开启debug模式时，$ocLazyLoad会打印出所有的错误到console控制台上。\n* events：当你动态加载了module的时候，$ocLazyLoad会广播相应的事件。布尔值，默认为false。\n* modules：用于定义你需要动态加载的模块。定义每个模块的名字需要唯一。\nmodules必须要用**数组**的形式，其中files也必须以**数组**的形式存在，哪怕只需要加载一个文件\n\n### 在路由当中加载module\n```bash\n    .config(['$routeProvider', function($routeProvider) {\n        $routeProvider.otherwise('/index');\n        $routeProvider.when('/index', {\n            templateUrl: 'index.html',\n            controller: 'IndexController',\n            resolve: { //  resolve 里的属性如果返回的是 promise对象，那么resolve将会在view加载之前执行\n                loadMyCtrl: ['$ocLazyLoad', function($ocLazyLoad) {\n                    // 在这里可以延迟加载任何文件或者刚才预定义的modules\n                    return $ocLazyLoad.load('TestModule'); //加载刚才定义的TestModule\n                    /*return $ocLazyLoad.load([   // 如果要加载多个module，需要写成数组的形式\n                        'TestModule',\n                        'MainModule'\n                        ]);*/\n                }]\n            }\n        })\n    }])\n```\nresolve设置的属性可以被注入到Controller当中。如果resolve返回的是promise对象的话，那么它们将在控制器加载以及$routeChangeSuccess被触发之前执行。\n**$ocLazyLoad就是利用这个原理hack，进行动态加载**。\n`resolve`的值可以是：\n* key，the value of key 是会被注入到Controller的依赖的名字；\n* factory，即可以是一个service的名字，也可以是一个返回值，它是会被注入到控制器中的函\n数或可以被resolve的promise对象。\n\n通过这样的配置，就可以实现了AngularJS动态加载模块和依赖。但是$ocLazyLoad提供的功能更加丰富，不止动态加载模块和依赖，还能动态加载service，diretive等。更多的功能，可以访问[$ocLazyLoad官网](https://oclazyload.readme.io)\n","slug":"angular/angular-lazyload","published":1,"updated":"2016-02-24T14:47:59.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinszs7mv002frwtzna92sr7u"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cinszs7ja0000rwtzn99pzyyo","tag_id":"cinszs7jh0001rwtzlh6ehf2j","_id":"cinszs7jj0002rwtztdy1ac39"},{"post_id":"cinszs7jr0004rwtzq4bq0lv5","tag_id":"cinszs7jt0005rwtz7as7qub7","_id":"cinszs7ju0007rwtz9tn1s775"},{"post_id":"cinszs7jr0004rwtzq4bq0lv5","tag_id":"cinszs7ju0006rwtzblsvkvw9","_id":"cinszs7ju0008rwtzff4uzukn"},{"post_id":"cinszs7jw0009rwtzgle0z6ax","tag_id":"cinszs7jx000arwtzwhsoh8el","_id":"cinszs7jy000brwtz6pmfhy69"},{"post_id":"cinszs7jw0009rwtzgle0z6ax","tag_id":"cinszs7jt0005rwtz7as7qub7","_id":"cinszs7jy000crwtzgram3lk2"},{"post_id":"cinszs7jz000drwtzeuyp6tmb","tag_id":"cinszs7jt0005rwtz7as7qub7","_id":"cinszs7k1000erwtz1xt97m45"},{"post_id":"cinszs7k2000frwtzeatq5h6s","tag_id":"cinszs7k3000grwtzagmccm1h","_id":"cinszs7k4000irwtzz99cytib"},{"post_id":"cinszs7k2000frwtzeatq5h6s","tag_id":"cinszs7k4000hrwtzgtspq21g","_id":"cinszs7k5000jrwtz1mlffndx"},{"post_id":"cinszs7k7000krwtzshexphby","tag_id":"cinszs7k3000grwtzagmccm1h","_id":"cinszs7k9000lrwtz0sjn6qg6"},{"post_id":"cinszs7k7000krwtzshexphby","tag_id":"cinszs7k4000hrwtzgtspq21g","_id":"cinszs7k9000mrwtzxeg5h794"},{"post_id":"cinszs7kc000nrwtz8iosmob8","tag_id":"cinszs7kd000orwtzkrwz24o0","_id":"cinszs7kf000rrwtzvtmkwe6z"},{"post_id":"cinszs7kc000nrwtz8iosmob8","tag_id":"cinszs7ke000prwtziapeuqsh","_id":"cinszs7kf000srwtz3uhtvujn"},{"post_id":"cinszs7kc000nrwtz8iosmob8","tag_id":"cinszs7ke000qrwtztvzzkih3","_id":"cinszs7kg000trwtzpazfqh7u"},{"post_id":"cinszs7kh000urwtzbzubwqzx","tag_id":"cinszs7kd000orwtzkrwz24o0","_id":"cinszs7kk000wrwtzj0mehb9y"},{"post_id":"cinszs7kh000urwtzbzubwqzx","tag_id":"cinszs7ke000prwtziapeuqsh","_id":"cinszs7kk000xrwtzz3xpw6w6"},{"post_id":"cinszs7kh000urwtzbzubwqzx","tag_id":"cinszs7kj000vrwtz8aphvkje","_id":"cinszs7kk000yrwtzm3zvxso4"},{"post_id":"cinszs7kn000zrwtzej7r01u0","tag_id":"cinszs7k4000hrwtzgtspq21g","_id":"cinszs7kp0010rwtzf6l8xi1s"},{"post_id":"cinszs7kr0011rwtzm32uakbw","tag_id":"cinszs7k4000hrwtzgtspq21g","_id":"cinszs7kt0012rwtz75zmyv7d"},{"post_id":"cinszs7kv0013rwtzhnph571h","tag_id":"cinszs7k3000grwtzagmccm1h","_id":"cinszs7kw0014rwtz6jkk7yjx"},{"post_id":"cinszs7ky0015rwtzhajszill","tag_id":"cinszs7kz0016rwtz130dssyf","_id":"cinszs7l00017rwtzzlvxscct"},{"post_id":"cinszs7l10018rwtzfi4itbn2","tag_id":"cinszs7l40019rwtz30qpt7xq","_id":"cinszs7l5001arwtzji771h7e"},{"post_id":"cinszs7l6001brwtz7lhol8mw","tag_id":"cinszs7l40019rwtz30qpt7xq","_id":"cinszs7l8001crwtzowva7z8q"},{"post_id":"cinszs7la001drwtz8zr1zfvc","tag_id":"cinszs7l40019rwtz30qpt7xq","_id":"cinszs7lc001erwtz00uw3moq"},{"post_id":"cinszs7ld001frwtzysl5vfho","tag_id":"cinszs7l40019rwtz30qpt7xq","_id":"cinszs7lf001grwtzkqpocdt8"},{"post_id":"cinszs7lh001hrwtz3iophjty","tag_id":"cinszs7li001irwtzzcpw1pkm","_id":"cinszs7lj001krwtzoka66ue5"},{"post_id":"cinszs7lh001hrwtz3iophjty","tag_id":"cinszs7li001jrwtzpf7zdoi6","_id":"cinszs7lk001lrwtzuvdzki8q"},{"post_id":"cinszs7lm001mrwtzl8qg5zhk","tag_id":"cinszs7lo001nrwtztqef8wza","_id":"cinszs7lp001orwtzmuahny1l"},{"post_id":"cinszs7lq001prwtzr616ld00","tag_id":"cinszs7ls001qrwtzd7ruwiio","_id":"cinszs7lt001rrwtz7qq8qdus"},{"post_id":"cinszs7lq001prwtzr616ld00","tag_id":"cinszs7lo001nrwtztqef8wza","_id":"cinszs7lt001srwtzfgcm1epv"},{"post_id":"cinszs7lu001trwtzik0ifeup","tag_id":"cinszs7lo001nrwtztqef8wza","_id":"cinszs7lw001urwtz2jclvmgd"},{"post_id":"cinszs7lx001vrwtz64xvu53d","tag_id":"cinszs7lo001nrwtztqef8wza","_id":"cinszs7lz001xrwtz74mqelz8"},{"post_id":"cinszs7lx001vrwtz64xvu53d","tag_id":"cinszs7lz001wrwtznrcrtkcd","_id":"cinszs7lz001yrwtzbar4p34z"},{"post_id":"cinszs7m1001zrwtzcv80iaj9","tag_id":"cinszs7lo001nrwtztqef8wza","_id":"cinszs7m40021rwtzcrto376y"},{"post_id":"cinszs7m1001zrwtzcv80iaj9","tag_id":"cinszs7m30020rwtzgk6wc3ei","_id":"cinszs7m40022rwtznbytkpe4"},{"post_id":"cinszs7m60023rwtzukq4dyx6","tag_id":"cinszs7lo001nrwtztqef8wza","_id":"cinszs7mb0025rwtzdad113wc"},{"post_id":"cinszs7m60023rwtzukq4dyx6","tag_id":"cinszs7m90024rwtzphbwwst1","_id":"cinszs7md0026rwtz0dk2gnxy"},{"post_id":"cinszs7m60023rwtzukq4dyx6","tag_id":"cinszs7m30020rwtzgk6wc3ei","_id":"cinszs7me0027rwtz71yh5zxb"},{"post_id":"cinszs7mg0028rwtzrpyrrtxq","tag_id":"cinszs7jh0001rwtzlh6ehf2j","_id":"cinszs7mi002arwtzih7kglrz"},{"post_id":"cinszs7mg0028rwtzrpyrrtxq","tag_id":"cinszs7mh0029rwtzyn5fefut","_id":"cinszs7mi002brwtzch9m7m0t"},{"post_id":"cinszs7mn002crwtz3ogns999","tag_id":"cinszs7jh0001rwtzlh6ehf2j","_id":"cinszs7mq002drwtzzri0wz86"},{"post_id":"cinszs7mn002crwtz3ogns999","tag_id":"cinszs7mh0029rwtzyn5fefut","_id":"cinszs7mr002erwtzuz1knyw7"},{"post_id":"cinszs7mv002frwtzna92sr7u","tag_id":"cinszs7jh0001rwtzlh6ehf2j","_id":"cinszs7mz002hrwtz3f3jjjna"},{"post_id":"cinszs7mv002frwtzna92sr7u","tag_id":"cinszs7mx002grwtzy5cqsxrh","_id":"cinszs7mz002irwtzxdtz1p2l"}],"Tag":[{"name":"AngularJS","_id":"cinszs7jh0001rwtzlh6ehf2j"},{"name":"移动端","_id":"cinszs7jt0005rwtz7as7qub7"},{"name":"rem布局","_id":"cinszs7ju0006rwtzblsvkvw9"},{"name":"微信","_id":"cinszs7jx000arwtzwhsoh8el"},{"name":"JavaScript","_id":"cinszs7k3000grwtzagmccm1h"},{"name":"JavaScript学习笔记","_id":"cinszs7k4000hrwtzgtspq21g"},{"name":"JavaScript高级程序设计学习笔记","_id":"cinszs7kd000orwtzkrwz24o0"},{"name":"面向对象","_id":"cinszs7ke000prwtziapeuqsh"},{"name":"对象","_id":"cinszs7ke000qrwtztvzzkih3"},{"name":"继承","_id":"cinszs7kj000vrwtz8aphvkje"},{"name":"面试总结","_id":"cinszs7kz0016rwtz130dssyf"},{"name":"Hexo","_id":"cinszs7l40019rwtz30qpt7xq"},{"name":"Git","_id":"cinszs7li001irwtzzcpw1pkm"},{"name":"Git规范","_id":"cinszs7li001jrwtzpf7zdoi6"},{"name":"随笔","_id":"cinszs7lo001nrwtztqef8wza"},{"name":"阅读书单","_id":"cinszs7ls001qrwtzd7ruwiio"},{"name":"机械键盘","_id":"cinszs7lz001wrwtznrcrtkcd"},{"name":"读书笔记","_id":"cinszs7m30020rwtzgk6wc3ei"},{"name":"读后感","_id":"cinszs7m90024rwtzphbwwst1"},{"name":"markdown","_id":"cinszs7mh0029rwtzyn5fefut"},{"name":"动态加载","_id":"cinszs7mx002grwtzy5cqsxrh"}]}}