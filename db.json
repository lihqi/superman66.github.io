{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/img/cnzz.png","path":"img/cnzz.png","modified":1},{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":1},{"_id":"themes/yilia/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":1},{"_id":"themes/yilia/source/img/avatar.png","path":"img/avatar.png","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1}],"Cache":[{"_id":"source/_posts/angular-collect.md","shasum":"f98155af24acc41a837c4abfddc742444466d484","modified":1457791741037},{"_id":"source/_posts/angular-lazyload.md","shasum":"88ea08b85f3694b6ed51b563d36846fc9e00a2ea","modified":1456325279701},{"_id":"source/_posts/hexo-guide-1.md","shasum":"2ff80035e231f58a526e60d68bb21d2510936ee9","modified":1456062965314},{"_id":"source/_posts/hexo-guide-2.md","shasum":"a6af306224ef3ad65dfb5ac0bca19782e185df1a","modified":1456150068498},{"_id":"source/_posts/hexo-guide-3.md","shasum":"6e42133dac71be2fe6ed0d2d9b86318bd0aa1eee","modified":1456241046197},{"_id":"source/_posts/hexo-guide-4.md","shasum":"6039081c87268689935c15a85d3049efd0a86b8d","modified":1458370526633},{"_id":"source/_posts/javascript-closure.md","shasum":"59fd51bf0abfcdc5b0b6a928329749330046da38","modified":1458405807387},{"_id":"source/_posts/javascript-hoisting.md","shasum":"77874e905d2f833564111a95bb999b8a20074a44","modified":1457797841529},{"_id":"source/_posts/javascript-inherit.md","shasum":"d3af5527a2efcdc16703c67815fc411773f9bde5","modified":1457199064891},{"_id":"source/_posts/javascript-learning-object.md","shasum":"2f8ad3cb7e868b2485887f0cdfe81a17ae1a0952","modified":1457198999632},{"_id":"source/_posts/mobile-collect.md","shasum":"1d91e9559bdcadbcdeabfc66ea92f5eef4857c2d","modified":1457791791392},{"_id":"source/_posts/project-summary-uular.md","shasum":"67dbacf61f3e632570e6d58dd5bbececd9a7ee27","modified":1457792375834},{"_id":"source/_posts/reading-list-2016.md","shasum":"4b524e677894c8838a1622b317fce7f2ad804557","modified":1457202161416},{"_id":"source/_posts/write.md","shasum":"59a961b3204413f2334ca84222cbcadd883edccf","modified":1456062254952},{"_id":"source/_posts/you-donot-konw-javascript-reading-notes-2.md","shasum":"8a942ec0c8f10601672f0cc37d346edbb4ca9365","modified":1458219993331},{"_id":"source/_posts/you-donot-konw-javascript-reading-notes.md","shasum":"c1ea229e6c661d817c6c5b9b8227541162fb41eb","modified":1458220103043},{"_id":"source/files/editor_md.html","shasum":"a86251c114d93e3eb0d4c397a2c0015d1f972d02","modified":1458222245335},{"_id":"source/img/cnzz.png","shasum":"9d997129aed64fe1c90f92ca561bd2433e3c8789","modified":1456238520554},{"_id":"themes/yilia/README.md","shasum":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1456027247669},{"_id":"themes/yilia/_config.yml","shasum":"6714bd7380d91b9f42ec3bc7f5af64c22e8d8ccc","modified":1456325870304},{"_id":"themes/yilia/languages/de.yml","shasum":"bc80f78f61c3d7af9652e6aa6fc3e4ff39b0c8d3","modified":1456027247676},{"_id":"themes/yilia/languages/default.yml","shasum":"f0a7a032b31555c9ec05a711e1ac19bb07724708","modified":1456027247683},{"_id":"themes/yilia/languages/en.yml","shasum":"a093e794aef63ec9e9e9ef490cf7e4474e45e59f","modified":1456027247687},{"_id":"themes/yilia/languages/fr-FR.yml","shasum":"04b9a0d80d88d01e039e8077afe88f741e9620ba","modified":1456027247690},{"_id":"themes/yilia/languages/ru.yml","shasum":"62f84ea82a696060c481fc22d4742e6201bb9bdc","modified":1456027247697},{"_id":"themes/yilia/languages/zh-Hans.yml","shasum":"d2336578e14bb880d152266981c2b17523fc8742","modified":1456027247701},{"_id":"themes/yilia/languages/zh-hk.yml","shasum":"e702fc43556e54c396917bdf7c869d528742e28b","modified":1456027247705},{"_id":"themes/yilia/languages/zh-tw.yml","shasum":"005559baa96b7bb34e1efe6b031829a95d58d5e0","modified":1456027247710},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","shasum":"3709af4e8f7e1196dbd1f9dea62fa440d4b47836","modified":1456027247733},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","shasum":"5b29a383418cfdcf8d5c5719b4fc4608aaba6fe7","modified":1456027247736},{"_id":"themes/yilia/layout/_partial/archive.ejs","shasum":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1456027247753},{"_id":"themes/yilia/layout/_partial/article.ejs","shasum":"0f3033ea411eabb7a57cf16f08fde468f83add6b","modified":1456152612721},{"_id":"themes/yilia/layout/_partial/cnzz_tongji.ejs","shasum":"fc26f4bf24a9478192710ec420a0432f08c8b8d7","modified":1456241298555},{"_id":"themes/yilia/layout/_partial/footer.ejs","shasum":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1456027247778},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","shasum":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1456027247786},{"_id":"themes/yilia/layout/_partial/head.ejs","shasum":"8fde5ac9e7d10625d9ab9317e008d26d3c02e3a6","modified":1458369146839},{"_id":"themes/yilia/layout/_partial/header.ejs","shasum":"b69855e07b65117769adc515cb64b803932068c9","modified":1456027247813},{"_id":"themes/yilia/layout/_partial/left-col.ejs","shasum":"b03e8424b4798d4887801afdfae457fbf6027838","modified":1456027247827},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","shasum":"7be03a92dabeb2f94bf0e731d12a1c1146d736dd","modified":1456027247840},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","shasum":"6a7a2a4960dabf9d7cd523573da7869eebf4b02d","modified":1456027247846},{"_id":"themes/yilia/layout/_partial/post/category.ejs","shasum":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1456027247855},{"_id":"themes/yilia/layout/_partial/post/date.ejs","shasum":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1456027247859},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","shasum":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1456027247872},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","shasum":"c115c282eebfb6b18612d2d8733272c270b03066","modified":1456027247878},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","shasum":"4ab6cab2a975a4df8419448b33dec4724279d85c","modified":1456027247883},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","shasum":"d50294bf9858e7942208c380e851a37ed37f1d6f","modified":1456027247888},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","shasum":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1456027247897},{"_id":"themes/yilia/layout/_partial/post/title.ejs","shasum":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1456027247902},{"_id":"themes/yilia/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1456027247905},{"_id":"themes/yilia/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1456027247911},{"_id":"themes/yilia/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1456027247914},{"_id":"themes/yilia/layout/layout.ejs","shasum":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1456027247924},{"_id":"themes/yilia/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1456027247928},{"_id":"themes/yilia/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1456027247930},{"_id":"themes/yilia/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1456027247935},{"_id":"themes/yilia/package.json","shasum":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1456027247938},{"_id":"themes/yilia/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1456027247951},{"_id":"themes/yilia/source/css/_partial/archive.styl","shasum":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1456027247956},{"_id":"themes/yilia/source/css/_partial/article.styl","shasum":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1456027247961},{"_id":"themes/yilia/source/css/_partial/footer.styl","shasum":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1456027247965},{"_id":"themes/yilia/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1456027247969},{"_id":"themes/yilia/source/css/_partial/highlight.styl","shasum":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1456027247973},{"_id":"themes/yilia/source/css/_partial/instagram.styl","shasum":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1456027247977},{"_id":"themes/yilia/source/css/_partial/main.styl","shasum":"bfaa5979188612175c90ae881ed16b6870a51bc8","modified":1456063063046},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","shasum":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1456027247985},{"_id":"themes/yilia/source/css/_partial/mobile.styl","shasum":"c44f4c9068160f7ee679c0faf6cda898cd21225e","modified":1456326471164},{"_id":"themes/yilia/source/css/_partial/page.styl","shasum":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1456027247994},{"_id":"themes/yilia/source/css/_partial/scroll.styl","shasum":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1456027247999},{"_id":"themes/yilia/source/css/_partial/share.styl","shasum":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1456027248003},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","shasum":"af0115de5c6455f899a2e09225b50224982c039d","modified":1456027248009},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","shasum":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1456027248013},{"_id":"themes/yilia/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1456027248017},{"_id":"themes/yilia/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1456027248026},{"_id":"themes/yilia/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1456027248032},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1456027248039},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1456027248051},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","shasum":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1456027248057},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1456027248062},{"_id":"themes/yilia/source/css/style.styl","shasum":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1456027248066},{"_id":"themes/yilia/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1456027248068},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1456027248069},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1456027248070},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1456027248071},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1456027248072},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1456027248073},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1456027248076},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1456027248079},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1456027248084},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1456027248091},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1456027248094},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1456027248100},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","shasum":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1456027248104},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","shasum":"004bb0812414554ab48067792f09e978603253b6","modified":1456027248116},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","shasum":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1456027248127},{"_id":"themes/yilia/source/img/avatar.png","shasum":"69470d1a8a3a5e39dc22fc8f0ff6e1e735ac0986","modified":1456035285536},{"_id":"themes/yilia/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1456027248128},{"_id":"themes/yilia/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1456027248130},{"_id":"themes/yilia/source/img/douban.png","shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1456027248131},{"_id":"themes/yilia/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1456027248132},{"_id":"themes/yilia/source/img/favicon.ico","shasum":"e7b7dbb3c7c62aef9e5bddcae3ca87df20c78e0f","modified":1456032156747},{"_id":"themes/yilia/source/img/github.png","shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1456027248133},{"_id":"themes/yilia/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1456027248134},{"_id":"themes/yilia/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1456027248136},{"_id":"themes/yilia/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1456027248136},{"_id":"themes/yilia/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1456027248138},{"_id":"themes/yilia/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1456027248139},{"_id":"themes/yilia/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1456027248140},{"_id":"themes/yilia/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1456027248141},{"_id":"themes/yilia/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1456027248142},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1456027248143},{"_id":"themes/yilia/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1456027248144},{"_id":"themes/yilia/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1456027248146},{"_id":"themes/yilia/source/img/weibo.png","shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1456027248148},{"_id":"themes/yilia/source/img/zhihu.png","shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1456027248149},{"_id":"themes/yilia/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1456027248162},{"_id":"themes/yilia/source/js/jquery.lazyload.js","shasum":"9c34c37b4dca82386648d364da913153d1db902e","modified":1456027248169},{"_id":"themes/yilia/source/js/main.js","shasum":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1456027248174},{"_id":"themes/yilia/source/js/mobile.js","shasum":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1456027248181},{"_id":"themes/yilia/source/js/pc.js","shasum":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1456027248187},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1456027248046},{"_id":"public/img/cnzz.png","modified":1458405830288,"shasum":"9d997129aed64fe1c90f92ca561bd2433e3c8789"},{"_id":"public/js/pc.js","modified":1458405830296,"shasum":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10"},{"_id":"public/js/mobile.js","modified":1458405830299,"shasum":"b68cc01d24e80973c48205f551da87f3f3427644"},{"_id":"public/js/main.js","modified":1458405830305,"shasum":"0640b68a76fab3c693b3cd1e4d04d14be1e53940"},{"_id":"public/js/jquery.lazyload.js","modified":1458405830310,"shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799"},{"_id":"public/js/instagram.js","modified":1458405830314,"shasum":"f19adbcc0dac33536bc6660598059048ec901882"},{"_id":"public/img/zhihu.png","modified":1458405830319,"shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d"},{"_id":"public/img/weibo.png","modified":1458405830322,"shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b"},{"_id":"public/img/twitter.png","modified":1458405830328,"shasum":"14dbb8e62d056525253bc0de13acd1723da7a934"},{"_id":"public/img/stackoverflow.png","modified":1458405830334,"shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2"},{"_id":"public/img/scrollbar_arrow.png","modified":1458405830341,"shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0"},{"_id":"public/img/rss.png","modified":1458405830351,"shasum":"430fd47340e75214c081abd05cd7410cf7c71b86"},{"_id":"public/img/pinterest.png","modified":1458405830355,"shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630"},{"_id":"public/img/pinboard.png","modified":1458405830357,"shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0"},{"_id":"public/img/mail.png","modified":1458405830360,"shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7"},{"_id":"public/img/linkedin.png","modified":1458405830363,"shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c"},{"_id":"public/img/img-loading.png","modified":1458405830365,"shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031"},{"_id":"public/img/img-err.png","modified":1458405830369,"shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b"},{"_id":"public/img/google.png","modified":1458405830372,"shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d"},{"_id":"public/img/github.png","modified":1458405830375,"shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d"},{"_id":"public/img/favicon.ico","modified":1458405830378,"shasum":"e7b7dbb3c7c62aef9e5bddcae3ca87df20c78e0f"},{"_id":"public/img/facebook.png","modified":1458405830382,"shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54"},{"_id":"public/img/douban.png","modified":1458405830388,"shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e"},{"_id":"public/img/delicious.png","modified":1458405830391,"shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd"},{"_id":"public/img/coderwall.png","modified":1458405830395,"shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331"},{"_id":"public/img/avatar.png","modified":1458405830399,"shasum":"69470d1a8a3a5e39dc22fc8f0ff6e1e735ac0986"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1458405830402,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1458405830405,"shasum":"a82597493d75ea989ca586e09173cff332efe41e"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1458405830410,"shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1458405830414,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1458405830419,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1458405830425,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1458405830432,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1458405830439,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1458405830443,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1458405830447,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1458405830452,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1458405830457,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1458405830462,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1458405830475,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1458405830478,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1458405831926,"shasum":"8c5b2578d5712ac630d1cf6923a8e2d64c2a2739"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1458405832339,"shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1458405832343,"shasum":"1480b8101b02da9bc4c60341b5e185e63e585064"},{"_id":"public/css/fonts/fontawesome-webfont.svgz","modified":1458405832347,"shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1458405832352,"shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1458405832359,"shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6"},{"_id":"public/files/editor_md.html","modified":1458405832432,"shasum":"c5b7c63cc5cd29705c3daf115d16eb3ad32e6d01"},{"_id":"public/2016/03/20/javascript-closure/index.html","modified":1458405832484,"shasum":"ddd8e97ef98a150414952a072f4b176d3a84434e"},{"_id":"public/2016/03/15/you-donot-konw-javascript-reading-notes-2/index.html","modified":1458405832516,"shasum":"2b9921c71045fc008fde733b6125d8716c413ba3"},{"_id":"public/2016/03/12/you-donot-konw-javascript-reading-notes/index.html","modified":1458405832542,"shasum":"12f756ba56e7f18c3cf9a037b6362b99beec6183"},{"_id":"public/2016/03/12/project-summary-uular/index.html","modified":1458405832571,"shasum":"d9b8a5c4183025f144c15342b296334e6114d02f"},{"_id":"public/2016/03/06/javascript-inherit/index.html","modified":1458405832615,"shasum":"1b9df1035af9221580d9adf538c85eed920dc51b"},{"_id":"public/2016/03/06/reading-list-2016/index.html","modified":1458405832636,"shasum":"540efc770f0390909ea19dbb96e03bf4c941f2ea"},{"_id":"public/2016/03/05/javascript-hoisting/index.html","modified":1458405832660,"shasum":"04732ca226a1c2b450213b43e21ef3bbd12ea2bd"},{"_id":"public/2016/02/29/angular-collect/index.html","modified":1458405832742,"shasum":"c0c4088f2e97b0d486557dde55d1a898ae2faedc"},{"_id":"public/2016/02/29/mobile-collect/index.html","modified":1458405832764,"shasum":"b07457f419696bc2a392e3bfc111723cfc914a75"},{"_id":"public/2016/02/26/javascript-learning-object/index.html","modified":1458405832796,"shasum":"f30c2a0168855dc817b7fd60c37f7002fc3f45fa"},{"_id":"public/2016/02/24/angular-lazyload/index.html","modified":1458405832819,"shasum":"54aac0efac5a3efd5b0b7743bd6866f93750198e"},{"_id":"public/2016/02/23/hexo-guide-4/index.html","modified":1458405832841,"shasum":"81b2a963abf4657a3f6efbe1419cb58ea3964b71"},{"_id":"public/2016/02/22/hexo-guide-3/index.html","modified":1458405832862,"shasum":"e4f381ece8370e410216f8bb6435ab5168df9959"},{"_id":"public/2016/02/21/hexo-guide-2/index.html","modified":1458405832881,"shasum":"a436370acc7a6be9e68f7dbeb1b02bd7693706d5"},{"_id":"public/2016/02/21/hexo-guide-1/index.html","modified":1458405832901,"shasum":"49ca853e645bb9f3ae03ae222fe62d6fb4a2aaca"},{"_id":"public/2016/02/21/write/index.html","modified":1458405832929,"shasum":"39688421f2e79b90f48672124777aca1b2537fe4"},{"_id":"public/archives/index.html","modified":1458405833034,"shasum":"2e7f027b99706300667cc2b8730ca280e3bc32bb"},{"_id":"public/archives/2016/index.html","modified":1458405833135,"shasum":"d244cb17aadbbcbbd351681259f2094d229816a5"},{"_id":"public/archives/2016/02/index.html","modified":1458405833207,"shasum":"f6b51d1a1bf9d12a3bdee15ee0a6d409177771a3"},{"_id":"public/archives/2016/03/index.html","modified":1458405833271,"shasum":"5de7ea3ef2431d01dea9941843cabd315e6c1c10"},{"_id":"public/index.html","modified":1458405833311,"shasum":"5c755f0469b81eb07e0b6ce363e79d9bed03a55d"},{"_id":"public/page/2/index.html","modified":1458405833346,"shasum":"997466d234414b28b14494cfb4157d40a9f5d0a4"},{"_id":"public/page/3/index.html","modified":1458405833380,"shasum":"849afa931b154469f33aac039e2432093a933a16"},{"_id":"public/page/4/index.html","modified":1458405833397,"shasum":"29bb2b2c6340271c3272d860a0743db85a41f278"},{"_id":"public/tags/AngularJS/index.html","modified":1458405833419,"shasum":"060f7f9bf25f52ded05278fcc055cd7c59dcf69e"},{"_id":"public/tags/JavaScript/index.html","modified":1458405833438,"shasum":"1786fe0cfa5930d92ff4a6de5233a8ec62a69497"},{"_id":"public/tags/JavaScript学习笔记/index.html","modified":1458405833468,"shasum":"6185f24ccf49b8b3a4a1f834c88e1aead10b28be"},{"_id":"public/tags/随笔/index.html","modified":1458405833487,"shasum":"3bf7a67815c34b990ace922fdd3890c65fd94295"},{"_id":"public/tags/阅读书单/index.html","modified":1458405833509,"shasum":"6c2d1a5c7f71376987808dda23ed39b737d2ccde"},{"_id":"public/tags/移动端/index.html","modified":1458405833529,"shasum":"b0eeb4aa674f695bc82ec1b76e78399887b4b04e"},{"_id":"public/tags/rem布局/index.html","modified":1458405833544,"shasum":"6279bbbf6435cdb5bfc8bed3507a2b7300c231b3"},{"_id":"public/tags/JavaScript高级程序设计学习笔记/index.html","modified":1458405833563,"shasum":"d5c0a8cae726b022bb8fd4068f19b5f1ac247c23"},{"_id":"public/tags/面向对象/index.html","modified":1458405833588,"shasum":"7a7d8705885f8c0f1a0483c07f8170cad07eb26e"},{"_id":"public/tags/对象/index.html","modified":1458405833602,"shasum":"78fa12b0bcff638cb9aebddcbdde6c2052c15a40"},{"_id":"public/tags/继承/index.html","modified":1458405833617,"shasum":"44f38ac51dd036b27265ad564cd2de656d626c7b"},{"_id":"public/tags/Hexo/index.html","modified":1458405833646,"shasum":"d83ae34c40f0dbd76e0f8239bc20c71084ab6ae0"},{"_id":"public/tags/动态加载/index.html","modified":1458405833660,"shasum":"5942689e4439d506f8755e04b529629ae15bdb0f"}],"Category":[],"Data":[],"Page":[{"_content":"<style type=\"text/css\">.e{position:absolute;top:0;right:50%;bottom:0;left:0;} .c{position:absolute;overflow:auto;top:0;right:0;bottom:0;left:50%;}</style><div class=\"e\" id=\"editor\"></div><div class=\"c\"></div><script src=\"http://d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js\" type=\"text/javascript\" charset=\"utf-8\"></script><script src=\"http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js\"></script><script> function showResult(e){consoleEl.innerHTML=e}var e=ace.edit(\"editor\");e.setTheme(\"ace/theme/monokai\");e.getSession().setMode(\"ace/mode/markdown\");var consoleEl=document.getElementsByClassName(\"c\")[0];var converter=new Showdown.converter;e.commands.addCommand({name:\"markdown\",bindKey:{win:\"Ctrl-M\",mac:\"Command-M\"},exec:function(t){var n=e.getSession().getMode().$id;if(n==\"ace/mode/markdown\"){showResult(converter.makeHtml(t.getValue()))}},readOnly:true})</script>","source":"files/editor_md.html","raw":"<style type=\"text/css\">.e{position:absolute;top:0;right:50%;bottom:0;left:0;} .c{position:absolute;overflow:auto;top:0;right:0;bottom:0;left:50%;}</style><div class=\"e\" id=\"editor\"></div><div class=\"c\"></div><script src=\"http://d1n0x3qji82z53.cloudfront.net/src-min-noconflict/ace.js\" type=\"text/javascript\" charset=\"utf-8\"></script><script src=\"http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js\"></script><script> function showResult(e){consoleEl.innerHTML=e}var e=ace.edit(\"editor\");e.setTheme(\"ace/theme/monokai\");e.getSession().setMode(\"ace/mode/markdown\");var consoleEl=document.getElementsByClassName(\"c\")[0];var converter=new Showdown.converter;e.commands.addCommand({name:\"markdown\",bindKey:{win:\"Ctrl-M\",mac:\"Command-M\"},exec:function(t){var n=e.getSession().getMode().$id;if(n==\"ace/mode/markdown\"){showResult(converter.makeHtml(t.getValue()))}},readOnly:true})</script>","date":"2016-03-17T13:44:05.335Z","updated":"2016-03-17T13:44:05.335Z","path":"files/editor_md.html","title":"","comments":1,"layout":"page","_id":"cilzd6bzi0003m0pj32odp42v"}],"Post":[{"title":"关于AngularJS的一些坑","date":"2016-02-29T13:45:39.000Z","_content":"本文是搜集学习AngularJS和开发中收集的一些坑。持续更新。\n<!-- more -->\n## 1、select第一行出现空白\n在使用带有angular数据绑定功能的HTML SELECT 元素时，如果不指定default value的话，第一个option会出现空白，如下图：\n\n解决办法：\n`为select添加 一个 默认的option`\n```javascript\n    <select ng-model=\"myColor\" ng-options=\"d.id for d in data\">\n            <option value=\"\">请选择</option>\n     </select>\n```\n## 2、AngularJS在IE的XHR请求存在Bug。\nIE只会在第一次才会从服务器中去请求XHR数据，之后的XHR请求都是从缓存中取。 \n解决办法：禁用IE对ajax的缓存\nhttp://stackoverflow.com/questions/16098430/angular-ie-caching-issue-for-http\n具体代码如下：\n```javascript\nmyModule.config(['$httpProvider', function($httpProvider) {\n    //initialize get if not there\n    if (!$httpProvider.defaults.headers.get) {\n        $httpProvider.defaults.headers.get = {};  \n    }  \n \n    // Answer edited to include suggestions from comments\n    // because previous version of code introduced browser-related errors\n \n    //disable IE ajax request caching\n    $httpProvider.defaults.headers.get['If-Modified-Since'] = 'Mon, 26 Jul 1997 05:00:00 GMT';\n    // extra\n    $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';\n    $httpProvider.defaults.headers.get['Pragma'] = 'no-cache';}]);\n```\n","source":"_posts/angular-collect.md","raw":"---\ntitle: 关于AngularJS的一些坑\ndate: 2016-02-29 21:45:39\ntags: AngularJS\n---\n本文是搜集学习AngularJS和开发中收集的一些坑。持续更新。\n<!-- more -->\n## 1、select第一行出现空白\n在使用带有angular数据绑定功能的HTML SELECT 元素时，如果不指定default value的话，第一个option会出现空白，如下图：\n\n解决办法：\n`为select添加 一个 默认的option`\n```javascript\n    <select ng-model=\"myColor\" ng-options=\"d.id for d in data\">\n            <option value=\"\">请选择</option>\n     </select>\n```\n## 2、AngularJS在IE的XHR请求存在Bug。\nIE只会在第一次才会从服务器中去请求XHR数据，之后的XHR请求都是从缓存中取。 \n解决办法：禁用IE对ajax的缓存\nhttp://stackoverflow.com/questions/16098430/angular-ie-caching-issue-for-http\n具体代码如下：\n```javascript\nmyModule.config(['$httpProvider', function($httpProvider) {\n    //initialize get if not there\n    if (!$httpProvider.defaults.headers.get) {\n        $httpProvider.defaults.headers.get = {};  \n    }  \n \n    // Answer edited to include suggestions from comments\n    // because previous version of code introduced browser-related errors\n \n    //disable IE ajax request caching\n    $httpProvider.defaults.headers.get['If-Modified-Since'] = 'Mon, 26 Jul 1997 05:00:00 GMT';\n    // extra\n    $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';\n    $httpProvider.defaults.headers.get['Pragma'] = 'no-cache';}]);\n```\n","slug":"angular-collect","published":1,"updated":"2016-03-12T14:09:01.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6byi0000m0pj72ullfgc"},{"title":"【你不知道的JavasSript(上)读书笔记】第1章：作用域","date":"2016-03-12T14:11:54.000Z","_content":"该系列是《你不知道的JavaScript（上）》的读书笔记。记录成文字，加深学习印象。\n<!-- more -->\n# 一、JavaScript编译原理\n传统的语言编译一般经历三个过程：\n* 分词/词法分析\n* 解析/语法分析\n* 代码生成\n而JavaScript引擎则要复杂得多了。简单来说就是任何JavaScript代码在执行前都要进行**编译**（通常在代码执行前）。\n# 二、理解作用域\n要理解作用域之前需要了解下什么是作用域，它有什么作用？同时还需要了解JavaScript引擎和编译器是什么？\n* 引擎\n    从头到尾负责整个JavaScript程序的编译及执行过程。\n* 编译器\n    负责语法分析及代码生成\n* 作用域\n   负责收集并维护由所有声明的标识符（及变量）组成的一系列**查询**，并实施一套**规则**，确定当前执行的代码对这些标识符的**访问权限**（简而言之就是规定了谁有权限访问哪些变量）。\n现在以`var a = 2`这个简单的变量命名过程来分析，JavaScript引擎会将其看做两步`var a;`和`a = 2`两步进行。详见下面的流程图\n![JavaScript变量编译流程图](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_JavaScript%E5%8F%98%E9%87%8F%E7%BC%96%E8%AF%91.png)\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域查找该变量，如果能够找到便对它进行赋值。\n### 关于变量查找的类型\n编译器在编译过程，会对变量进行查询。一种是LHS查询，另外一种查找的类型是RHS。\n* LHS 当变量出现在赋值操作的左侧时进行LHS查询 （赋值操作的目标是谁）\n* RHS 当变量出现在赋值操作的非左侧时，进行RHS查询（谁是赋值操作的源头，取到这个变量的源值）\n试着找出下面的例子各有多少个LHS和RHS\n```javascript\nfunction foo(a){\n    var b = a;\n    return b+a;\n}\nvar c = foo(2);\n```\n_答案在结尾_\n# 三、作用域嵌套\n所谓作用域嵌套就是当一个块或函数嵌套在另外一个块或函数中，就发生了作用域的嵌套。因此在当前作用域无法找到该变量时，就会往外层嵌套作用域中继续寻找，直到找到该变量或者抵达最外层的作用域（也就是全局作用域）为止。\n# 四、异常\n前面提到的LHS和RHS两种查询，如何区分它们是非常重要的一件事。\n因为在变量尚未声明之前，二者的查询行为是不一样的。如下面例子\n```javascript\nfunction foo(a){\n    console.log(b+a);\n    b = a;\n}\nfoo(2);\n```\n想一下，输出的值应该是什么？\n答案：`Uncaught ReferenceError: b is not defined(…)`，结果会报错。因为`b`并没有被定义，因此引擎就抛出`ReferenceError`异常。\n为什么会导致这样的结果呢？这是因为在对变量`b`进行RHS查询的时候，如果在作用域中没有找到该变量，也就是说明这是一个“未声明”的变量，这时候引擎就会抛出`ReferenceError`异常。\n相比较之下，如果是对变量`b`进行LHS查询的时候，如果在全局作用域也没有找到该变量的话，**全局作用域便会自动创建该变量**，前提是在非严格模式下。**这就是LHS和RHS的两种查询类型的区别**。\n同样，在JavaScript中，也有两种异常类型。一种就是刚刚说到的`ReferenceError`，另外一种则是`TypeError`。那这二者有什么区别吗？\n* `ReferenceError`指的是同作用域判别失败相关，简单说就是在作用域找不到该变量。\n* `TypeError`指的是作用域判别成功，但对结果的操作是非法或者不合理的。简单说就是在作用域找到该变量，但是该变量的值不符合。\n\n**前面问题的答案**\nLHS\n* `c=`\n* `a=2`\n* `b=`。\nRHS\n* `foo(2)`\n* `=a`\n* `a`（return的时候要去查找a的值）   \n* `b`（return的时候要去查找b的值）","source":"_posts/you-donot-konw-javascript-reading-notes.md","raw":"---\ntitle: 【你不知道的JavasSript(上)读书笔记】第1章：作用域\ndate: 2016-03-12 22:11:54\ntags:\n- JavaScript\n- JavaScript学习笔记\n---\n该系列是《你不知道的JavaScript（上）》的读书笔记。记录成文字，加深学习印象。\n<!-- more -->\n# 一、JavaScript编译原理\n传统的语言编译一般经历三个过程：\n* 分词/词法分析\n* 解析/语法分析\n* 代码生成\n而JavaScript引擎则要复杂得多了。简单来说就是任何JavaScript代码在执行前都要进行**编译**（通常在代码执行前）。\n# 二、理解作用域\n要理解作用域之前需要了解下什么是作用域，它有什么作用？同时还需要了解JavaScript引擎和编译器是什么？\n* 引擎\n    从头到尾负责整个JavaScript程序的编译及执行过程。\n* 编译器\n    负责语法分析及代码生成\n* 作用域\n   负责收集并维护由所有声明的标识符（及变量）组成的一系列**查询**，并实施一套**规则**，确定当前执行的代码对这些标识符的**访问权限**（简而言之就是规定了谁有权限访问哪些变量）。\n现在以`var a = 2`这个简单的变量命名过程来分析，JavaScript引擎会将其看做两步`var a;`和`a = 2`两步进行。详见下面的流程图\n![JavaScript变量编译流程图](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_JavaScript%E5%8F%98%E9%87%8F%E7%BC%96%E8%AF%91.png)\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域查找该变量，如果能够找到便对它进行赋值。\n### 关于变量查找的类型\n编译器在编译过程，会对变量进行查询。一种是LHS查询，另外一种查找的类型是RHS。\n* LHS 当变量出现在赋值操作的左侧时进行LHS查询 （赋值操作的目标是谁）\n* RHS 当变量出现在赋值操作的非左侧时，进行RHS查询（谁是赋值操作的源头，取到这个变量的源值）\n试着找出下面的例子各有多少个LHS和RHS\n```javascript\nfunction foo(a){\n    var b = a;\n    return b+a;\n}\nvar c = foo(2);\n```\n_答案在结尾_\n# 三、作用域嵌套\n所谓作用域嵌套就是当一个块或函数嵌套在另外一个块或函数中，就发生了作用域的嵌套。因此在当前作用域无法找到该变量时，就会往外层嵌套作用域中继续寻找，直到找到该变量或者抵达最外层的作用域（也就是全局作用域）为止。\n# 四、异常\n前面提到的LHS和RHS两种查询，如何区分它们是非常重要的一件事。\n因为在变量尚未声明之前，二者的查询行为是不一样的。如下面例子\n```javascript\nfunction foo(a){\n    console.log(b+a);\n    b = a;\n}\nfoo(2);\n```\n想一下，输出的值应该是什么？\n答案：`Uncaught ReferenceError: b is not defined(…)`，结果会报错。因为`b`并没有被定义，因此引擎就抛出`ReferenceError`异常。\n为什么会导致这样的结果呢？这是因为在对变量`b`进行RHS查询的时候，如果在作用域中没有找到该变量，也就是说明这是一个“未声明”的变量，这时候引擎就会抛出`ReferenceError`异常。\n相比较之下，如果是对变量`b`进行LHS查询的时候，如果在全局作用域也没有找到该变量的话，**全局作用域便会自动创建该变量**，前提是在非严格模式下。**这就是LHS和RHS的两种查询类型的区别**。\n同样，在JavaScript中，也有两种异常类型。一种就是刚刚说到的`ReferenceError`，另外一种则是`TypeError`。那这二者有什么区别吗？\n* `ReferenceError`指的是同作用域判别失败相关，简单说就是在作用域找不到该变量。\n* `TypeError`指的是作用域判别成功，但对结果的操作是非法或者不合理的。简单说就是在作用域找到该变量，但是该变量的值不符合。\n\n**前面问题的答案**\nLHS\n* `c=`\n* `a=2`\n* `b=`。\nRHS\n* `foo(2)`\n* `=a`\n* `a`（return的时候要去查找a的值）   \n* `b`（return的时候要去查找b的值）","slug":"you-donot-konw-javascript-reading-notes","published":1,"updated":"2016-03-17T13:08:23.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6bzm0004m0pji06to1o9"},{"title":"【你不知道的JavasSript(上)读书笔记】第2章：词法作用域","date":"2016-03-14T16:54:54.000Z","_content":"该系列是《你不知道的JavaScript（上）》的读书笔记。记录成文字，加深学习印象。\n<!-- more -->\n# 什么是词法作用域\n词法作用域就是定义在词法阶段的作用域。是不是很难理解呢、换句话说就是，词法作用域意味着**作用域由书写代码时函数的位置**来决定的。如果还不能理解的话，先以一个简单的例子来说明：\n```javascript\n    function fn1(a) {\n        var b = a * 2;\n\n        function fn2(c) {\n        \tconsole.log(a, b, c);\n        }\n        fn2(b * 3);\n    }\n    fn1(2);\t// 2, 4 ,12\n```\n上面这个例子包含着三个作用域\n* 全局作用域\n* fn1的作用域\n* fn2的作用域\n根据它们定义的位置，这三个作用域应该是逐级包含的关系。\n\n如果上面这个例子可以理解的话，那么再来看一个相对复杂一点的例子：\n```javascript\n    function foo() {\n        console.log(a);\n    }\n\n    function bar() {\n        var a = 3;\n        foo();\n    }\n    var a = 2;\n    bar(); // 2\n```\n最终的输出结果是`2`。可能会有人觉得应该输出`3`的，但是为什么却是输出`2`呢？\n根据前面所提到的词法作用域指的是**作用域由书写代码时函数的位置来决定的，而不是代码执行引用的位置**。只要理解了这个概念，就能明白了上面的输出结果了。\n函数`foo`是在全局作用域下定义的，因此它的作用域是属于全局作用域的子作用域。函数`bar`也是一样，属于全局作用域的子作用域。\n虽然函数`foo`在函数`bar`中执行了(二者并不存在父子作用域的关系)，但是函数`fn`此时的父级作用域仍然是全局作用域。因此当引擎执行`console.log(a)`的声明时，会对变量`a`进行RHS查询。引擎在`foo`当前作用域寻找不到`a`，便往上级作用域（对`foo`而言便是全局作用域）寻找，在上级作用域找到了`a=2`，因此就输出了`2`。\n这也就是JavaScript没有动态作用域的原因。如果JavaScript支持动态作用域，那么最后的输出结果应该是`3`，而不是`2`。","source":"_posts/you-donot-konw-javascript-reading-notes-2.md","raw":"---\ntitle: 【你不知道的JavasSript(上)读书笔记】第2章：词法作用域\ndate: 2016-03-15 00:54:54\ntags:\n- JavaScript\n- JavaScript学习笔记\n---\n该系列是《你不知道的JavaScript（上）》的读书笔记。记录成文字，加深学习印象。\n<!-- more -->\n# 什么是词法作用域\n词法作用域就是定义在词法阶段的作用域。是不是很难理解呢、换句话说就是，词法作用域意味着**作用域由书写代码时函数的位置**来决定的。如果还不能理解的话，先以一个简单的例子来说明：\n```javascript\n    function fn1(a) {\n        var b = a * 2;\n\n        function fn2(c) {\n        \tconsole.log(a, b, c);\n        }\n        fn2(b * 3);\n    }\n    fn1(2);\t// 2, 4 ,12\n```\n上面这个例子包含着三个作用域\n* 全局作用域\n* fn1的作用域\n* fn2的作用域\n根据它们定义的位置，这三个作用域应该是逐级包含的关系。\n\n如果上面这个例子可以理解的话，那么再来看一个相对复杂一点的例子：\n```javascript\n    function foo() {\n        console.log(a);\n    }\n\n    function bar() {\n        var a = 3;\n        foo();\n    }\n    var a = 2;\n    bar(); // 2\n```\n最终的输出结果是`2`。可能会有人觉得应该输出`3`的，但是为什么却是输出`2`呢？\n根据前面所提到的词法作用域指的是**作用域由书写代码时函数的位置来决定的，而不是代码执行引用的位置**。只要理解了这个概念，就能明白了上面的输出结果了。\n函数`foo`是在全局作用域下定义的，因此它的作用域是属于全局作用域的子作用域。函数`bar`也是一样，属于全局作用域的子作用域。\n虽然函数`foo`在函数`bar`中执行了(二者并不存在父子作用域的关系)，但是函数`fn`此时的父级作用域仍然是全局作用域。因此当引擎执行`console.log(a)`的声明时，会对变量`a`进行RHS查询。引擎在`foo`当前作用域寻找不到`a`，便往上级作用域（对`foo`而言便是全局作用域）寻找，在上级作用域找到了`a=2`，因此就输出了`2`。\n这也就是JavaScript没有动态作用域的原因。如果JavaScript支持动态作用域，那么最后的输出结果应该是`3`，而不是`2`。","slug":"you-donot-konw-javascript-reading-notes-2","published":1,"updated":"2016-03-17T13:06:33.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6bzr0009m0pjubjqnvxs"},{"title":"随笔系列","date":"2016-02-21T06:38:42.000Z","_content":"# 随笔\n待完善。。。","source":"_posts/write.md","raw":"---\ntitle: 随笔系列\ndate: 2016-02-21 14:38:42\ntags: 随笔\n---\n# 随笔\n待完善。。。","slug":"write","published":1,"updated":"2016-02-21T13:44:14.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6bzw000cm0pjt0qtjlr8"},{"title":"2016阅读书单","date":"2016-03-05T16:32:29.000Z","_content":"记录2016阅读过的书籍\n<!-- more -->\n# 2016-02-阅读列表\n## 《把时间当朋友》- 很不错的一本关于时间与精力的书。\n\n书中有个观点非常有意思：利用黄金分割法来规划你的时间。如果你一天可以规划的时间有10个小时，那么大概用6.18小时去工作学习，剩下的大约3.82小时去享受欢乐。我们总想着一直保持高效率的运转，但这是不切实际的。所以不妨试试这个方法来规划你的时间。\n\n## 《当我跑步时，我谈些什么》- 村上春树的经典之作\n\n喜欢就一个理由，不喜欢却有千千万万的借口。为什么我现在还没有开始跑步呢，可能是自己还没找到一个可以为之坚持的理由吧！\n\n## 《高效程序员的45个习惯》- 论程序猿的自我修养\n\n程序猿学习应该是迭代和增量式学习。每天用一定时间来学习新技术，不需要很多时间，但要经常进行。记录新的技术，在计划时间学习。ps:这不就是互联网的节奏嘛，快速迭代，小步快跑。\n\n## 《小强升职记》 - 这名字无力吐槽了，但是不能以貌取人\n\n\n实操性非常强的一本书，感谢这本书让我获得了行动计划的习惯。当然了，书中还提到很多非常行之有效的办法，只不过我没学到。\n\n## 《程序员跳槽全攻略》 - 其实是我想跳槽了\n\n\n就算是不想跳槽的程序猿也值得看一看。因为总有一天你也会面临跳槽的问题。\n\n## 《人类简史》 - 别被名字吓到了，内容和文字非常浅显易懂！\n\n“现代人类的各种破坏大自然的行为，被很多人称呼是“自然的毁灭”。然而，这其实并不能算是“毁灭”，而只是“改变”。自然是无法“毁灭”的。6500万年前，一颗陨石让恐龙灭绝，但却为哺乳类动物开启了一条康庄大道。今天，人类正在让许多物种灭绝，甚至可能包括自己。但即使如此，还是有某些生物过得生龙活虎。举例来说，老鼠和蟑螂可说是正在全盛时期。如果今天发生核灾而让世界末日降临，这些顽强的动物很有可能就会从闷烧的废墟里爬出来，准备好继续将自己的DNA传给千代万代。或许，现在的6500万年后，会有一群高智商的老鼠心怀感激地回顾人类造成的这场灾难，就像我们现在感谢那颗杀死恐龙的陨石一般。” 细思极恐！\n","source":"_posts/reading-list-2016.md","raw":"---\ntitle: 2016阅读书单\ndate: 2016-03-06 00:32:29\ntags:\n- 阅读书单\n- 随笔\n---\n记录2016阅读过的书籍\n<!-- more -->\n# 2016-02-阅读列表\n## 《把时间当朋友》- 很不错的一本关于时间与精力的书。\n\n书中有个观点非常有意思：利用黄金分割法来规划你的时间。如果你一天可以规划的时间有10个小时，那么大概用6.18小时去工作学习，剩下的大约3.82小时去享受欢乐。我们总想着一直保持高效率的运转，但这是不切实际的。所以不妨试试这个方法来规划你的时间。\n\n## 《当我跑步时，我谈些什么》- 村上春树的经典之作\n\n喜欢就一个理由，不喜欢却有千千万万的借口。为什么我现在还没有开始跑步呢，可能是自己还没找到一个可以为之坚持的理由吧！\n\n## 《高效程序员的45个习惯》- 论程序猿的自我修养\n\n程序猿学习应该是迭代和增量式学习。每天用一定时间来学习新技术，不需要很多时间，但要经常进行。记录新的技术，在计划时间学习。ps:这不就是互联网的节奏嘛，快速迭代，小步快跑。\n\n## 《小强升职记》 - 这名字无力吐槽了，但是不能以貌取人\n\n\n实操性非常强的一本书，感谢这本书让我获得了行动计划的习惯。当然了，书中还提到很多非常行之有效的办法，只不过我没学到。\n\n## 《程序员跳槽全攻略》 - 其实是我想跳槽了\n\n\n就算是不想跳槽的程序猿也值得看一看。因为总有一天你也会面临跳槽的问题。\n\n## 《人类简史》 - 别被名字吓到了，内容和文字非常浅显易懂！\n\n“现代人类的各种破坏大自然的行为，被很多人称呼是“自然的毁灭”。然而，这其实并不能算是“毁灭”，而只是“改变”。自然是无法“毁灭”的。6500万年前，一颗陨石让恐龙灭绝，但却为哺乳类动物开启了一条康庄大道。今天，人类正在让许多物种灭绝，甚至可能包括自己。但即使如此，还是有某些生物过得生龙活虎。举例来说，老鼠和蟑螂可说是正在全盛时期。如果今天发生核灾而让世界末日降临，这些顽强的动物很有可能就会从闷烧的废墟里爬出来，准备好继续将自己的DNA传给千代万代。或许，现在的6500万年后，会有一群高智商的老鼠心怀感激地回顾人类造成的这场灾难，就像我们现在感谢那颗杀死恐龙的陨石一般。” 细思极恐！\n","slug":"reading-list-2016","published":1,"updated":"2016-03-05T18:22:41.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6bzz000fm0pjk9weeky1"},{"title":"优乐健身移动端页面制作总结","date":"2016-03-12T13:50:42.000Z","_content":"该项目是优乐健身的移动端页面。刚好利用这个项目用来学习移动端的适配方案：rem布局。 \n<!-- more -->\n\n# 项目介绍\n该项目是优乐健身的移动端页面。网站要求字体和边距做到自适应。因此采用了rem布局。\nrem布局参考资料：\nweb app变革之rem: https://isux.tencent.com/web-app-rem.html\n手机端页面自适应解决方案: http://www.jianshu.com/p/b00cd3506782\n\n# 项目技术点\n## 1、rem布局\nrem布局非常简单，只需要将下面的JavaScript代码放到你的页面中即可。\n```\n(function (doc, win) { \n\tvar docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', \n\trecalc = function () { \n\tvar clientWidth = docEl.clientWidth; \n\tif (!clientWidth) return; \n\tif(clientWidth>=640){ \n\tdocEl.style.fontSize = '100px'; \n\t}\n\telse{ \n\tdocEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; \n\t}\n\t}; \n\tif (!doc.addEventListener) return; \n\twin.addEventListener(resizeEvt, recalc, false); \n\tdoc.addEventListener('DOMContentLoaded', recalc, false); \n\t})(document, window);\n```\n### 如何使用\n先解释下上面的代码，最核心的意思就是说当页面的宽度超过了640px，html的`font-size`为100px。如果小于640px，则通过`100 * (clientWidth / 640)`计算出页面的`font-size`。这时候便可以在网页中尽情使用rem了。所以涉及到宽度和距离的属性比如`width`、`margin`、`padding`、`font-size`等都可以使用rem作为单位。\n那么设计稿中的px值要怎么转换成rem值呢？\n我们可以将font-size的值设成100px，这样1rem = 100px。如果设计稿中的宽度是30px的话，那么就可以很方便的转换为0.3rem。\n**ps:这里设置宽度为640px是根据设计稿来的，如果你拿到的设计稿是750，那么你就可以将上面的数值改为750。**\n\n### rem布局存在的问题\n**存在的问题**：在生成dom树的时候，底部用js改变html的font-size的话，会造成整个页面重新布局，这样的结果就是导致页面元素因为尺寸改变了而闪烁的情况。在页面类容大的时候，加载时页面会有明显的动态变化，\n**解决办法**： \n* 使用一个全局loading页面，在fontSize计算之后才展示真正的页面\n* 用响应式样式控制最好先用响应式，再用js。具体做法就是用CSS的`@media`根据屏幕初始化一遍html的font-size，然后在再用js计算，这样可以避免页面加载时候出现的闪烁。具体的CSS代码如下面：\n```css\n@media only screen and (max-width: 320px){html{font-size: 9px;} }\n@media only screen and (min-width: 320px) and (max-width: 352px){html{font-size: 10px;} }\n@media only screen and (min-width: 352px) and (max-width: 384px){html{font-size: 11px;} }\n@media only screen and (min-width: 384px) and (max-width: 416px){html{font-size: 12px;} }\n@media only screen and (min-width: 416px) and (max-width: 448px){html{font-size: 13px;} }\n@media only screen and (min-width: 448px) and (max-width: 480px){html{font-size: 14px;} }\n@media only screen and (min-width: 480px) and (max-width: 512px){html{font-size: 15px;} }\n@media only screen and (min-width: 512px) and (max-width: 544px){html{font-size: 16px;} }\n@media only screen and (min-width: 544px) and (max-width: 576px){html{font-size: 17px;} }\n@media only screen and (min-width: 576px) and (max-width: 608px){html{font-size: 18px;} }\n@media only screen and (min-width: 608px) and (max-width: 640px){html{font-size: 19px;} }\n@media only screen and (min-width: 640px){html{font-size: 20px;} }\n\n来源： https://isux.tencent.com/web-app-rem.html\n```     \n* 采取淘宝的[flexible.js](https://github.com/amfe/lib-flexible)方案解决。\n```\n## 2、自定义select框\n如何自定义select框的样式\n## 3、移动端直接拨打电话\n\n```html\n<a href=\"tel://110\">电话</a>\n```\n在`a`标签中使用tel://协议，后面跟着电话号码，就可以实现在移动端拨打电话。","source":"_posts/project-summary-uular.md","raw":"---\ntitle: 优乐健身移动端页面制作总结\ndate: 2016-03-12 21:50:42\ntags: \n- 移动端 \n- rem布局\n---\n该项目是优乐健身的移动端页面。刚好利用这个项目用来学习移动端的适配方案：rem布局。 \n<!-- more -->\n\n# 项目介绍\n该项目是优乐健身的移动端页面。网站要求字体和边距做到自适应。因此采用了rem布局。\nrem布局参考资料：\nweb app变革之rem: https://isux.tencent.com/web-app-rem.html\n手机端页面自适应解决方案: http://www.jianshu.com/p/b00cd3506782\n\n# 项目技术点\n## 1、rem布局\nrem布局非常简单，只需要将下面的JavaScript代码放到你的页面中即可。\n```\n(function (doc, win) { \n\tvar docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', \n\trecalc = function () { \n\tvar clientWidth = docEl.clientWidth; \n\tif (!clientWidth) return; \n\tif(clientWidth>=640){ \n\tdocEl.style.fontSize = '100px'; \n\t}\n\telse{ \n\tdocEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; \n\t}\n\t}; \n\tif (!doc.addEventListener) return; \n\twin.addEventListener(resizeEvt, recalc, false); \n\tdoc.addEventListener('DOMContentLoaded', recalc, false); \n\t})(document, window);\n```\n### 如何使用\n先解释下上面的代码，最核心的意思就是说当页面的宽度超过了640px，html的`font-size`为100px。如果小于640px，则通过`100 * (clientWidth / 640)`计算出页面的`font-size`。这时候便可以在网页中尽情使用rem了。所以涉及到宽度和距离的属性比如`width`、`margin`、`padding`、`font-size`等都可以使用rem作为单位。\n那么设计稿中的px值要怎么转换成rem值呢？\n我们可以将font-size的值设成100px，这样1rem = 100px。如果设计稿中的宽度是30px的话，那么就可以很方便的转换为0.3rem。\n**ps:这里设置宽度为640px是根据设计稿来的，如果你拿到的设计稿是750，那么你就可以将上面的数值改为750。**\n\n### rem布局存在的问题\n**存在的问题**：在生成dom树的时候，底部用js改变html的font-size的话，会造成整个页面重新布局，这样的结果就是导致页面元素因为尺寸改变了而闪烁的情况。在页面类容大的时候，加载时页面会有明显的动态变化，\n**解决办法**： \n* 使用一个全局loading页面，在fontSize计算之后才展示真正的页面\n* 用响应式样式控制最好先用响应式，再用js。具体做法就是用CSS的`@media`根据屏幕初始化一遍html的font-size，然后在再用js计算，这样可以避免页面加载时候出现的闪烁。具体的CSS代码如下面：\n```css\n@media only screen and (max-width: 320px){html{font-size: 9px;} }\n@media only screen and (min-width: 320px) and (max-width: 352px){html{font-size: 10px;} }\n@media only screen and (min-width: 352px) and (max-width: 384px){html{font-size: 11px;} }\n@media only screen and (min-width: 384px) and (max-width: 416px){html{font-size: 12px;} }\n@media only screen and (min-width: 416px) and (max-width: 448px){html{font-size: 13px;} }\n@media only screen and (min-width: 448px) and (max-width: 480px){html{font-size: 14px;} }\n@media only screen and (min-width: 480px) and (max-width: 512px){html{font-size: 15px;} }\n@media only screen and (min-width: 512px) and (max-width: 544px){html{font-size: 16px;} }\n@media only screen and (min-width: 544px) and (max-width: 576px){html{font-size: 17px;} }\n@media only screen and (min-width: 576px) and (max-width: 608px){html{font-size: 18px;} }\n@media only screen and (min-width: 608px) and (max-width: 640px){html{font-size: 19px;} }\n@media only screen and (min-width: 640px){html{font-size: 20px;} }\n\n来源： https://isux.tencent.com/web-app-rem.html\n```     \n* 采取淘宝的[flexible.js](https://github.com/amfe/lib-flexible)方案解决。\n```\n## 2、自定义select框\n如何自定义select框的样式\n## 3、移动端直接拨打电话\n\n```html\n<a href=\"tel://110\">电话</a>\n```\n在`a`标签中使用tel://协议，后面跟着电话号码，就可以实现在移动端拨打电话。","slug":"project-summary-uular","published":1,"updated":"2016-03-12T14:19:35.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c04000jm0pj9eiynaks"},{"title":"收集移动端代码","date":"2016-02-29T13:44:05.000Z","_content":"收集了移动端的一些代码，持续更新。\n<!-- more -->\n## 1、input输入框更改placeholder样式\n```cpp\n/* webkit solution*/\ninput :: -webkit-input-placeholder {\n    text-align: center;\n    color: #333;\n}\n/* mozilla solution*/\ninput:-moz-placeholder{\n    text-align: center;\n    color: #333;\n}\n```\n## 2、iOS系统去除input输入框自带的内阴影\n```cpp\ninput{\n    -webkit-appearance: none;\n}\n```\n### 3、去除数字输入框的小三角\n```cpp\n/* webkit*/\ninput::-webkit-outer-spin-button,\ninput:: -webkit-inner-spin-button{\n   -webikt-appearance: none;\n}\n/*mozilla */\ninput[type=\"numer\"]{\n    -moz-appearance: textfield;\n}\n```\n### 4、手机网页中点击链接自动拨打电话\n```\n<a href=”tel://110 ”>电话</a>\n```\n","source":"_posts/mobile-collect.md","raw":"---\ntitle: 收集移动端代码\ndate: 2016-02-29 21:44:05\ntags: 移动端\n---\n收集了移动端的一些代码，持续更新。\n<!-- more -->\n## 1、input输入框更改placeholder样式\n```cpp\n/* webkit solution*/\ninput :: -webkit-input-placeholder {\n    text-align: center;\n    color: #333;\n}\n/* mozilla solution*/\ninput:-moz-placeholder{\n    text-align: center;\n    color: #333;\n}\n```\n## 2、iOS系统去除input输入框自带的内阴影\n```cpp\ninput{\n    -webkit-appearance: none;\n}\n```\n### 3、去除数字输入框的小三角\n```cpp\n/* webkit*/\ninput::-webkit-outer-spin-button,\ninput:: -webkit-inner-spin-button{\n   -webikt-appearance: none;\n}\n/*mozilla */\ninput[type=\"numer\"]{\n    -moz-appearance: textfield;\n}\n```\n### 4、手机网页中点击链接自动拨打电话\n```\n<a href=”tel://110 ”>电话</a>\n```\n","slug":"mobile-collect","published":1,"updated":"2016-03-12T14:09:51.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c0a000om0pjo6p17mjk"},{"title":"【JavaScript高程学习笔记】面向对象的程序设计之对象","date":"2016-02-25T16:45:53.000Z","_content":"本篇文章是学习《Javascript高级程序设计》中关于对象这一部分的学习笔记。\n<!-- more -->\n# 学习内容\n* 理解并创建对象\n* 理解继承\n# 一、理解对象\n对象本质是一组散列表由key-value值组成。而value可以是数据或者函数。可以使用**对象字面量**方法创建对象。\n```javascript\nvar person = {\n    name: 'superman',\n    age: 29,\n    sayName: function(){\n        alert(this.name);    \n    }\n}\n```\n*对象优化建议：*\n\n* **不使用delete操作符，如需要删除属性，直接对属性进行`null`赋值。因为在FF和chrome中，`null`赋值会快99%。**\n* **不要添加属性。定义好对象后，不要随便给对象添加属性，而是一开始就应该定义好对象的结构。这样的运行速度会快很多（FF快100%，Chrome快89%）。**\n\n# 二、创建对象\n创建对象有以下几种模式：\n* 工厂模式\n* 构造函数模式\n* 原型模式\n* 组合使用构造函数模式和原型模式\n* 动态原型模式\n* 寄生构造函数模式\n* 稳妥构造函数模式\n**要求能熟练掌握每种模式的写法，以及他们之间的区别。**\n## 1、工厂模式\n工厂模式是软件工厂领域一种广为人知的设计模式。特点是抽象了创建具体对象的过程。**工厂模式创建函数的例子**：\n```javascript\n//工厂模式\nfunction createPerson(name,age){\n    var obj = new Object(); //需要显式创建对象，并在最后返回该对象\n    obj.name = name;\n    obj.age = age;\n    obj.sayName = function(){\n            alert(this.name);\n    }\n    return obj; //返回该对象\n}\nvar person = createPerson(); //实例化\n```\n工厂模式解决了创建多个相似对象的问题，却没有解决对象识别的问题(即怎么知道一个对象的类型)。因此出现了构造函数模式。\n## 2、构造函数模式\n就好比Object和Array这种原生的构造函数，可以使用构造函数来创建对象。因此也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。**构造函数模式的例子**：\n```javascript\n//构造函数模式\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.sayName = function(){\n        alert(this.name);\n    }\n}\n//实例化\nvar person = new Person();\n```\n*构造函数与工厂模式的区别*\n* 无需显式创建对象；\n* 没有return语句 ；\n* 直接将属性和方法赋给了this对象。\n\n*使用 `new`调用构造函数会经历以下四个步骤*：\n* 创建一个新对象；\n* 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）\n* 执行构造函数中的代码（为这个新对象添加属性）\n* 返回新对象\n\n*构造函数存在的问题*\n使用构造函数时，每个方法都要在每个实例上重新创建一遍。这样会导致创建了多个完成相同任务的function。没有这个必要。因此有了原型模式来解决构造函数所产生的这些问题。\n## 3、原型模式\n我们创建的每个函数都有一个 `prototype(原型)`属性，这个属性是*一个指针，指向一个对象*，而这个对象的用途是包含可以由特定类型的*所有实例共享的属性和方法*。因此为了解决构造函数模式存在的问题，我们可以将通用的方法添加到prototype中，如下面的例子：\n```javascript\n//原型模式\nfunction Person(){\n}\nPerson.prototype = {\n     name : 'superman',\n     age : 29,\n     sayName : function(){\n        alert(this.name);\n    }     \n}\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.sayName == person2.sayName); // true\n```\n通过原型模式创建的对象，由于`sayName()`函数是加到`Person.prototype`上，所有的Person对象实例的`sayName()`都是共享的，因此都属于同一个实例。\n*原型对象存在的问题*：\n1、它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得相同的值。\n2、最大的问题是由于其共享的本性所导致的。由于原型中的属性都是被实例共享的，在属性为基本值的时候倒不会产生太大的问题。但如果属性是引用类型的时候，问题就凸显了。以下面的例子说明：\n```javascript\nfuntion Person(){\n}\nPerson.prototype = {\n    constructor: Person,\n    name: 'superman',\n    friends: ['superman', 'spiderman'],\n    sayName : function(){\n        alert(this.name);\n    }  \n};\nvar person1 = new Person();\nvar person2 = new Person();\nperson1.friends.push('Van'); //由于friends方法被所有实例共享，因此任何一个实例操作这个方法，都会影响到所有的实例调用这个方法。\nconsole.log(person1.friends);     //superman, spiderman, Van\nconsole.log(person2.friends);     //superman, spiderman, Van\nconsole.log(person1.friends === person2.friends);  // true;\n```\n这就是原型模式最大的问题。任何实例对原型上的方法进行操作都会影响的到所有实例对该方法的调用。\n因此引入了下面的这种模式：**组合使用构造函数模式和原型模式**\n## 4、组合使用构造函数模式和原型模式\n这种模式是创建自定义类型的最常见方式。构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。这样模式的优点便是，每个实例都会有自己的一份**实例属性的副本**，但同时又**共享着对方法的引用**，**最大限度地节省了内存**。同时这种模式还支持向构造函数传递参数，可谓急两种模式之长。如下面例子：\n```javascript\nfuntion Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.friends = [\"a\", \"b\"];\n}\nPerson.prototype = {\n    constructor: person,\n    sayName: function(){\n        alert(this.name);\n}\n}\n```\n这种构造函数和原型混成的模式，是目前使用最广泛的一种创建自定义类型的方法。\n\n## 5、动态原型模式\n所谓动态原型模式就是**把所有的信息都封装在构造函数中，而通过在构造函数中初始化原型**，又保持了同时使用构造函数和原型的优点。如下面例子：\n```javascript\n function Person(name, age){\n    //属性\n    this.name = name;\n    this.age = age;\n    //方法\n    if(typeof this.sayName !=  \"function\"){ //通过判断某个应该存在的方法是否有效，来决定是否需要初始化原型。\n        Person.prototype.sayName = function(){\n            alert(this.name);\n        }\n    }\n}\nvar friend = new Person('Nicholas', 29);\nfriend.sayName();          //Nicholas\n```\n动态原型模式可谓非常完美！仅在方法不存在时，才会将它添加到原型中。\n## 6、寄生构造函数模式\n写法与工厂模式一模一样，区别是在创建实例的时候，是通过`new`来创建，与构造函数的实例对象方法一致。这种模式可以在特殊情况下用来为对象创建构造函数。如下面例子：我们可以创建一个具有额外特殊方法的特殊数组。\n```javascript\nfunctio SpecialArray(){\n    //创建数组\n    var values = new Array();\n    // 添加值\n    values.push.apply(values, arguments);\n    //添加方法\n    values,toPipedString = funtion(){\n        return this.join(\"|\");\n    }\n    return values;\n}\nvar colors = new SpecialArray(\"red\", \"blue\", \"black\");\nalert(colors,toPipedString());    //\"red|blue|green\"\n```\n## 7、稳妥构造函数模式\n所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象。\n稳妥对象适用场景：一些安全环境或者在防止数据被其他应用篡改。如下面例子：\n```javacript\nfunction Person(){   \n    //创建要返回对象\n    var o = new Object();\n    //定义私有变量和函数\n    o.sayName = function(){\n        alert(name);    \n    }\n    return o;\n}\n\nvar person = Person(); //不使用new来实例化对象，跟工厂模式一样\nfriend.sayName();\n```\n\n\n","source":"_posts/javascript-learning-object.md","raw":"---\ntitle: 【JavaScript高程学习笔记】面向对象的程序设计之对象\ndate: 2016-02-26 00:45:53\ntags: \n- JavaScript高级程序设计学习笔记\n- 面向对象\n- 对象\n---\n本篇文章是学习《Javascript高级程序设计》中关于对象这一部分的学习笔记。\n<!-- more -->\n# 学习内容\n* 理解并创建对象\n* 理解继承\n# 一、理解对象\n对象本质是一组散列表由key-value值组成。而value可以是数据或者函数。可以使用**对象字面量**方法创建对象。\n```javascript\nvar person = {\n    name: 'superman',\n    age: 29,\n    sayName: function(){\n        alert(this.name);    \n    }\n}\n```\n*对象优化建议：*\n\n* **不使用delete操作符，如需要删除属性，直接对属性进行`null`赋值。因为在FF和chrome中，`null`赋值会快99%。**\n* **不要添加属性。定义好对象后，不要随便给对象添加属性，而是一开始就应该定义好对象的结构。这样的运行速度会快很多（FF快100%，Chrome快89%）。**\n\n# 二、创建对象\n创建对象有以下几种模式：\n* 工厂模式\n* 构造函数模式\n* 原型模式\n* 组合使用构造函数模式和原型模式\n* 动态原型模式\n* 寄生构造函数模式\n* 稳妥构造函数模式\n**要求能熟练掌握每种模式的写法，以及他们之间的区别。**\n## 1、工厂模式\n工厂模式是软件工厂领域一种广为人知的设计模式。特点是抽象了创建具体对象的过程。**工厂模式创建函数的例子**：\n```javascript\n//工厂模式\nfunction createPerson(name,age){\n    var obj = new Object(); //需要显式创建对象，并在最后返回该对象\n    obj.name = name;\n    obj.age = age;\n    obj.sayName = function(){\n            alert(this.name);\n    }\n    return obj; //返回该对象\n}\nvar person = createPerson(); //实例化\n```\n工厂模式解决了创建多个相似对象的问题，却没有解决对象识别的问题(即怎么知道一个对象的类型)。因此出现了构造函数模式。\n## 2、构造函数模式\n就好比Object和Array这种原生的构造函数，可以使用构造函数来创建对象。因此也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。**构造函数模式的例子**：\n```javascript\n//构造函数模式\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.sayName = function(){\n        alert(this.name);\n    }\n}\n//实例化\nvar person = new Person();\n```\n*构造函数与工厂模式的区别*\n* 无需显式创建对象；\n* 没有return语句 ；\n* 直接将属性和方法赋给了this对象。\n\n*使用 `new`调用构造函数会经历以下四个步骤*：\n* 创建一个新对象；\n* 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）\n* 执行构造函数中的代码（为这个新对象添加属性）\n* 返回新对象\n\n*构造函数存在的问题*\n使用构造函数时，每个方法都要在每个实例上重新创建一遍。这样会导致创建了多个完成相同任务的function。没有这个必要。因此有了原型模式来解决构造函数所产生的这些问题。\n## 3、原型模式\n我们创建的每个函数都有一个 `prototype(原型)`属性，这个属性是*一个指针，指向一个对象*，而这个对象的用途是包含可以由特定类型的*所有实例共享的属性和方法*。因此为了解决构造函数模式存在的问题，我们可以将通用的方法添加到prototype中，如下面的例子：\n```javascript\n//原型模式\nfunction Person(){\n}\nPerson.prototype = {\n     name : 'superman',\n     age : 29,\n     sayName : function(){\n        alert(this.name);\n    }     \n}\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.sayName == person2.sayName); // true\n```\n通过原型模式创建的对象，由于`sayName()`函数是加到`Person.prototype`上，所有的Person对象实例的`sayName()`都是共享的，因此都属于同一个实例。\n*原型对象存在的问题*：\n1、它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得相同的值。\n2、最大的问题是由于其共享的本性所导致的。由于原型中的属性都是被实例共享的，在属性为基本值的时候倒不会产生太大的问题。但如果属性是引用类型的时候，问题就凸显了。以下面的例子说明：\n```javascript\nfuntion Person(){\n}\nPerson.prototype = {\n    constructor: Person,\n    name: 'superman',\n    friends: ['superman', 'spiderman'],\n    sayName : function(){\n        alert(this.name);\n    }  \n};\nvar person1 = new Person();\nvar person2 = new Person();\nperson1.friends.push('Van'); //由于friends方法被所有实例共享，因此任何一个实例操作这个方法，都会影响到所有的实例调用这个方法。\nconsole.log(person1.friends);     //superman, spiderman, Van\nconsole.log(person2.friends);     //superman, spiderman, Van\nconsole.log(person1.friends === person2.friends);  // true;\n```\n这就是原型模式最大的问题。任何实例对原型上的方法进行操作都会影响的到所有实例对该方法的调用。\n因此引入了下面的这种模式：**组合使用构造函数模式和原型模式**\n## 4、组合使用构造函数模式和原型模式\n这种模式是创建自定义类型的最常见方式。构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。这样模式的优点便是，每个实例都会有自己的一份**实例属性的副本**，但同时又**共享着对方法的引用**，**最大限度地节省了内存**。同时这种模式还支持向构造函数传递参数，可谓急两种模式之长。如下面例子：\n```javascript\nfuntion Person(name, age){\n    this.name = name;\n    this.age = age;\n    this.friends = [\"a\", \"b\"];\n}\nPerson.prototype = {\n    constructor: person,\n    sayName: function(){\n        alert(this.name);\n}\n}\n```\n这种构造函数和原型混成的模式，是目前使用最广泛的一种创建自定义类型的方法。\n\n## 5、动态原型模式\n所谓动态原型模式就是**把所有的信息都封装在构造函数中，而通过在构造函数中初始化原型**，又保持了同时使用构造函数和原型的优点。如下面例子：\n```javascript\n function Person(name, age){\n    //属性\n    this.name = name;\n    this.age = age;\n    //方法\n    if(typeof this.sayName !=  \"function\"){ //通过判断某个应该存在的方法是否有效，来决定是否需要初始化原型。\n        Person.prototype.sayName = function(){\n            alert(this.name);\n        }\n    }\n}\nvar friend = new Person('Nicholas', 29);\nfriend.sayName();          //Nicholas\n```\n动态原型模式可谓非常完美！仅在方法不存在时，才会将它添加到原型中。\n## 6、寄生构造函数模式\n写法与工厂模式一模一样，区别是在创建实例的时候，是通过`new`来创建，与构造函数的实例对象方法一致。这种模式可以在特殊情况下用来为对象创建构造函数。如下面例子：我们可以创建一个具有额外特殊方法的特殊数组。\n```javascript\nfunctio SpecialArray(){\n    //创建数组\n    var values = new Array();\n    // 添加值\n    values.push.apply(values, arguments);\n    //添加方法\n    values,toPipedString = funtion(){\n        return this.join(\"|\");\n    }\n    return values;\n}\nvar colors = new SpecialArray(\"red\", \"blue\", \"black\");\nalert(colors,toPipedString());    //\"red|blue|green\"\n```\n## 7、稳妥构造函数模式\n所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象。\n稳妥对象适用场景：一些安全环境或者在防止数据被其他应用篡改。如下面例子：\n```javacript\nfunction Person(){   \n    //创建要返回对象\n    var o = new Object();\n    //定义私有变量和函数\n    o.sayName = function(){\n        alert(name);    \n    }\n    return o;\n}\n\nvar person = Person(); //不使用new来实例化对象，跟工厂模式一样\nfriend.sayName();\n```\n\n\n","slug":"javascript-learning-object","published":1,"updated":"2016-03-05T17:29:59.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c0e000qm0pj3it3bess"},{"title":"【JavaScript高程学习笔记】面向对象的程序设计之继承","date":"2016-03-05T17:27:43.000Z","_content":"本篇文章是学习《Javascript高级程序设计》中关于继承这一部分的学习笔记。\n<!-- more -->\n#继承\n许多OO语言都支持两种继承方式：接口继承和实现继承。而ECMAScript只支持**实现继承**，而且实现继承主要是依靠原型链来实现的。\n## 一、原型链\nECMAScript中继承的基本思想是利用原型让一个引用类型继承另外一个引用类型的属性和方法。\n让我们简单回顾一下原型、构造函数和实例之间的关系。\n每个构造函数都有一个原型对象`Prototype`，原型对象包含一个指向构造函数的指针，即`constructor`属性，这个属性指向的是`prototype`属性所在的函数（构造函数）。而构造函数的实例则包含一个指向原型对象的内部指针。\n那么如果让原型对象等于另一个类型的实例，则此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另外一个构造函数的指针。假如另外一个原型又是另外一个类型的实例，那么上述关系依然成立，如此层层推进，就构成原型链。如下面的例子：\n```javascript\n\tfunction Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n\tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n\n\tfunction Boy(){\n\t\tthis.sex = 'boy';\n\t}\n\tBoy.prototype = new Human();\t//将父类Human的实例赋给子类Boy的原型对象实现继承,子类 Boy就继承了Human以及Animal\n\tvar human = new Human();\n\tvar boy = new Boy();\n\tconsole.log(human)\n\tconsole.log(boy);\t// \n\tboy.run();    \t// I can run\n```\n**1、原型链搜索机制**\n从打印结果，如下图所示，可以看出，Boy的继承原型链，Human->Animal->Object（因为所有的对象都继承于Object）。所以Boy对象在执行run()方法的时候，能输出“I can run”的结果。而boy能找到run方法是基于`原型链搜索机制`。当boy调用run()方法时，首先会先在Boy的实例去寻找该方法或者属性。如果找不到该方法或属性，则会继续搜索实例的原型。如果再找不到，就继续往原型的原型寻找。在找不到的情况下，会一直搜索到原型链的末端才会停止，一般是Object对象。\n\n**2、确定原型和实例的关系**\n有两种方式可以确定原型和实例之间的关系。\n* instanceof操作符\n* isPrototypeOf()方法\n```javascript\n        console.log(boy instanceof Object); //true\n\tconsole.log(boy instanceof Animal); //true\n\tconsole.log(boy instanceof Human); //true\n\n\tconsole.log(Object.prototype.isPrototypeOf(boy)); //true\n\tconsole.log(Animal.prototype.isPrototypeOf(boy)); //true\n\tconsole.log(Human.prototype.isPrototypeOf(boy)); //true\n```\n**3、重写父类方法或者添加新方法**\n如果需要重写父类方法或者添加新方法，一定要放在**替换原型的语句之后**，而且在重写父类方法或者添加新方法的时候，**不能使用对象字面量创建**。因为如果使用对象字面量创建，就相当于重新创建了原型链，会导致原有的原型链失效。\n```javascript\n    function Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n\tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n\n\tHuman.prototype.eat = function(){\t//重写父类方法，语句要放在原型替换之后。\n\t\tconsole.log(\"I can eat override\");\n\t}\n\n\tHuman.prototype.speak = function(){  //添加新方法，且不能使用对象字面量添加方法\n\t\tconsole.log('Human can speak');\n\t}\n\tHuman.prototype = {\t //不能使用对象字面量添加\n\t\tspeak: function(){  \n\t\tconsole.log('Human can speak');\n\t}\n```\n**4、原型链存在的问题**\n跟之前创建对象的原型模式一样，正是由于原型共享被所有实例共享的特性，导致了在听过原型继承的时候，父类的属性是子类的原型，因此所有子类的实例对父类的属性操作时，都会影响到子类所有实例。如下面例子：\n```javascript\n    function Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.gender = [''];\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n    \tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n        var human1 = new Human();\n        var human1 = new Human();\n        human1.gender.push('male');\n        console.log(human2.gender);     //此时输出 male\n```\n这个例子中，human1对父类（即Human的原型）的gender属性添加了一个值“male”,由于原型的共享性，导致了Human的另外一个实例human2调用gender属性输出的值是刚刚human1添加过值的。\n原型链的第二个问题：在创建子类实例的时候，无法在不影响所有子类实例的情况下，向父类的构造函数传递参数。\n## 2、继承的方法\n### 1、借用构造函数\n实现思想：在子类内部调用超类构造函数，使用apply（）和call()\n```\nfunction SuperType(name){\n    this.color = ['red', 'blue', 'white'];\n    this.getName = function(){\n        console.log(name);\n    }\n}\nfunction SubType(){\n    //继承了SuperType\n    SuperType.call(this, 'Superman');\n}\n```\n使用借用构造函数继承可以保证了父类的属性和方法对每个子类而言都是独立的。同时还支持传递参数。\n但是该方法依然存在着问题，由于是通过在子类内部实例化父类构造函数的方式来实现继承，应该函数的复用就无从谈起。而且在父类原型中定义的方法，对于子类而言也是不可见的，结果导致所有类型都只能使用构造函数模式。因此很少单独使用借用构造函数模式。\n\n### 2、组合继承\n组合继承也称伪经典继承，是将借用构造函数和原型链的技术组合到一块。这种方式是最常用的继承模式。\n实现思路：使用原型链对**原型属性**和**原型方法**的继承，而通过借用构造函数来实现对**实例属性**的继承。如下面例子\n```javascript\nfunction SuperType(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n}\nfunction SubType(name, age){\n    SuperType.call(this, name);\n    this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType();\n\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n}\nvar sub1 = new SubType('superman1', '1');\nvar sub2 = new SubType('superman2', '2');\nsub1.colors.push('black');\nconsole.log(sub1.colors);    // ['red', 'blue', 'green', 'black']\nsub1.sayName();    //superman1\n\nsub2.colors.push('green');\nconsole.log(sub2.colors);    // ['red', 'blue', 'green', 'green']\nsub2.sayName();    //superman2\n```\n通过这种方式，即可以让子类的实例分别拥有自己的属性，又可以使用同样的方法。\n### 3、原型式继承\n实现思路：借助原型可以基于已有的对象创建新对象。如下面例子：\n```javascript\nfunction object(o){\n    function F(){\n        F.prototype = o;\n        return new F();\n    }\n}\nvar person = {\n    name: 'superman',\n    age: 22,\n    friends: ['1', '2', '3', '4']\n}\nvar anotherPerson = object(person);\n```\n### 4、寄生式继承\n### 5、寄生组合式继承\n\n\n","source":"_posts/javascript-inherit.md","raw":"---\ntitle: 【JavaScript高程学习笔记】面向对象的程序设计之继承\ndate: 2016-03-06 01:27:43\ntags:\n- JavaScript高级程序设计学习笔记\n- 面向对象\n- 继承\n---\n本篇文章是学习《Javascript高级程序设计》中关于继承这一部分的学习笔记。\n<!-- more -->\n#继承\n许多OO语言都支持两种继承方式：接口继承和实现继承。而ECMAScript只支持**实现继承**，而且实现继承主要是依靠原型链来实现的。\n## 一、原型链\nECMAScript中继承的基本思想是利用原型让一个引用类型继承另外一个引用类型的属性和方法。\n让我们简单回顾一下原型、构造函数和实例之间的关系。\n每个构造函数都有一个原型对象`Prototype`，原型对象包含一个指向构造函数的指针，即`constructor`属性，这个属性指向的是`prototype`属性所在的函数（构造函数）。而构造函数的实例则包含一个指向原型对象的内部指针。\n那么如果让原型对象等于另一个类型的实例，则此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另外一个构造函数的指针。假如另外一个原型又是另外一个类型的实例，那么上述关系依然成立，如此层层推进，就构成原型链。如下面的例子：\n```javascript\n\tfunction Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n\tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n\n\tfunction Boy(){\n\t\tthis.sex = 'boy';\n\t}\n\tBoy.prototype = new Human();\t//将父类Human的实例赋给子类Boy的原型对象实现继承,子类 Boy就继承了Human以及Animal\n\tvar human = new Human();\n\tvar boy = new Boy();\n\tconsole.log(human)\n\tconsole.log(boy);\t// \n\tboy.run();    \t// I can run\n```\n**1、原型链搜索机制**\n从打印结果，如下图所示，可以看出，Boy的继承原型链，Human->Animal->Object（因为所有的对象都继承于Object）。所以Boy对象在执行run()方法的时候，能输出“I can run”的结果。而boy能找到run方法是基于`原型链搜索机制`。当boy调用run()方法时，首先会先在Boy的实例去寻找该方法或者属性。如果找不到该方法或属性，则会继续搜索实例的原型。如果再找不到，就继续往原型的原型寻找。在找不到的情况下，会一直搜索到原型链的末端才会停止，一般是Object对象。\n\n**2、确定原型和实例的关系**\n有两种方式可以确定原型和实例之间的关系。\n* instanceof操作符\n* isPrototypeOf()方法\n```javascript\n        console.log(boy instanceof Object); //true\n\tconsole.log(boy instanceof Animal); //true\n\tconsole.log(boy instanceof Human); //true\n\n\tconsole.log(Object.prototype.isPrototypeOf(boy)); //true\n\tconsole.log(Animal.prototype.isPrototypeOf(boy)); //true\n\tconsole.log(Human.prototype.isPrototypeOf(boy)); //true\n```\n**3、重写父类方法或者添加新方法**\n如果需要重写父类方法或者添加新方法，一定要放在**替换原型的语句之后**，而且在重写父类方法或者添加新方法的时候，**不能使用对象字面量创建**。因为如果使用对象字面量创建，就相当于重新创建了原型链，会导致原有的原型链失效。\n```javascript\n    function Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n\tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n\n\tHuman.prototype.eat = function(){\t//重写父类方法，语句要放在原型替换之后。\n\t\tconsole.log(\"I can eat override\");\n\t}\n\n\tHuman.prototype.speak = function(){  //添加新方法，且不能使用对象字面量添加方法\n\t\tconsole.log('Human can speak');\n\t}\n\tHuman.prototype = {\t //不能使用对象字面量添加\n\t\tspeak: function(){  \n\t\tconsole.log('Human can speak');\n\t}\n```\n**4、原型链存在的问题**\n跟之前创建对象的原型模式一样，正是由于原型共享被所有实例共享的特性，导致了在听过原型继承的时候，父类的属性是子类的原型，因此所有子类的实例对父类的属性操作时，都会影响到子类所有实例。如下面例子：\n```javascript\n    function Animal(){ //采用构造函数模式创建对象\n\t\tthis.live = true;\n\t\tthis.gender = [''];\n\t\tthis.run = function(){\n\t\t\tconsole.log('I can run');\n\t\t}\n\t}\n    \tAnimal.prototype = {\n\t\tconstructor: Animal,\n\t\teat: function(){\n\t\t\tconsole.log('I can eat');\n\t\t}\n\t}\n\tfunction Human(){\n\t\tthis.isHuman = true;\n\t}\n\tHuman.prototype = new Animal(); //将父类Animal的实例赋给子类Human的原型对象实现继承\n        var human1 = new Human();\n        var human1 = new Human();\n        human1.gender.push('male');\n        console.log(human2.gender);     //此时输出 male\n```\n这个例子中，human1对父类（即Human的原型）的gender属性添加了一个值“male”,由于原型的共享性，导致了Human的另外一个实例human2调用gender属性输出的值是刚刚human1添加过值的。\n原型链的第二个问题：在创建子类实例的时候，无法在不影响所有子类实例的情况下，向父类的构造函数传递参数。\n## 2、继承的方法\n### 1、借用构造函数\n实现思想：在子类内部调用超类构造函数，使用apply（）和call()\n```\nfunction SuperType(name){\n    this.color = ['red', 'blue', 'white'];\n    this.getName = function(){\n        console.log(name);\n    }\n}\nfunction SubType(){\n    //继承了SuperType\n    SuperType.call(this, 'Superman');\n}\n```\n使用借用构造函数继承可以保证了父类的属性和方法对每个子类而言都是独立的。同时还支持传递参数。\n但是该方法依然存在着问题，由于是通过在子类内部实例化父类构造函数的方式来实现继承，应该函数的复用就无从谈起。而且在父类原型中定义的方法，对于子类而言也是不可见的，结果导致所有类型都只能使用构造函数模式。因此很少单独使用借用构造函数模式。\n\n### 2、组合继承\n组合继承也称伪经典继承，是将借用构造函数和原型链的技术组合到一块。这种方式是最常用的继承模式。\n实现思路：使用原型链对**原型属性**和**原型方法**的继承，而通过借用构造函数来实现对**实例属性**的继承。如下面例子\n```javascript\nfunction SuperType(name){\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n}\nfunction SubType(name, age){\n    SuperType.call(this, name);\n    this.age = age;\n}\n//继承方法\nSubType.prototype = new SuperType();\n\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n}\nvar sub1 = new SubType('superman1', '1');\nvar sub2 = new SubType('superman2', '2');\nsub1.colors.push('black');\nconsole.log(sub1.colors);    // ['red', 'blue', 'green', 'black']\nsub1.sayName();    //superman1\n\nsub2.colors.push('green');\nconsole.log(sub2.colors);    // ['red', 'blue', 'green', 'green']\nsub2.sayName();    //superman2\n```\n通过这种方式，即可以让子类的实例分别拥有自己的属性，又可以使用同样的方法。\n### 3、原型式继承\n实现思路：借助原型可以基于已有的对象创建新对象。如下面例子：\n```javascript\nfunction object(o){\n    function F(){\n        F.prototype = o;\n        return new F();\n    }\n}\nvar person = {\n    name: 'superman',\n    age: 22,\n    friends: ['1', '2', '3', '4']\n}\nvar anotherPerson = object(person);\n```\n### 4、寄生式继承\n### 5、寄生组合式继承\n\n\n","slug":"javascript-inherit","published":1,"updated":"2016-03-05T17:31:04.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c0k000xm0pjrsdrdct0"},{"title":"深入理解变量声明提升和函数声明提升","date":"2016-03-05T07:08:35.000Z","_content":"最近做题目遇到了关于变量声明提升和函数声明提升的知识点，觉得掌握得不是非常好，因此特地又翻开了犀牛书，重新深入学习，并整理成文章。\n<!-- more -->\n# 变量声明提升\n## 1、变量定义\n可以使用var定义变量，变量如果没有赋值，那变量的初始值为`undefined`。\n## 2、变量作用域\n变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数内有效。\n在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。\n**所有不使用var定义的变量都视为全局变量**\n## 3、函数作用域和声明提前\nJavaScript的函数作用是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说**变量在声明之前已经可用**，所有这特性称为`声明提前（hoisting）`，即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。如下面例子：\n_注释：`声明提前`是在JavaScript引擎的预编译时进行，是在代码开始运行之前。_\n```javascript\nvar scope = 'global';\nfunction f(){\n    console.log(scope);\n    var scope = 'local';\n    console.log('scope');\n}\n```\n由于函数内声明提升，所以上面的代码实际上是这样的\n```javascript\nvar scope = 'global';\nfunction f(){\n    var scope;    //变量声明提升到函数顶部\n    console.log(scope);\n    scope = 'local';    //变量初始化依然保留在原来的位置\n    console.log(scope);\n}\n```\n经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是`undefined`.第二个console.log(scope)语句之前，scope已经完成赋值为'local'，所以输出的结果是`local`。\n\n# 函数声明提升\n## 1、函数的两种创建方式\n* 函数声明\n* 函数表达式\n\n**函数声明语法**\n```javascript\nf('superman');\nfunction f(name){\n    console.log(name);\n}\n```\n运行上面的程序，控制台能打印出`supemran`。\n**函数表达式语法**\n```javascript\nf('superman');\nvar f= function(name){\n    console.log(name);\n}\n```\n\n运行上面的代码，会报错`Uncaught ReferenceError: f is not defined(…)`,错误信息显示说f没有被定义。\n 为什么同样的代码，函数声明和函数表达式存在着差异呢？\n这是因为，函数声明有一个非常重要的特征：`函数声明提升`，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（是不是跟变量提升非常类似）。正是因为这个特征，所以可以把函数声明放在调用它的语句后面。如下面例子，最终的输出结果应该是什么？：\n```javascript    \nvar getName = function(){\n    console.log(2);\n}\nfunction getName (){\n    console.log(1);\n}\ngetName();\n```\n可能会有人觉得最后输出的结果是`1`。让我们来分析一下，这个例子涉及到了`变量声明提升`和`函数声明提升`。正如前面说到的函数声明提升，函数声明`function getName(){}`的声明会被提前到顶部。而函数表达式`var getName = function(){}`则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。需要注意的是，**函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。**因此上面的函数可以转换成下面的样子:\n```javascript\nfunction getName(){    //函数声明提升到顶部\n    console.log(1);\n}\nvar getName;    //变量声明提升\n\ngetName = function(){    //变量赋值依然保留在原来的位置\n    console.log(2);\n}\ngetName();    // 最终输出：2\n```\n所以最终的输出结果是：`2`。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出`2`。\n\n\n\n\n\n\n\n\n\n","source":"_posts/javascript-hoisting.md","raw":"---\ntitle: 深入理解变量声明提升和函数声明提升\ndate: 2016-03-05 15:08:35\ntags:\n- JavaScript学习笔记\n---\n最近做题目遇到了关于变量声明提升和函数声明提升的知识点，觉得掌握得不是非常好，因此特地又翻开了犀牛书，重新深入学习，并整理成文章。\n<!-- more -->\n# 变量声明提升\n## 1、变量定义\n可以使用var定义变量，变量如果没有赋值，那变量的初始值为`undefined`。\n## 2、变量作用域\n变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数内有效。\n在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。\n**所有不使用var定义的变量都视为全局变量**\n## 3、函数作用域和声明提前\nJavaScript的函数作用是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说**变量在声明之前已经可用**，所有这特性称为`声明提前（hoisting）`，即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。如下面例子：\n_注释：`声明提前`是在JavaScript引擎的预编译时进行，是在代码开始运行之前。_\n```javascript\nvar scope = 'global';\nfunction f(){\n    console.log(scope);\n    var scope = 'local';\n    console.log('scope');\n}\n```\n由于函数内声明提升，所以上面的代码实际上是这样的\n```javascript\nvar scope = 'global';\nfunction f(){\n    var scope;    //变量声明提升到函数顶部\n    console.log(scope);\n    scope = 'local';    //变量初始化依然保留在原来的位置\n    console.log(scope);\n}\n```\n经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是`undefined`.第二个console.log(scope)语句之前，scope已经完成赋值为'local'，所以输出的结果是`local`。\n\n# 函数声明提升\n## 1、函数的两种创建方式\n* 函数声明\n* 函数表达式\n\n**函数声明语法**\n```javascript\nf('superman');\nfunction f(name){\n    console.log(name);\n}\n```\n运行上面的程序，控制台能打印出`supemran`。\n**函数表达式语法**\n```javascript\nf('superman');\nvar f= function(name){\n    console.log(name);\n}\n```\n\n运行上面的代码，会报错`Uncaught ReferenceError: f is not defined(…)`,错误信息显示说f没有被定义。\n 为什么同样的代码，函数声明和函数表达式存在着差异呢？\n这是因为，函数声明有一个非常重要的特征：`函数声明提升`，函数声明语句将会被提升到外部脚本或者外部函数作用域的顶部（是不是跟变量提升非常类似）。正是因为这个特征，所以可以把函数声明放在调用它的语句后面。如下面例子，最终的输出结果应该是什么？：\n```javascript    \nvar getName = function(){\n    console.log(2);\n}\nfunction getName (){\n    console.log(1);\n}\ngetName();\n```\n可能会有人觉得最后输出的结果是`1`。让我们来分析一下，这个例子涉及到了`变量声明提升`和`函数声明提升`。正如前面说到的函数声明提升，函数声明`function getName(){}`的声明会被提前到顶部。而函数表达式`var getName = function(){}`则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。需要注意的是，**函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。**因此上面的函数可以转换成下面的样子:\n```javascript\nfunction getName(){    //函数声明提升到顶部\n    console.log(1);\n}\nvar getName;    //变量声明提升\n\ngetName = function(){    //变量赋值依然保留在原来的位置\n    console.log(2);\n}\ngetName();    // 最终输出：2\n```\n所以最终的输出结果是：`2`。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出`2`。\n\n\n\n\n\n\n\n\n\n","slug":"javascript-hoisting","published":1,"updated":"2016-03-12T15:50:41.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c0r0012m0pjlfuu4cwh"},{"title":"【读书笔记】JavaScript闭包的理解","date":"2016-03-19T16:41:34.000Z","_content":"以前一直都不能完全理解闭包的概念，于是就专门学习了下闭包，整理成这篇文章。\n<!-- more -->\n在学习JavaScript中，有一个概念一直困扰着我，它就是**闭包**。今天就彻底学习学习什么是闭包。\n参考资料：\n阮一峰老师的闭包教程: http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n# 为什么会有闭包？\n由于JavaScript的变量作用域的特点，函数内部作用域可以访问外部作用域的变量，而外部作用域却无权访问内部作用域的局部变量。那如果我们想要在函数作用域外访问到函数内部的变量时，该怎么办。\n因此解决的办法就是在函数的内部再创建一个函数，这样就可以在内部函数中访问函数的内部变量，这时候再将内部函数作为返回值的话，那么就可以在函数外去访问到函数的内部变量。这就是**函数的闭包**。\n# 什么是闭包？\n先来看看对于函数的闭包，经典的书籍都是怎么定义的：\n**闭包是指有权访问另外一个函数作用域中的变量的函数。**-----《JavaScript高级程序设计（第3版）》\n**函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中被称为闭包。**-----《JavaScript权威指南（第6版）》\n**当函数可以记住并访问所有的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。**-----《你不知道的JavaScript（上）》\n发现了没有，上面三个关于**闭包**虽然描述的方式不同，但是对闭包定义的本质是相同的：**闭包就是能够读取其他函数内部变量的函数**。\n阮老师将定义更加简洁得定义为：**定义在一个函数内部的函数**（由于在JavaScript中，只有函数内部的子函数才可以读取函数内部的变量）。\n先来看一个简单的例子，清晰地展示了闭包：\n```javascript\nfunction foo(){\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    return bar;\n}\nvar baz = foo();\nbaz.bar();    //2 ——这就是闭包的效果，在foo()函数作用域却能访问到函数内部变量a的值\n```\n# 闭包有什么用途\n1. 匿名自执行函数\n2. 缓存\n3. 实现封装\n4. 实现面向对象中的对象\n\n_关于闭包的用途，下一篇文章将详细介绍。_\n# 闭包注意事项\n## 1、闭包性能问题 \n由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能导致内存占用过多。\n虽然V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存。但也应避免大量使用闭包。\n## 2、闭包与变量\nJavaScript作用域导致了一个副作用，即闭包只能取得包含函数中的任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。如下面的例子：\n```javascript\nfunction createFunctions(){\n\tvar result = new Array();\n\tfor(var i = 0; i< 10; i ++){\n\t\tresult[i] = function(){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn result;\n}\nconsole.log(createFunctions()[1]());    //10，其实数组的每个值都是输出10\n```\n这个函数返回了一个数组，从表面上看，每个函数都应该返回自己的索引值，但实际上却是每个函数都返回了10。这是为什么呢？\n因为每个函数的作用域链中都包含着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用这保存变量i的统一变量对象，所以每个函数内部i的值都是10。\n我们可以通过创建另外一个匿名函数来解决这个问题，如下所示\n```javascript\nfunction createFunctions() {\n    var result = new Array();\n    for (var i = 0; i < 10; i++) {\n        result[i] = function(num) {\n            return function(){\n            \treturn num;\n            };\n        }(i);\n    }\n    return result;\n}\n```\n改进之后，我们并没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该函数的结果赋值给数组。而这个匿名函数有一个参数，也就是最终函数要返回的值。在调用每个匿名函数时，我们传入变量i。在这个匿名函数内部，又创建并返回了一个访问num的闭包，这样一来，result数组中的每个函数都有自己的num变量的一个副本，因此就可以各自不同的值。\n## 3、闭包与this对象\n我们都知道`this`对象是基于函数运行时的执行环境绑定的，在全局函数中，`this`等于`window`。但是在匿名函数中，其执行环境具有全局局限性，因此'this'通常指的是'window'。来比较下下面两个例子：\n```javascript\nvar name = 'The window';\nvar object = {\n    name: 'My Object',\n    getNameFunc: function() {\n        return function() {\n            return this.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()()); //The window\n```\n```javascript\nvar name = 'The window';\nvar object = {\n    name: 'My Object',\n    getNameFunc: function() {\n        var self = this;\n        return function() {\n            return self.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()()); //My Object\n```\n\n# 闭包小测\n\n```javascript\n    function fun(n, o) {\n        console.log(o);\n        return {\n            fun: function(m) {\n                return fun(m, n);\n            }\n        };\n    }\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n问着三行，a、b、c分别输出什么\n```\n答案请[猛戳](http://www.cnblogs.com/xxcanghai/p/4991870.html)\n参考资料：大部分人都会做错的经典JS闭包面试题 http://www.cnblogs.com/xxcanghai/p/4991870.html\n\n\n\n","source":"_posts/javascript-closure.md","raw":"---\ntitle: 【读书笔记】JavaScript闭包的理解\ndate: 2016-03-20 00:41:34\ntags:\n- JavaScript学习笔记\n---\n以前一直都不能完全理解闭包的概念，于是就专门学习了下闭包，整理成这篇文章。\n<!-- more -->\n在学习JavaScript中，有一个概念一直困扰着我，它就是**闭包**。今天就彻底学习学习什么是闭包。\n参考资料：\n阮一峰老师的闭包教程: http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n# 为什么会有闭包？\n由于JavaScript的变量作用域的特点，函数内部作用域可以访问外部作用域的变量，而外部作用域却无权访问内部作用域的局部变量。那如果我们想要在函数作用域外访问到函数内部的变量时，该怎么办。\n因此解决的办法就是在函数的内部再创建一个函数，这样就可以在内部函数中访问函数的内部变量，这时候再将内部函数作为返回值的话，那么就可以在函数外去访问到函数的内部变量。这就是**函数的闭包**。\n# 什么是闭包？\n先来看看对于函数的闭包，经典的书籍都是怎么定义的：\n**闭包是指有权访问另外一个函数作用域中的变量的函数。**-----《JavaScript高级程序设计（第3版）》\n**函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中被称为闭包。**-----《JavaScript权威指南（第6版）》\n**当函数可以记住并访问所有的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。**-----《你不知道的JavaScript（上）》\n发现了没有，上面三个关于**闭包**虽然描述的方式不同，但是对闭包定义的本质是相同的：**闭包就是能够读取其他函数内部变量的函数**。\n阮老师将定义更加简洁得定义为：**定义在一个函数内部的函数**（由于在JavaScript中，只有函数内部的子函数才可以读取函数内部的变量）。\n先来看一个简单的例子，清晰地展示了闭包：\n```javascript\nfunction foo(){\n    var a = 2;\n    function bar(){\n        console.log(a);\n    }\n    return bar;\n}\nvar baz = foo();\nbaz.bar();    //2 ——这就是闭包的效果，在foo()函数作用域却能访问到函数内部变量a的值\n```\n# 闭包有什么用途\n1. 匿名自执行函数\n2. 缓存\n3. 实现封装\n4. 实现面向对象中的对象\n\n_关于闭包的用途，下一篇文章将详细介绍。_\n# 闭包注意事项\n## 1、闭包性能问题 \n由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能导致内存占用过多。\n虽然V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存。但也应避免大量使用闭包。\n## 2、闭包与变量\nJavaScript作用域导致了一个副作用，即闭包只能取得包含函数中的任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。如下面的例子：\n```javascript\nfunction createFunctions(){\n\tvar result = new Array();\n\tfor(var i = 0; i< 10; i ++){\n\t\tresult[i] = function(){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn result;\n}\nconsole.log(createFunctions()[1]());    //10，其实数组的每个值都是输出10\n```\n这个函数返回了一个数组，从表面上看，每个函数都应该返回自己的索引值，但实际上却是每个函数都返回了10。这是为什么呢？\n因为每个函数的作用域链中都包含着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用这保存变量i的统一变量对象，所以每个函数内部i的值都是10。\n我们可以通过创建另外一个匿名函数来解决这个问题，如下所示\n```javascript\nfunction createFunctions() {\n    var result = new Array();\n    for (var i = 0; i < 10; i++) {\n        result[i] = function(num) {\n            return function(){\n            \treturn num;\n            };\n        }(i);\n    }\n    return result;\n}\n```\n改进之后，我们并没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该函数的结果赋值给数组。而这个匿名函数有一个参数，也就是最终函数要返回的值。在调用每个匿名函数时，我们传入变量i。在这个匿名函数内部，又创建并返回了一个访问num的闭包，这样一来，result数组中的每个函数都有自己的num变量的一个副本，因此就可以各自不同的值。\n## 3、闭包与this对象\n我们都知道`this`对象是基于函数运行时的执行环境绑定的，在全局函数中，`this`等于`window`。但是在匿名函数中，其执行环境具有全局局限性，因此'this'通常指的是'window'。来比较下下面两个例子：\n```javascript\nvar name = 'The window';\nvar object = {\n    name: 'My Object',\n    getNameFunc: function() {\n        return function() {\n            return this.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()()); //The window\n```\n```javascript\nvar name = 'The window';\nvar object = {\n    name: 'My Object',\n    getNameFunc: function() {\n        var self = this;\n        return function() {\n            return self.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()()); //My Object\n```\n\n# 闭包小测\n\n```javascript\n    function fun(n, o) {\n        console.log(o);\n        return {\n            fun: function(m) {\n                return fun(m, n);\n            }\n        };\n    }\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n问着三行，a、b、c分别输出什么\n```\n答案请[猛戳](http://www.cnblogs.com/xxcanghai/p/4991870.html)\n参考资料：大部分人都会做错的经典JS闭包面试题 http://www.cnblogs.com/xxcanghai/p/4991870.html\n\n\n\n","slug":"javascript-closure","published":1,"updated":"2016-03-19T16:43:27.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c0v0014m0pjjkomp3o2"},{"title":"Hexo博客搭建教程（四）：Hexo优化与个性化","date":"2016-02-23T14:24:11.000Z","_content":"前面的文章介绍了如何打造一个属于自己的博客。但是这个博客还只是拥有基本的功能。对于一个站点而言，我们还需要很多功能来完善它，比如需要网站访问统计数据，网站评论功能等。这篇文章将从以下几个方面介绍如何自定义你的博客。\n* 添加统计代码\n* 添加多说评论功能\n<!-- more -->\n# 添加统计代码\n无数据，不运营。对于一个站点而言，网站的访问数据十分重要，数据分析是网站运营的一部分。虽然这只是一个博客，但我们也可以将其当做一个网站来运营。\n要想统计网站的访问数据，一般通过第三方数据分析网站，添加相应的统计代码来进行数据统计。由于google analytics会出现被墙的原因以及统计数据不够及时（一般需要第二天才能看到报表），因此我采用了[CNZZ数据专家](http://www.cnzz.com/)的数据统计功能。（至于为啥不用百度统计，由于百度全家桶实在是呵呵。。。）。\n## 获得CNZZ统计代码\n没有账号的自行去注册。注册完，填写你的博客站点信息之后，拿到CNZZ提供的统计代码。\n## 编辑 `themes/yilia/_config.yml`文件\n```yml\ncnzz_tongji: true  # 开启cnzz统计\ngoogle_analytics: ''\n```\n## 新建`cnzz_tongji.ejs`文件\n在`themes/yilia/layout/_partial/`文件夹下新建文件`cnzz_tongji.ejs`，文件内容如下:\n```ejs\n<% if(theme.cnzz_tongji) {%>\n\t<script type=\"text/javascript\"> \n\t//cnzz analytics code\n\t</script>\n<%}%>\n```\n## 将`cnzz_tongji.ejs`添加到`head.ejs`\n打开位于`themes/yilia/layout/_partial/`文件夹下的`head.ejs`，在`</head>`之前添加以下代码，将统计代码添加到页面中\n```ejs\n<%- partial/cnzz_tongji%>\n```\n添加后便可以去[CNZZ数据专家](http://www.cnzz.com/)查看博客的访问数据统计了。\n\n# 添加多说评论功能\n##登录多说，获取key，并将key添加到配置文件中\n如下图：箭头所指的就是你的多说的key(注意:后面的.duoshuo.com不需要)\n![](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_duoshuo_example.png)\n将你的域名填写到`themes/yilia/_config.yml`中\n```\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: your-key\n```","source":"_posts/hexo-guide-4.md","raw":"---\ntitle: Hexo博客搭建教程（四）：Hexo优化与个性化\ndate: 2016-02-23 22:24:11\ntags: Hexo\n---\n前面的文章介绍了如何打造一个属于自己的博客。但是这个博客还只是拥有基本的功能。对于一个站点而言，我们还需要很多功能来完善它，比如需要网站访问统计数据，网站评论功能等。这篇文章将从以下几个方面介绍如何自定义你的博客。\n* 添加统计代码\n* 添加多说评论功能\n<!-- more -->\n# 添加统计代码\n无数据，不运营。对于一个站点而言，网站的访问数据十分重要，数据分析是网站运营的一部分。虽然这只是一个博客，但我们也可以将其当做一个网站来运营。\n要想统计网站的访问数据，一般通过第三方数据分析网站，添加相应的统计代码来进行数据统计。由于google analytics会出现被墙的原因以及统计数据不够及时（一般需要第二天才能看到报表），因此我采用了[CNZZ数据专家](http://www.cnzz.com/)的数据统计功能。（至于为啥不用百度统计，由于百度全家桶实在是呵呵。。。）。\n## 获得CNZZ统计代码\n没有账号的自行去注册。注册完，填写你的博客站点信息之后，拿到CNZZ提供的统计代码。\n## 编辑 `themes/yilia/_config.yml`文件\n```yml\ncnzz_tongji: true  # 开启cnzz统计\ngoogle_analytics: ''\n```\n## 新建`cnzz_tongji.ejs`文件\n在`themes/yilia/layout/_partial/`文件夹下新建文件`cnzz_tongji.ejs`，文件内容如下:\n```ejs\n<% if(theme.cnzz_tongji) {%>\n\t<script type=\"text/javascript\"> \n\t//cnzz analytics code\n\t</script>\n<%}%>\n```\n## 将`cnzz_tongji.ejs`添加到`head.ejs`\n打开位于`themes/yilia/layout/_partial/`文件夹下的`head.ejs`，在`</head>`之前添加以下代码，将统计代码添加到页面中\n```ejs\n<%- partial/cnzz_tongji%>\n```\n添加后便可以去[CNZZ数据专家](http://www.cnzz.com/)查看博客的访问数据统计了。\n\n# 添加多说评论功能\n##登录多说，获取key，并将key添加到配置文件中\n如下图：箭头所指的就是你的多说的key(注意:后面的.duoshuo.com不需要)\n![](http://7xr6yj.com1.z0.glb.clouddn.com/hexo_duoshuo_example.png)\n将你的域名填写到`themes/yilia/_config.yml`中\n```\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: your-key\n```","slug":"hexo-guide-4","published":1,"updated":"2016-03-19T06:55:26.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c0y0016m0pjx8b5vtke"},{"title":"Hexo博客搭建教程（三）：Hexo博客代码版本控制","date":"2016-02-22T14:03:43.000Z","_content":"由于Hexo只会将生成后的public文件夹部署到github上，导致无法对博客进行代码版本控制。同时如果需要备份代码的话，只能通过其他手段来实现。\n本文介绍了如何利用github分支对代码进行版本控制，同时起到备份代码的作用。\n<!-- more -->\n# 解决思路\n实现Hexo博客代码版本控制以及备份的思路如下：\n通过新建一个`source`分支用于专门存放hexo代码。原先的`master`分支依然不变，作为hexo 部署的分支。\n每次在部署后，再把代码提交到`source`分支。\n# 实现步骤\n## 1、本地创建git 仓库\n```bash\ngit init\n```\n## 2、添加远程库\n```bash\ngit remote add origin <git repository url>\n```\n## 3、创建source分支\n```bash\ngit checkout -b source\n```\n## 4、提交文件及分支，并push到远程仓库\n```bash\ngit add *\ngit commit -m 'message'\ngit push origin source \n```\n其中`source`为分支名称。\n\n这样就建立了代码版本控制分支。之后只要将博客在部署到github之后，将代码push到`source`分支上。代码如下：\n```bash\ngit add *\ngit commit -m \"udpate site\"\ngit push origin source\n```\n# 问题记录\n如果你使用了第三方主题，在进行代码提交的时候，是无法将第三方主题提交到你的github repository中，会出现 `untracked content`的提示。\n这是因为第三方主题本身也是一个git项目。你无法将别人的git项目直接通过add 和commit的方式提交到你自己的git repository。\n也就说，你无法提交处于 `untracked`状态的文件。\n解决办法：\n* 添加 `submodule`的方式，将主题作为submodule提交到你的git repository\n* 删除主题文件夹下的`.git`文件夹。如果这时候还不能提交，可以新建个文件夹，随便命名，将主题文件夹内的东西复制到新建的文件夹。再通过`git add`提交就可以了。","source":"_posts/hexo-guide-3.md","raw":"---\ntitle: Hexo博客搭建教程（三）：Hexo博客代码版本控制\ndate: 2016-02-22 22:03:43\ntags: Hexo\n---\n由于Hexo只会将生成后的public文件夹部署到github上，导致无法对博客进行代码版本控制。同时如果需要备份代码的话，只能通过其他手段来实现。\n本文介绍了如何利用github分支对代码进行版本控制，同时起到备份代码的作用。\n<!-- more -->\n# 解决思路\n实现Hexo博客代码版本控制以及备份的思路如下：\n通过新建一个`source`分支用于专门存放hexo代码。原先的`master`分支依然不变，作为hexo 部署的分支。\n每次在部署后，再把代码提交到`source`分支。\n# 实现步骤\n## 1、本地创建git 仓库\n```bash\ngit init\n```\n## 2、添加远程库\n```bash\ngit remote add origin <git repository url>\n```\n## 3、创建source分支\n```bash\ngit checkout -b source\n```\n## 4、提交文件及分支，并push到远程仓库\n```bash\ngit add *\ngit commit -m 'message'\ngit push origin source \n```\n其中`source`为分支名称。\n\n这样就建立了代码版本控制分支。之后只要将博客在部署到github之后，将代码push到`source`分支上。代码如下：\n```bash\ngit add *\ngit commit -m \"udpate site\"\ngit push origin source\n```\n# 问题记录\n如果你使用了第三方主题，在进行代码提交的时候，是无法将第三方主题提交到你的github repository中，会出现 `untracked content`的提示。\n这是因为第三方主题本身也是一个git项目。你无法将别人的git项目直接通过add 和commit的方式提交到你自己的git repository。\n也就说，你无法提交处于 `untracked`状态的文件。\n解决办法：\n* 添加 `submodule`的方式，将主题作为submodule提交到你的git repository\n* 删除主题文件夹下的`.git`文件夹。如果这时候还不能提交，可以新建个文件夹，随便命名，将主题文件夹内的东西复制到新建的文件夹。再通过`git add`提交就可以了。","slug":"hexo-guide-3","published":1,"updated":"2016-02-23T15:24:06.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c120019m0pjezvate2x"},{"title":"Hexo博客搭建教程（二）：Hexo博客的配置、使用","date":"2016-02-21T14:41:24.000Z","_content":"本文主要介绍如何对Hexo博客站点进行个性化的设置、如何安装主题以及主题的设置。\n\n<!-- more -->\n经过上一篇文章，我们已经学会如何搭建Hexo博客以及将博客部署到github上了。这篇文章主要讲如何对自己的博客站点进行个性化配置以及如何发表新文章。\n博客的配置一个是站点的配置:`d:\\hexo\\_config.yml`，一个是主题的配置:`d:\\hexo\\themes\\yilia\\_config.yml`\n## 站点的配置\n```yml\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Superman的博客 #站定的名称\nsubtitle: 超人不会飞 #站点的副标题\ndescription: 超人前端学习博客 #站点的描述\nauthor: Superman \nemail: supermanchc@gmail.com\nlanguage: zh-Hans # 语言 使用中文需要使用zh-Hans\ntimezone:  #默认操作系统的时间\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n##url 在没有绑定域名前，不需要填写\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory 目录格式，不修改\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 写作布局，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Extensions 配置主题\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n\n# Deployment 配置部署github站点，改为自己的github repository\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/superman66/superman66.github.io.git\n  branch: master\n```\n## 安装新主题\nHexo此时用的是默认的主题，如果需要更换主题，可以去[主题市场](https://github.com/tommy351/hexo/wiki/Themes)挑选自己喜爱的主题。这里以安装`yilia`主题为例。\n#### 安装\n\n``` bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n#### 配置\n\n修改hexo根目录下 `_config.yml` 的themes: \n```yml\n# Extensions 配置主题\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n```\n\n#### 更新\n\n``` bash\ncd themes/yilia\ngit pull\n```\n## 配置主题\n这样就为你的博客站点安装了新的主题。接下来对主题进行配置\n主题配置文件在主目录下的`_config.yml`：\n```\n# Header\nmenu:\n  主页: /\n  所有文章: /archives\n  # 随笔: /tags/随笔\n\n# SubNav\nsubnav:\n  github: \"#\"\n  weibo: \"#\"\n  rss: \"#\"\n  zhihu: \"#\"\n  #douban: \"#\"\n  #mail: \"#\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\nrss: /atom.xml\n\n# Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n# Miscellaneous\ngoogle_analytics: ''\nfavicon: /favicon.png\n\n#你的头像url\navatar: \"\"\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n#是否开启友情链接\n#不开启——\n#friends: false\n#开启——\nfriends:\n  奥巴马的博客: http://localhost:4000/\n  卡卡的美丽传说: http://localhost:4000/\n  本泽马的博客: http://localhost:4000/\n  吉格斯的博客: http://localhost:4000/\n  习大大大不同: http://localhost:4000/\n  托蒂的博客: http://localhost:4000/\n\n#是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n```\n\n","source":"_posts/hexo-guide-2.md","raw":"---\ntitle: Hexo博客搭建教程（二）：Hexo博客的配置、使用\ndate: 2016-02-21 22:41:24\ntags: Hexo\n---\n本文主要介绍如何对Hexo博客站点进行个性化的设置、如何安装主题以及主题的设置。\n\n<!-- more -->\n经过上一篇文章，我们已经学会如何搭建Hexo博客以及将博客部署到github上了。这篇文章主要讲如何对自己的博客站点进行个性化配置以及如何发表新文章。\n博客的配置一个是站点的配置:`d:\\hexo\\_config.yml`，一个是主题的配置:`d:\\hexo\\themes\\yilia\\_config.yml`\n## 站点的配置\n```yml\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Superman的博客 #站定的名称\nsubtitle: 超人不会飞 #站点的副标题\ndescription: 超人前端学习博客 #站点的描述\nauthor: Superman \nemail: supermanchc@gmail.com\nlanguage: zh-Hans # 语言 使用中文需要使用zh-Hans\ntimezone:  #默认操作系统的时间\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n##url 在没有绑定域名前，不需要填写\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory 目录格式，不修改\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 写作布局，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Extensions 配置主题\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n\n# Deployment 配置部署github站点，改为自己的github repository\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/superman66/superman66.github.io.git\n  branch: master\n```\n## 安装新主题\nHexo此时用的是默认的主题，如果需要更换主题，可以去[主题市场](https://github.com/tommy351/hexo/wiki/Themes)挑选自己喜爱的主题。这里以安装`yilia`主题为例。\n#### 安装\n\n``` bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n#### 配置\n\n修改hexo根目录下 `_config.yml` 的themes: \n```yml\n# Extensions 配置主题\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n```\n\n#### 更新\n\n``` bash\ncd themes/yilia\ngit pull\n```\n## 配置主题\n这样就为你的博客站点安装了新的主题。接下来对主题进行配置\n主题配置文件在主目录下的`_config.yml`：\n```\n# Header\nmenu:\n  主页: /\n  所有文章: /archives\n  # 随笔: /tags/随笔\n\n# SubNav\nsubnav:\n  github: \"#\"\n  weibo: \"#\"\n  rss: \"#\"\n  zhihu: \"#\"\n  #douban: \"#\"\n  #mail: \"#\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\nrss: /atom.xml\n\n# Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n# Miscellaneous\ngoogle_analytics: ''\nfavicon: /favicon.png\n\n#你的头像url\navatar: \"\"\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n#是否开启友情链接\n#不开启——\n#friends: false\n#开启——\nfriends:\n  奥巴马的博客: http://localhost:4000/\n  卡卡的美丽传说: http://localhost:4000/\n  本泽马的博客: http://localhost:4000/\n  吉格斯的博客: http://localhost:4000/\n  习大大大不同: http://localhost:4000/\n  托蒂的博客: http://localhost:4000/\n\n#是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n```\n\n","slug":"hexo-guide-2","published":1,"updated":"2016-02-22T14:07:48.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c15001bm0pjf7jlnbka"},{"title":"Hexo博客搭建教程（一）：Hexo介绍及搭建","date":"2016-02-21T13:33:34.000Z","_content":"终于有了自己的github博客了。记录下搭建Github.io博客的过程以及当中所遇到的坑。\n\n<!-- more -->\n# Hexo是什么\nHexo是一个基于nodejs快速、简洁且高效的博客框架。可以方便的生成静态网页文件托管到github pages。具有超快渲染速度、支持GitHub Flavored Markdown语法、一键部署等优点，同时还拥有强大的插件系统，方便用户进行定制化开发。\n# Hexo 安装\n本教程只针对windows用户。\n## 安装前提\n在安装Hexo之前，请先安装\n* Node.js\n* Git\n\n## 安装 Git\n下载[msysgit](https://git-for-windows.github.io/)进行安装即可。\n## 安装 Nodejs\n在windows下安装nodejs非常简单，直接去[官网](https://nodejs.org/)下载进行安装即可。\n## 安装 Hexo\nHexo安装也很简单。在Git和Node.js都安装后，直接使用npm进行安装即可\n```bash\nnpm install -g hexo-cli\n```\n## 创建Hexo文件夹\n在你喜爱的文件夹下，如（`D:\\hexo`）,右键选择`git bash`,执行以下命令。便会自动新建所有的文件\n```bash\nhexo init\n```\n## 安装所依赖的包\n```bash\nnpm install\n```\n## 本地查看\n到这一步，你已经在本地安装了Hexo博客。你可以通过以下的命令在本地查看博客。\n### 生成静态文件\n```bash\nhexo generate\n```\n### 运行服务\n```bash\nhexo server\n```\n此时在浏览器中输入`localhost:4000`，便可以看到博客了。至此，本地博客已经搭建好了。但是此时博客还只是在本地，别人是无法访问的。\n\n# Github部署\n## 注册Github账号\n有账号的人跳过，没有的话[注册](https://github.com/)下也很简单。\n## 创建 repository\n在个人github主页右下角点击 `New repository`,创建一个新的repository。\n新的repository的名字应该跟你github账号的名字一样。比如我的github账号是`superman66`，\n那么新的repository的名字就应该为`superman66.github.io`。\n## 部署\n进入博客所在的文件夹(如`D:\\hexo`)，找到_config.yml文件，修改以下的配置，将下面的`superman66`都换成你自己的账户名。\n```\ndeploy:\n  type: git\n  repository: https://github.com/superman66/superman66.github.io.git\n  branch: master\n```\n*注意：hexo 3.0以下，type要写成 `github`*\n这个参数是用来配置网站一键部署的。让你只需要一条命令就可以将网站部署到服务器上。\n配置文件修改之后，执行一下命令便可以完成部署了。\n```bash\nhexo generate\nhexo deploy\n```\n\n### hexo常用命令\n* `hexo new \"post_name\"`用于生成新的文章；\n* `hexo generate`用于生成静态文件；\n* `hexo server` 用于启动本地服务；\n* `hexo deploy`用于将生成的静态文件部署到repository上。\n\n同时这四个命令还支持简写\n `hexo g` === `hexo generate`\n `hexo s` === `hexo server`\n `hexo d` === `hexo deploy`\n `hexo n` === `hexo new`\n 至此，你已经将本地的博客部署到github上。你可以通过username.github.io(`username`换成你自己的账户名)来访问你的博客了 \n\n ## 问题记录\n 在部署过程中，执行`hexo d`进行部署的时候，出现以下的错误\n **`hexo bash: /dev/tty: No such device or address`**\n ### 解决办法：\n 安装github for Window，点击这里进行[下载](https://github-windows.s3.amazonaws.com/GitHubSetup.exe),使用git shell再执行`hexo d`命令进行部署即可。\n ### 问题的原因：\n google找到的说法是，由于window安装的git版本问题导致的。\n","source":"_posts/hexo-guide-1.md","raw":"---\ntitle: Hexo博客搭建教程（一）：Hexo介绍及搭建\ndate: 2016-02-21 21:33:34\ntags: Hexo\n---\n终于有了自己的github博客了。记录下搭建Github.io博客的过程以及当中所遇到的坑。\n\n<!-- more -->\n# Hexo是什么\nHexo是一个基于nodejs快速、简洁且高效的博客框架。可以方便的生成静态网页文件托管到github pages。具有超快渲染速度、支持GitHub Flavored Markdown语法、一键部署等优点，同时还拥有强大的插件系统，方便用户进行定制化开发。\n# Hexo 安装\n本教程只针对windows用户。\n## 安装前提\n在安装Hexo之前，请先安装\n* Node.js\n* Git\n\n## 安装 Git\n下载[msysgit](https://git-for-windows.github.io/)进行安装即可。\n## 安装 Nodejs\n在windows下安装nodejs非常简单，直接去[官网](https://nodejs.org/)下载进行安装即可。\n## 安装 Hexo\nHexo安装也很简单。在Git和Node.js都安装后，直接使用npm进行安装即可\n```bash\nnpm install -g hexo-cli\n```\n## 创建Hexo文件夹\n在你喜爱的文件夹下，如（`D:\\hexo`）,右键选择`git bash`,执行以下命令。便会自动新建所有的文件\n```bash\nhexo init\n```\n## 安装所依赖的包\n```bash\nnpm install\n```\n## 本地查看\n到这一步，你已经在本地安装了Hexo博客。你可以通过以下的命令在本地查看博客。\n### 生成静态文件\n```bash\nhexo generate\n```\n### 运行服务\n```bash\nhexo server\n```\n此时在浏览器中输入`localhost:4000`，便可以看到博客了。至此，本地博客已经搭建好了。但是此时博客还只是在本地，别人是无法访问的。\n\n# Github部署\n## 注册Github账号\n有账号的人跳过，没有的话[注册](https://github.com/)下也很简单。\n## 创建 repository\n在个人github主页右下角点击 `New repository`,创建一个新的repository。\n新的repository的名字应该跟你github账号的名字一样。比如我的github账号是`superman66`，\n那么新的repository的名字就应该为`superman66.github.io`。\n## 部署\n进入博客所在的文件夹(如`D:\\hexo`)，找到_config.yml文件，修改以下的配置，将下面的`superman66`都换成你自己的账户名。\n```\ndeploy:\n  type: git\n  repository: https://github.com/superman66/superman66.github.io.git\n  branch: master\n```\n*注意：hexo 3.0以下，type要写成 `github`*\n这个参数是用来配置网站一键部署的。让你只需要一条命令就可以将网站部署到服务器上。\n配置文件修改之后，执行一下命令便可以完成部署了。\n```bash\nhexo generate\nhexo deploy\n```\n\n### hexo常用命令\n* `hexo new \"post_name\"`用于生成新的文章；\n* `hexo generate`用于生成静态文件；\n* `hexo server` 用于启动本地服务；\n* `hexo deploy`用于将生成的静态文件部署到repository上。\n\n同时这四个命令还支持简写\n `hexo g` === `hexo generate`\n `hexo s` === `hexo server`\n `hexo d` === `hexo deploy`\n `hexo n` === `hexo new`\n 至此，你已经将本地的博客部署到github上。你可以通过username.github.io(`username`换成你自己的账户名)来访问你的博客了 \n\n ## 问题记录\n 在部署过程中，执行`hexo d`进行部署的时候，出现以下的错误\n **`hexo bash: /dev/tty: No such device or address`**\n ### 解决办法：\n 安装github for Window，点击这里进行[下载](https://github-windows.s3.amazonaws.com/GitHubSetup.exe),使用git shell再执行`hexo d`命令进行部署即可。\n ### 问题的原因：\n google找到的说法是，由于window安装的git版本问题导致的。\n","slug":"hexo-guide-1","published":1,"updated":"2016-02-21T13:56:05.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c19001dm0pjbjcyegt5"},{"title":"AngularJS动态加载模块和依赖","date":"2016-02-24T14:23:54.000Z","_content":"由于AngularJS是单页面应用框架，在正常的情况下，会在访问页面的时候将所有的CSS、JavaScript文件都加载进来。文件不多的时候，页面启动速度倒不会影响太多。但是一旦文件数太多或者加载的第三方库比较大的时候，就会影响页面启动速度。因此对于应用规模大、文件数比较多或者加载的第三方库比较大的时候，采用动态加载JS或者动态加载模块会极大提升页面的启动速度。本文将介绍如何利用ocLazyLoad实现动态加载。\n<!-- more -->\nAngularJS动态加载依赖第三方库：[ocLazyLoad](https://oclazyload.readme.io/docs)。ocLazyLoad是一个第三方库，支持AngularJS动态加载`module`、`service`、`directive`以及静态文件。\n### 安装ocLazyLoad\n可通过npm或者bower进行安装\n```bash\nnpm install oclazyload\nbower install oclazyload\n```\n### 将`ocLazyLoad` module 添加到你的应用中\n```javascript\nangular.module('myApp',['oc.lazyLoad']);\n```\n### 配置 `ocLazyLoad`\n你可以在 `config`函数中配置 `$ocLazyLoadProvider`,配置文件如下\n```bash\n.config(['$ocLazyLoadProvider', function($ocLazyLoadProvider){\n    $ocLazyLoadProvider.config({\n        debug: true,\n        events: true,\n        modules: [\n            {\n                name: 'TestModule',\n                files: ['test.js']\n            }\n        ]\n    })\n}])\n```\n* debug: 用来开启debug模式。布尔值，默认是false。当开启debug模式时，$ocLazyLoad会打印出所有的错误到console控制台上。\n* events：当你动态加载了module的时候，$ocLazyLoad会广播相应的事件。布尔值，默认为false。\n* modules：用于定义你需要动态加载的模块。定义每个模块的名字需要唯一。\nmodules必须要用**数组**的形式，其中files也必须以**数组**的形式存在，哪怕只需要加载一个文件\n\n### 在路由当中加载module\n```bash\n    .config(['$routeProvider', function($routeProvider) {\n        $routeProvider.otherwise('/index');\n        $routeProvider.when('/index', {\n            templateUrl: 'index.html',\n            controller: 'IndexController',\n            resolve: { //  resolve 里的属性如果返回的是 promise对象，那么resolve将会在view加载之前执行\n                loadMyCtrl: ['$ocLazyLoad', function($ocLazyLoad) {\n                    // 在这里可以延迟加载任何文件或者刚才预定义的modules\n                    return $ocLazyLoad.load('TestModule'); //加载刚才定义的TestModule\n                    /*return $ocLazyLoad.load([   // 如果要加载多个module，需要写成数组的形式\n                        'TestModule',\n                        'MainModule'\n                        ]);*/\n                }]\n            }\n        })\n    }])\n```\nresolve设置的属性可以被注入到Controller当中。如果resolve返回的是promise对象的话，那么它们将在控制器加载以及$routeChangeSuccess被触发之前执行。\n**$ocLazyLoad就是利用这个原理hack，进行动态加载**。\n`resolve`的值可以是：\n* key，the value of key 是会被注入到Controller的依赖的名字；\n* factory，即可以是一个service的名字，也可以是一个返回值，它是会被注入到控制器中的函\n数或可以被resolve的promise对象。\n\n通过这样的配置，就可以实现了AngularJS动态加载模块和依赖。但是$ocLazyLoad提供的功能更加丰富，不止动态加载模块和依赖，还能动态加载service，diretive等。更多的功能，可以访问[$ocLazyLoad官网](https://oclazyload.readme.io)\n","source":"_posts/angular-lazyload.md","raw":"---\ntitle: AngularJS动态加载模块和依赖\ndate: 2016-02-24 22:23:54\ntags: \n- AngularJS\n- 动态加载\n---\n由于AngularJS是单页面应用框架，在正常的情况下，会在访问页面的时候将所有的CSS、JavaScript文件都加载进来。文件不多的时候，页面启动速度倒不会影响太多。但是一旦文件数太多或者加载的第三方库比较大的时候，就会影响页面启动速度。因此对于应用规模大、文件数比较多或者加载的第三方库比较大的时候，采用动态加载JS或者动态加载模块会极大提升页面的启动速度。本文将介绍如何利用ocLazyLoad实现动态加载。\n<!-- more -->\nAngularJS动态加载依赖第三方库：[ocLazyLoad](https://oclazyload.readme.io/docs)。ocLazyLoad是一个第三方库，支持AngularJS动态加载`module`、`service`、`directive`以及静态文件。\n### 安装ocLazyLoad\n可通过npm或者bower进行安装\n```bash\nnpm install oclazyload\nbower install oclazyload\n```\n### 将`ocLazyLoad` module 添加到你的应用中\n```javascript\nangular.module('myApp',['oc.lazyLoad']);\n```\n### 配置 `ocLazyLoad`\n你可以在 `config`函数中配置 `$ocLazyLoadProvider`,配置文件如下\n```bash\n.config(['$ocLazyLoadProvider', function($ocLazyLoadProvider){\n    $ocLazyLoadProvider.config({\n        debug: true,\n        events: true,\n        modules: [\n            {\n                name: 'TestModule',\n                files: ['test.js']\n            }\n        ]\n    })\n}])\n```\n* debug: 用来开启debug模式。布尔值，默认是false。当开启debug模式时，$ocLazyLoad会打印出所有的错误到console控制台上。\n* events：当你动态加载了module的时候，$ocLazyLoad会广播相应的事件。布尔值，默认为false。\n* modules：用于定义你需要动态加载的模块。定义每个模块的名字需要唯一。\nmodules必须要用**数组**的形式，其中files也必须以**数组**的形式存在，哪怕只需要加载一个文件\n\n### 在路由当中加载module\n```bash\n    .config(['$routeProvider', function($routeProvider) {\n        $routeProvider.otherwise('/index');\n        $routeProvider.when('/index', {\n            templateUrl: 'index.html',\n            controller: 'IndexController',\n            resolve: { //  resolve 里的属性如果返回的是 promise对象，那么resolve将会在view加载之前执行\n                loadMyCtrl: ['$ocLazyLoad', function($ocLazyLoad) {\n                    // 在这里可以延迟加载任何文件或者刚才预定义的modules\n                    return $ocLazyLoad.load('TestModule'); //加载刚才定义的TestModule\n                    /*return $ocLazyLoad.load([   // 如果要加载多个module，需要写成数组的形式\n                        'TestModule',\n                        'MainModule'\n                        ]);*/\n                }]\n            }\n        })\n    }])\n```\nresolve设置的属性可以被注入到Controller当中。如果resolve返回的是promise对象的话，那么它们将在控制器加载以及$routeChangeSuccess被触发之前执行。\n**$ocLazyLoad就是利用这个原理hack，进行动态加载**。\n`resolve`的值可以是：\n* key，the value of key 是会被注入到Controller的依赖的名字；\n* factory，即可以是一个service的名字，也可以是一个返回值，它是会被注入到控制器中的函\n数或可以被resolve的promise对象。\n\n通过这样的配置，就可以实现了AngularJS动态加载模块和依赖。但是$ocLazyLoad提供的功能更加丰富，不止动态加载模块和依赖，还能动态加载service，diretive等。更多的功能，可以访问[$ocLazyLoad官网](https://oclazyload.readme.io)\n","slug":"angular-lazyload","published":1,"updated":"2016-02-24T14:47:59.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cilzd6c1e001fm0pjlszrs0or"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cilzd6byi0000m0pj72ullfgc","tag_id":"cilzd6bys0001m0pjbt1q8bof","_id":"cilzd6byv0002m0pj7430jg79"},{"post_id":"cilzd6bzm0004m0pji06to1o9","tag_id":"cilzd6bzn0005m0pjc7eizh4s","_id":"cilzd6bzo0007m0pjxm3pymg6"},{"post_id":"cilzd6bzm0004m0pji06to1o9","tag_id":"cilzd6bzo0006m0pjcvcq8kpp","_id":"cilzd6bzp0008m0pjtdvhbgan"},{"post_id":"cilzd6bzr0009m0pjubjqnvxs","tag_id":"cilzd6bzn0005m0pjc7eizh4s","_id":"cilzd6bzu000am0pjndsf1kwg"},{"post_id":"cilzd6bzr0009m0pjubjqnvxs","tag_id":"cilzd6bzo0006m0pjcvcq8kpp","_id":"cilzd6bzu000bm0pjoqsilzla"},{"post_id":"cilzd6bzw000cm0pjt0qtjlr8","tag_id":"cilzd6bzx000dm0pjk6a2247s","_id":"cilzd6bzy000em0pjg8nkjltq"},{"post_id":"cilzd6bzz000fm0pjk9weeky1","tag_id":"cilzd6c00000gm0pj3wc0c1b9","_id":"cilzd6c01000hm0pj3g3863qy"},{"post_id":"cilzd6bzz000fm0pjk9weeky1","tag_id":"cilzd6bzx000dm0pjk6a2247s","_id":"cilzd6c01000im0pj4502rqd7"},{"post_id":"cilzd6c04000jm0pj9eiynaks","tag_id":"cilzd6c06000km0pjd4aprtd0","_id":"cilzd6c07000mm0pjsii6vrt9"},{"post_id":"cilzd6c04000jm0pj9eiynaks","tag_id":"cilzd6c07000lm0pjvek7lbqg","_id":"cilzd6c07000nm0pjxbcuh4u3"},{"post_id":"cilzd6c0a000om0pjo6p17mjk","tag_id":"cilzd6c06000km0pjd4aprtd0","_id":"cilzd6c0b000pm0pjmb9wzrvs"},{"post_id":"cilzd6c0e000qm0pj3it3bess","tag_id":"cilzd6c0g000rm0pj0e4pipxu","_id":"cilzd6c0i000um0pjt3fz2hqu"},{"post_id":"cilzd6c0e000qm0pj3it3bess","tag_id":"cilzd6c0h000sm0pjohbuylri","_id":"cilzd6c0i000vm0pjp5euxfak"},{"post_id":"cilzd6c0e000qm0pj3it3bess","tag_id":"cilzd6c0h000tm0pj485k08p6","_id":"cilzd6c0i000wm0pjg5araeww"},{"post_id":"cilzd6c0k000xm0pjrsdrdct0","tag_id":"cilzd6c0g000rm0pj0e4pipxu","_id":"cilzd6c0n000zm0pjgzxle3tv"},{"post_id":"cilzd6c0k000xm0pjrsdrdct0","tag_id":"cilzd6c0h000sm0pjohbuylri","_id":"cilzd6c0o0010m0pjtzbonu53"},{"post_id":"cilzd6c0k000xm0pjrsdrdct0","tag_id":"cilzd6c0n000ym0pj3ui2qlzy","_id":"cilzd6c0o0011m0pjm0ck94o1"},{"post_id":"cilzd6c0r0012m0pjlfuu4cwh","tag_id":"cilzd6bzo0006m0pjcvcq8kpp","_id":"cilzd6c0t0013m0pjxmdps4dv"},{"post_id":"cilzd6c0v0014m0pjjkomp3o2","tag_id":"cilzd6bzo0006m0pjcvcq8kpp","_id":"cilzd6c0x0015m0pjuk222fqt"},{"post_id":"cilzd6c0y0016m0pjx8b5vtke","tag_id":"cilzd6c0z0017m0pj66hjapyj","_id":"cilzd6c100018m0pjhhadjp1p"},{"post_id":"cilzd6c120019m0pjezvate2x","tag_id":"cilzd6c0z0017m0pj66hjapyj","_id":"cilzd6c13001am0pjx3edv01j"},{"post_id":"cilzd6c15001bm0pjf7jlnbka","tag_id":"cilzd6c0z0017m0pj66hjapyj","_id":"cilzd6c17001cm0pjw0s9ih72"},{"post_id":"cilzd6c19001dm0pjbjcyegt5","tag_id":"cilzd6c0z0017m0pj66hjapyj","_id":"cilzd6c1b001em0pjjisg6jl4"},{"post_id":"cilzd6c1e001fm0pjlszrs0or","tag_id":"cilzd6bys0001m0pjbt1q8bof","_id":"cilzd6c1h001hm0pjdgeo6u57"},{"post_id":"cilzd6c1e001fm0pjlszrs0or","tag_id":"cilzd6c1g001gm0pj08rbtcqk","_id":"cilzd6c1h001im0pjgyrr0bit"}],"Tag":[{"name":"AngularJS","_id":"cilzd6bys0001m0pjbt1q8bof"},{"name":"JavaScript","_id":"cilzd6bzn0005m0pjc7eizh4s"},{"name":"JavaScript学习笔记","_id":"cilzd6bzo0006m0pjcvcq8kpp"},{"name":"随笔","_id":"cilzd6bzx000dm0pjk6a2247s"},{"name":"阅读书单","_id":"cilzd6c00000gm0pj3wc0c1b9"},{"name":"移动端","_id":"cilzd6c06000km0pjd4aprtd0"},{"name":"rem布局","_id":"cilzd6c07000lm0pjvek7lbqg"},{"name":"JavaScript高级程序设计学习笔记","_id":"cilzd6c0g000rm0pj0e4pipxu"},{"name":"面向对象","_id":"cilzd6c0h000sm0pjohbuylri"},{"name":"对象","_id":"cilzd6c0h000tm0pj485k08p6"},{"name":"继承","_id":"cilzd6c0n000ym0pj3ui2qlzy"},{"name":"Hexo","_id":"cilzd6c0z0017m0pj66hjapyj"},{"name":"动态加载","_id":"cilzd6c1g001gm0pj08rbtcqk"}]}}